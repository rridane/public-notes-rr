:author-url: https://github.com/rridane
:author: rridane
:source-highlighter: rouge
:hardbreaks:
:table-caption!:
:toc: left

== Fichiers de configuration détaillés

== Introduction

Molecule est un framework de test conçu pour développer et tester des rôles Ansible de manière fiable et reproductible. Il permet de créer des environnements de test isolés, d'appliquer les rôles, et de vérifier leur bon fonctionnement.

== Architectude des dossiers "état de l'art"

[source,bash]
----
roles/
└── mon_role/
    ├── defaults/
    ├── files/
    ├── handlers/
    ├── meta/
    ├── tasks/
    ├── templates/
    ├── tests/
    └── molecule/                    # Dossier contenant les scénarios de test
        ├── default/                 # Scénario par défaut
        │   ├── molecule.yml         # Configuration principale du scénario
        │   ├── converge.yml         # Playbook qui applique le rôle
        │   ├── prepare.yml          # (Optionnel) Playbook de préparation
        │   └── verify.yml           # Playbook de vérification (tests)
        ├── alternative-scenario/    # Autre scénario (ex: multi-node, autre OS)
        │   ├── molecule.yml
        │   ├── converge.yml
        │   └── ...
        └── shared/                  # (Optionnel) Fichiers partagés entre scénarios
            └── verify.yml           # Fichier de vérification commun
----


=== molecule.yml

Fichier de configuration principal d'un scénario Molecule :

[source,yaml]
----
---
dependency:
  name: galaxy
  # Options:
  #   name: galaxy (dépendances Ansible Galaxy) ou shell (script personnalisé)
  #   options:
  #     role-file: requirements.yml  # Fichier des dépendances
  #     requirements-file: collections.yml  # Fichier des collections

driver:
  name: docker
  # Autres drivers: vagrant, ec2, openstack, etc.

platforms:
  - name: instance
    image: ubuntu:20.04
    # Options Docker spécifiques:
    pre_build_image: true  # Utiliser une image pré-construite
    dockerfile: Dockerfile.j2  # Dockerfile personnalisé (optionnel)
    command: /sbin/init  # Commande de démarrage (nécessaire pour systemd)
    privileged: true  # Mode privilégié (requis pour systemd)
    volumes:
      - /sys/fs/cgroup:/sys/fs/cgroup:ro  # Montage nécessaire pour systemd
    published_ports:
      - "80:80"  # Ports à exposer
    # Configuration réseau:
    networks:
      - name: moleculenet
    # Variables d'environnement:
    env:
      TZ: UTC
    # Configuration de ressources:
    tmpfs:
      - /tmp
    ulimits:
      - nofile:262144:262144

provisioner:
  name: ansible
  config_options:
    defaults:
      # Options ansible.cfg
      interpreter_python: auto_silent
      # Désactiver la vérification de clé SSH (pour les tests)
      host_key_checking: false
      # Timeout pour les connexions
      timeout: 30
      # Nombre de forks
      forks: 5
    # Options de connexion SSH
    ssh_connection:
      pipelining: true
      control_path: "%(directory)s/%%h-%%p-%%r"
  # Inventaire personnalisé (optionnel)
  inventory:
    group_vars:
      all:
        # Variables communes à tous les groupes
        example_var: value
    host_vars:
      instance:
        # Variables spécifiques à l'hôte
        host_specific_var: value
  # Playbooks personnalisés
  playbooks:
    create: create.yml  # Création personnalisée (rare)
    prepare: prepare.yml  # Préparation avant convergence
    converge: converge.yml  # Application du rôle
    destroy: destroy.yml  # Nettoyage personnalisé (rare)

verifier:
  name: ansible
  # Autres options: testinfra, goss, etc.
  # Options pour le verifier ansible:
  playbooks:
    verify: verify.yml
  # Options pour testinfra:
  # directory: tests/
  # options:
  #   sudo: true

# Hooks (scripts exécutés à différentes étapes)
# Les hooks peuvent être des scripts shell ou des playbooks Ansible
hooks:
  # Hooks pour le scénario complet
  pre_scenario: |
    echo "Début du scénario"
  post_scenario: |
    echo "Fin du scénario"

  # Hooks par étape
  create:
    pre: pre_create.yml  # Playbook Ansible avant création
    post: post_create.sh  # Script shell après création
  converge:
    pre: pre_converge.sh
    post: post_converge.yml
  destroy:
    pre: pre_destroy.yml
    post: post_destroy.sh
----

=== converge.yml

Playbook principal qui applique le rôle à tester :

[source,yaml]
----
---
- name: Converge
  hosts: all
  # Stratégie d'exécution
  strategy: linear
  # Devenir root (si nécessaire)
  become: true
  # Variables pour le test
  vars:
    test_variable: test_value
  # Pré-tâches (configuration préalable)
  pre_tasks:
    - name: "Pré-tâche: Mettre à jour le cache des paquets"
      apt:
        update_cache: yes
        cache_valid_time: 3600
      when: ansible_os_family == "Debian"
  # Rôle à tester
  roles:
    - role: ../../  # Référence au rôle parent
  # Post-tâches (nettoyage ou configuration supplémentaire)
  post_tasks:
    - name: "Post-tâche: Vérifier l'état du service"
      service:
        name: "{{ service_name }}"
        state: started
      register: service_status
    - name: "Afficher le statut du service"
      debug:
        var: service_status
----

=== prepare.yml (optionnel)

Playbook de préparation exécuté avant la convergence :

[source,yaml]
----
---
- name: Prepare
  hosts: all
  tasks:
    - name: Installer les dépendances système
      package:
        name:
          - python3
          - sudo
        state: present
      when: ansible_os_family == "RedHat"

    - name: Configurer le timezone
      timezone:
        name: UTC

    - name: Désactiver SELinux (pour les tests)
      selinux:
        state: disabled
      when: ansible_os_family == "RedHat"
----

=== verify.yml

Playbook de vérification exécuté après la convergence :

[source,yaml]
----
---
- name: Verify
  hosts: all
  tasks:
    - name: Vérifier que le service est actif
      ansible.builtin.service:
        name: "{{ service_name }}"
        state: started
      changed_when: false
      tags: verify

    - name: Vérifier que le port écoute
      wait_for:
        port: "{{ service_port }}"
        timeout: 10
      tags: verify

    - name: Vérifier le contenu d'un fichier de configuration
      assert:
        that:
          - "'option_value' in file_content"
        success_msg: "L'option est présente dans le fichier"
        fail_msg: "L'option est manquante dans le fichier"
      vars:
        file_content: "{{ lookup('file', '/etc/service/config.conf') }}"
      tags: verify

    - name: Vérifier les permissions d'un fichier
      file:
        path: /etc/service/config.conf
        owner: root
        group: root
        mode: "0644"
      changed_when: false
      tags: verify
----


== Les Vérifieurs (Verifiers) : Stratégies de Validation

Le bloc `verifier:` dans `molecule.yml` définit le moteur de test utilisé pendant la phase `molecule verify` pour s'assurer que l'état final du système est conforme aux attentes.

.Principaux vérifieurs et quand les utiliser
[options="header"]
|===
| Vérifieur | Langage | Points Forts | Ideal pour
| `ansible` | Ansible/YAML | Aucune dépendance supplémentaire | Vérifications simples avec des modules Ansible
| `testinfra` | Python/Pytest | Expressivité et puissance de Python | Tests complexes, paramétrés
| `goss` | YAML | Syntaxe déclarative simple et lisible | Tests de conformité, tests rapides
|===

=== 1. Vérifieur `ansible` : La Méthode Native

**Quand l'utiliser :**
* Vous voulez rester à 100% dans l'écosystème Ansible
* Vos vérifications sont simples
* Vous ne voulez aucune dépendance Python supplémentaire

**Configuration :**
[source,yaml]
----
verifier:
  name: ansible
  playbooks:
    verify: verify.yml
----

**Exemple de playbook de vérification :**
[source,yaml]
----
---
- name: Verify
  hosts: all
  tasks:
    - name: Verify the service is running
      ansible.builtin.service:
        name: nginx
        state: started
      changed_when: false
----

=== 2. Vérifieur `testinfra` : La Puissance de Python

**Quand l'utiliser :**
* Vous avez besoin de tests complexes avec de la logique
* Vous voulez utiliser la puissance de Pytest
* Vous êtes à l'aise avec Python

**Configuration :**
[source,yaml]
----
verifier:
  name: testinfra
  directory: tests/
  options:
    v: true
----

**Exemple de test Testinfra :**
[source,python]
----
def test_nginx_service(host):
    nginx = host.service("nginx")
    assert nginx.is_running
    assert nginx.is_enabled
----

=== 3. Vérifieur `goss` : La Simplicité Declarative

**Quand l'utiliser :**
* Vous voulez des tests très simples et rapides à écrire
* La performance d'exécution est critique
* Vous préférez une syntaxe déclarative

**Configuration :**
[source,yaml]
----
verifier:
  name: goss
  directory: tests/
  options:
    format: documentation
----

**Exemple de fichier Goss :**
[source,yaml]
----
service:
  nginx:
    enabled: true
    running: true
----

== Les Vérifieurs (Verifiers) : Stratégies de Validation

Le bloc `verifier:` dans `molecule.yml` définit le moteur de test utilisé pendant la phase `molecule verify` pour s'assurer que l'état final du système est conforme aux attentes.

.Principaux vérifieurs et quand les utiliser
[options="header"]
|===
| Vérifieur | Langage | Points Forts | Ideal pour
| `ansible` | Ansible/YAML | Aucune dépendance supplémentaire | Vérifications simples avec des modules Ansible
| `testinfra` | Python/Pytest | Expressivité et puissance de Python | Tests complexes, paramétrés
| `goss` | YAML | Syntaxe déclarative simple et lisible | Tests de conformité, tests rapides
|===

=== 1. Vérifieur `ansible` : La Méthode Native

**Quand l'utiliser :**
* Vous voulez rester à 100% dans l'écosystème Ansible
* Vos vérifications sont simples
* Vous ne voulez aucune dépendance Python supplémentaire

**Configuration :**
[source,yaml]
----
verifier:
  name: ansible
  playbooks:
    verify: verify.yml
----

**Exemple de playbook de vérification :**
[source,yaml]
----
---
- name: Verify
  hosts: all
  tasks:
    - name: Verify the service is running
      ansible.builtin.service:
        name: nginx
        state: started
      changed_when: false
----

=== 2. Vérifieur `testinfra` : La Puissance de Python

**Quand l'utiliser :**
* Vous avez besoin de tests complexes avec de la logique
* Vous voulez utiliser la puissance de Pytest
* Vous êtes à l'aise avec Python

**Configuration :**
[source,yaml]
----
verifier:
  name: testinfra
  directory: tests/
  options:
    v: true
----

**Exemple de test Testinfra :**
[source,python]
----
def test_nginx_service(host):
    nginx = host.service("nginx")
    assert nginx.is_running
    assert nginx.is_enabled
----

=== 3. Vérifieur `goss` : La Simplicité Declarative

**Quand l'utiliser :**
* Vous voulez des tests très simples et rapides à écrire
* La performance d'exécution est critique
* Vous préférez une syntaxe déclarative

**Configuration :**
[source,yaml]
----
verifier:
  name: goss
  directory: tests/
  options:
    format: documentation
----

**Exemple de fichier Goss :**
[source,yaml]
----
service:
  nginx:
    enabled: true
    running: true
----

== Explication du Multi-Node Testing

L'exemple de configuration multi-node présenté dans le guide permet de tester des rôles qui nécessitent une interaction entre plusieurs machines. Ce scénario est particulièrement utile pour :

* **Tests d'architecture client-serveur** : Vérifier le bon fonctionnement entre un serveur et ses clients
* **Tests de clustering** : Valider la configuration de clusters (base de données, application, etc.)
* **Tests de communication réseau** : Vérifier la connectivité et les règles de firewall
* **Tests de load balancing** : Valider la distribution de charge entre plusieurs nœuds

Dans l'exemple fourni :
* Deux instances sont créées : `server` et `client`
* Chaque instance a une configuration spécifique via `host_vars`
* Le montage `/sys/fs/cgroup:/sys/fs/cgroup:ro` est nécessaire pour systemd
* Le mode `privileged: true` permet aux conteneurs d'avoir des privilèges étendus

=== Exemple de configuration multi-node

[source,yaml]
----
# molecule.yml
platforms:
  - name: server
    image: ubuntu:20.04
    privileged: true
    command: /sbin/init
    volumes:
      - /sys/fs/cgroup:/sys/fs/cgroup:ro

  - name: client
    image: ubuntu:20.04
    privileged: true
    command: /sbin/init
    volumes:
      - /sys/fs/cgroup:/sys/fs/cgroup:ro

provisioner:
  inventory:
    group_vars:
      all:
        common_var: value
    host_vars:
      server:
        role: server
      client:
        role: client
----

== Explication des Tags Verify

Les tags `verify` dans le playbook de vérification *ne sont pas obligatoires* mais fortement recommandés pour :

1. **Organisation** : Permettre d'exécuter spécifiquement les tâches de vérification
2. **Modularité** : Faciliter la réutilisation des tâches dans différents contextes
3. **Performance** : Permettre de sauter les vérifications si nécessaire

[source,bash]
----
# Exécuter uniquement les tâches tagguées "verify"
ansible-playbook verify.yml --tags verify

# Exécuter toutes les tâches sauf celles tagguées "verify"
ansible-playbook verify.yml --skip-tags verify
----

== Scripts Python Avancés et Situations Complexes

=== Utilisation de Tests Personnalisés avec Python

Molecule supporte l'intégration de tests personnalisés écrits en Python via différents verifyers :

==== Testinfra (Recommandé)

1. **Installation** :
[source,bash]
----
pip install molecule testinfra
----

2. **Création de tests** :
[source,python]
----
# molecule/default/tests/test_service.py
import pytest

def test_nginx_is_installed(host):
    nginx = host.package("nginx")
    assert nginx.is_installed

def test_nginx_is_running(host):
    nginx = host.service("nginx")
    assert nginx.is_running
    assert nginx.is_enabled

def test_nginx_listening_on_port_80(host):
    socket = host.socket("tcp://0.0.0.0:80")
    assert socket.is_listening
----

3. **Configuration Molecule** :
[source,yaml]
----
verifier:
  name: testinfra
  directory: tests/
  options:
    sudo: true
----

==== Integration avec des Bibliothèques Python Personnalisées

1. **Création d'un verifyer personnalisé** :
[source,python]
----
# molecule/custom_verifier.py
#!/usr/bin/env python3
import json
import requests

def main():
    # Logique de test personnalisée
    response = requests.get("http://localhost:80")
    assert response.status_code == 200
    print("Custom verification passed")

if __name__ == "__main__":
    main()
----

2. **Exécution via Hooks** :
[source,yaml]
----
hooks:
  verify:
    pre: python molecule/custom_verifier.py
----

=== Scénarios Complexes

==== Tests de Haute Disponibilité

[source,yaml]
----
# molecule/ha-scenario/molecule.yml
platforms:
  - name: loadbalancer
    image: ubuntu:20.04
    privileged: true
    command: /sbin/init
    volumes:
      - /sys/fs/cgroup:/sys/fs/cgroup:ro
    published_ports:
      - "80:80"

  - name: webserver-01
    image: ubuntu:20.04
    privileged: true
    command: /sbin/init
    volumes:
      - /sys/fs/cgroup:/sys/fs/cgroup:ro

  - name: webserver-02
    image: ubuntu:20.04
    privileged: true
    command: /sbin/init
    volumes:
      - /sys/fs/cgroup:/sys/fs/cgroup:ro

provisioner:
  inventory:
    group_vars:
      all:
        lb_backend_servers:
          - webserver-01
          - webserver-02
    host_vars:
      loadbalancer:
        role: loadbalancer
      webserver-01:
        role: webserver
      webserver-02:
        role: webserver
----

==== Tests de Montée de Version

[source,yaml]
----
# molecule/upgrade-scenario/molecule.yml
platforms:
  - name: instance
    image: ubuntu:18.04  # Version ancienne
    privileged: true
    command: /sbin/init
    volumes:
      - /sys/fs/cgroup:/sys/fs/cgroup:ro

hooks:
  converge:
    post: upgrade_playbook.yml  # Playbook de mise à jour
----

== Intégration avec CI/CD

Exemple de configuration GitHub Actions avancée :

[source,yaml]
----
name: Molecule Test

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        scenario: [default, multi-node, ha-scenario]
        python-version: [3.8, 3.9]

    services:
      docker:
        image: docker:dind
        options: --privileged

    steps:
    - uses: actions/checkout@v3

    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ matrix.python-version }}

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install ansible molecule molecule-docker docker testinfra

    - name: Test with Molecule
      run: molecule test -s ${{ matrix.scenario }}
      env:
        PY_COLORS: '1'
        ANSIBLE_FORCE_COLOR: '1'
        DOCKER_HOST: tcp://localhost:2375

    - name: Upload logs on failure
      if: failure()
      uses: actions/upload-artifact@v3
      with:
        name: molecule-logs-${{ matrix.scenario }}
        path: molecule/${{ matrix.scenario }}/molecule.log
----

== Bonnes Pratiques Avancées

=== Tests de Performance

[source,yaml]
----
# molecule/performance-scenario/verify.yml
- name: Performance Test
  hosts: all
  tasks:
    - name: Run performance test
      shell: |
        ab -n 1000 -c 10 http://localhost:80/
      register: ab_result
      changed_when: false

    - name: Verify response time
      assert:
        that:
          - ab_result.stdout | regex_search('Time per request.*(\\d+\\.\\d+)') | float < 50.0
        fail_msg: "Response time too high"
----

=== Tests de Sécurité

[source,yaml]
----
# molecule/security-scenario/verify.yml
- name: Security Tests
  hosts: all
  tasks:
    - name: Check for open ports
      shell: netstat -tuln
      register: netstat_result
      changed_when: false

    - name: Verify only expected ports are open
      assert:
        that:
          - "80 in netstat_result.stdout"
          - "22 in netstat_result.stdout"
          - "443 in netstat_result.stdout"
          - "3306 not in netstat_result.stdout"
        fail_msg: "Unexpected ports open"
----

=== Tests de Chaos Engineering

[source,yaml]
----
# molecule/chaos-scenario/converge.yml
- name: Chaos Test
  hosts: all
  tasks:
    - name: Simulate network failure
      shell: iptables -A INPUT -p tcp --dport 80 -j DROP
      when: chaos_network_failure | default(false) | bool

    - name: Simulate service failure
      shell: systemctl stop nginx
      when: chaos_service_failure | default(false) | bool
      ignore_errors: yes
----

== Dépannage Avancé

=== Debugging avec Visual Studio Code

[source,json]
----
// .vscode/launch.json
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Molecule Test",
      "type": "python",
      "request": "launch",
      "program": "/usr/local/bin/molecule",
      "args": ["test", "-s", "default", "--debug"],
      "console": "integratedTerminal"
    }
  ]
}
----

=== Tests de Récupération

[source,yaml]
----
# molecule/recovery-scenario/molecule.yml
platforms:
  - name: instance
    image: ubuntu:20.04
    privileged: true
    command: /sbin/init
    volumes:
      - /sys/fs/cgroup:/sys/fs/cgroup:ro

hooks:
  create:
    post: simulate_failure.sh  # Script qui corrompt délibérément le système
----

== Conclusion

Molecule est un outil extrêmement puissant pour tester des rôles Ansible dans des environnements complexes et variés. En utilisant les fonctionnalités avancées présentées dans ce guide, vous pouvez créer des tests complets qui couvrent une large gamme de scénarios, desde tests unitaires simples jusqu'aux tests d'architecture complexes multi-nœuds.

Les tags `verify` ne sont pas obligatoires mais fortement recommandés pour une meilleure organisation des tests. L'intégration de scripts Python personnalisés et de verifyers comme Testinfra permet d'étendre considérablement les capacités de test de Molecule.

En suivant les bonnes pratiques et les exemples avancés présentés dans ce guide, vous serez en mesure de créer une suite de tests robuste et complète pour vos rôles Ansible.