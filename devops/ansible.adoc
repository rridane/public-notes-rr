:author-url: https://github.com/rridane
:author: rridane
:source-highlighter: rouge
:hardbreaks:
:table-caption!:
:toc: left

== Configuration & Inventories

=== ansible.cfg (Deep-dive)

==== Ordre de la configuration

Ansible cherche sa configuration dans l'ordre suivant :

* variable d'environnement : **ANSIBLE_CONFIG**
* fichier **ansible.cfg** dans le répertoire courant
* fichier **~/.ansible.cfg** dans le dossier home
* fichier **/etc/ansible/ansible.cfg**

[TIP]
--
Diagnostiquer ce qui est réellement appliqué :
[source,bash]
ansible-config view # fichier effectif
ansible-config dump --only-changed
ansible-config list # catalogue complet des options
--

==== Principales sections d'un **ansible.cfg**

* [defaults] : comportement global (inventory, callbacks, diff, gather, paths…)
* [ssh_connection] : tuning de la connexion SSH (pipelining, multiplexing…)
* [privilege_escalation] : sudo par défaut (become)
* Sections additionnelles selon besoin : [inventory], [galaxy], [colors], etc.

.ansible.cfg (commenté)
[source, bash]
----
[defaults]

# Chemin par défaut de l’inventaire (évite -i partout)
inventory = inventories/staging/hosts.ini

# Auto-détection silencieuse du Python distant (utile sur OS minimal)
interpreter_python = auto_silent

# Sortie plus lisible par défaut (YAML)
stdout_callback = yaml

# Autorise l’exécution des callbacks (profilage, timer…)
bin_ansible_callbacks = True

## (Lab/CI) Désactive la vérif d’empreinte SSH ; en prod → True + known_hosts géré
# host_key_checking = False

# Timeout de connexion SSH (secondes)
timeout = 30

# Écrit des .retry pour rejouer facilement les hôtes en échec
retry_files_enabled = True

# Répertoire(s) des rôles (séparer par ":" si multiple)
roles_path = roles

# Où Ansible cherche/installe les collections
collections_paths = collections

# Parallélisme (nb d’hôtes en parallèle)
forks = 20

# Collecte “intelligente” des facts (cache-friendly)
gathering = smart

# Active les callbacks de profilage : temps par tâche + temps total
callbacks_enabled = profile_tasks,timer

# -------- Fact cache (accélère les runs répétés) --------
# Type de cache de facts (ici fichiers JSON locaux)
fact_caching = jsonfile

# Dossier de cache des facts
fact_caching_connection = .fact_cache

# Durée de validité du cache (secondes) → 1 jour
fact_caching_timeout = 86400
----

.Section SSH
[source,bash]
----
[ssh_connection]
# Réduit les allers-retours SSH (plus rapide). Attention à requiretty côté sudo.
pipelining = True
----

.Ignorer le cache et les retry dans Git
[source,bash]
----
echo ".fact_cache/" >> .gitignore
echo ".retry/" >> .gitignore
----

=== liste exhaustive des commandes

[source,shell]
----
ansible -i inventories/staging/hosts.ini all -m ping
----

.liste des commandes ansible
[source,bash]
----
ansible all -m ping # Test simple de connectivité (module ping), all pour all hosts
ansible all -a "uptime" # Commande ad-hoc (module command par défaut)
ansible web -m shell -a "df -h" # Utiliser explicitement le module shell

ansible-playbook playbooks/site.yml # Exécuter un playbook
ansible-playbook -i inventories/prod/hosts.ini playbooks/site.yml # Forcer un inventaire INI
ansible-playbook -i inventories/prod/hosts.yml playbooks/site.yml # Forcer un inventaire YAML

ansible-playbook -i inventories/prod/hosts.ini -l server1 playbooks/site.yml # --limit : cibler un hôte/groupe/pattern dans l'inventory de prod
ansible-playbook -t motd playbooks/site.yml # --tags : exécuter seulement certaines tâches
ansible-playbook --skip-tags motd playbooks/site.yml # --skip-tags : ignorer des tâches
ansible-playbook --list-tags playbooks/site.yml # Lister les tags disponibles
ansible-playbook --list-tasks playbooks/site.yml # Lister toutes les tâches
ansible-playbook --list-hosts playbooks/site.yml # Lister les hôtes ciblés

ansible-playbook --check playbooks/site.yml # Dry-run : simuler sans changer l’état
ansible-playbook --diff playbooks/site.yml # Afficher les diffs (templates/copy)
ansible-playbook --step playbooks/site.yml # Exécution pas-à-pas
ansible-playbook --start-at-task "Installer Nginx" playbooks/site.yml # Reprendre à partir d’une tâche
ansible-playbook --syntax-check playbooks/site.yml # Vérifier la syntaxe

ansible-playbook -v playbooks/site.yml # Verbosité 1
ansible-playbook -vv playbooks/site.yml # Verbosité 2
ansible-playbook -vvv playbooks/site.yml # Verbosité 3 (debug)
ansible-playbook -vvvv playbooks/site.yml # Verbosité 4 (SSH debug)

ansible-playbook -u ubuntu playbooks/site.yml # Utilisateur SSH
ansible-playbook --private-key=~/.ssh/id_rsa playbooks/site.yml # Clé privée SSH
ansible-playbook -b playbooks/site.yml # become (sudo)
ansible-playbook --become-user=root playbooks/site.yml # Changer d’utilisateur

ansible-playbook -e "motd_message='Hello world'" playbooks/site.yml # Variables inline
ansible-playbook -e "@vars.yml" playbooks/site.yml # Charger un fichier YAML
ansible-playbook -e '{"list":[1,2],"obj":{"a":1}}' playbooks/site.yml # JSON inline

ansible-inventory -i inventories/prod/hosts.ini --list --yaml # Afficher l’inventaire résolu
ansible-inventory -i inventories/prod/hosts.ini --graph # Graphe groupes↔hôtes
ansible-inventory -i inventories/prod/hosts.ini --host server1 # Variables effectives d’un hôte

ansible-doc -l # Lister tous les modules
ansible-doc copy # Aide détaillée sur un module
ansible-config list # Lister toutes les options
ansible-config view # Voir la configuration active
ansible-config dump # Afficher paramètres + source

ansible-galaxy init roles/nginx # Générer un rôle
ansible-galaxy install geerlingguy.nginx # Installer un rôle Galaxy
ansible-galaxy collection install community.general # Installer une collection

ansible-vault create group_vars/all/vault.yml # Créer un fichier chiffré
ansible-vault edit group_vars/all/vault.yml # Éditer un fichier chiffré
ansible-vault encrypt_string 'secret' --name 'db_password' # Variable inline chiffrée
ansible-playbook --ask-vault-pass playbooks/site.yml # Demander le mot de passe Vault
ansible-playbook --vault-password-file ~/.vault_pass # Fournir le pass Vault via fichier
----

.fiche ciblage & variables (patterns, limit, vars, vault)
[source,bash]
----
# -------------------------
# Patterns d’hôtes
# -------------------------

ansible all -m ping # Tous les hôtes
ansible web -m ping # Groupe "web"
ansible 'web:&prod' -m ping # Intersection (web ET prod)
ansible 'web:!db' -m ping # Exclusion (web SAUF db)
ansible 'server1,server2' -m ping # Union explicite
ansible 'web[1:3]' -m ping # Plage de noms (web1..web3)

# -------------------------
# --limit
# -------------------------

ansible-playbook -i inventories/prod/hosts.ini -l server1 playbooks/site.yml # Un seul hôte
ansible-playbook -l 'web:!db' playbooks/site.yml # Pattern combiné
ansible-playbook -l '@/path/run.retry' playbooks/site.yml # Rejouer hôtes en échec

# -------------------------
# Inventaires & introspection
# -------------------------

ansible-inventory -i inventories/prod/hosts.ini --graph # Vue graphe
ansible-inventory -i inventories/prod/hosts.ini --host server1 # Vars d’un hôte
ansible-playbook --list-hosts playbooks/site.yml # Hôtes ciblés par le playbook

# -------------------------
# Variables
# -------------------------

ansible-playbook -e "env=prod version=1.2.3" playbooks/site.yml # Variables inline
ansible-playbook -e "@vars/common.yml" playbooks/site.yml # Fichier YAML
ansible-playbook -e '{"features":["a","b"],"replicas":3}' playbooks/site.yml # JSON inline

# -------------------------
# Facts & debug
# -------------------------

ansible server1 -m setup -a 'filter=ansible_*_version' # Inspecter certains facts
ansible server1 -m debug -a 'var=ansible_facts' # Afficher les facts
ansible server1 -m debug -a 'var=vars.some_var' # Afficher une variable définie

# -------------------------
# Vault
# -------------------------

ansible-vault create group_vars/all/vault.yml # Créer un fichier chiffré
ansible-vault edit group_vars/all/vault.yml # Éditer
ansible-vault encrypt_string 'p@ssw0rd' --name 'db_password' # Var chiffrée inline
ansible-playbook --ask-vault-pass playbooks/site.yml # Mot de passe demandé
ansible-playbook --vault-password-file ~/.vault_pass # Pass via fichier

# -------------------------
# Connexion & privilèges
# -------------------------

ansible-playbook -u ubuntu --private-key=~/.ssh/id_rsa playbooks/site.yml # User + clé
ansible-playbook -b --become-user=root playbooks/site.yml # sudo + user ciblé

# -------------------------
# Ordre de résolution des variables
# -------------------------
1) defaults/ (rôle)
2) group_vars/ host_vars/
3) vars du play
4) vars de tâche
5) -e / --extra-vars (priorité max)
----

== Les tâches

=== Directives Conditionnelles et Contrôle d'Exécution

==== La directive `when` - Condition d'exécution de base

La directive `when` permet d'exécuter une tâche conditionnellement, basée sur l'évaluation d'une expression.

===== Syntaxe de base

[source,yaml]
----
tasks:
  - name: "Arrêter le service en maintenance"
    ansible.builtin.service:
      name: apache2
      state: stopped
    when: maintenance_mode | bool
----

===== Conditions complexes avec opérateurs logiques

[source,yaml]
----
tasks:
  - name: "Configurer uniquement sur Debian/Ubuntu"
    ansible.builtin.template:
      src: debian_config.j2
      dest: /etc/app/config
    when:
      - ansible_facts['os_family'] == "Debian"
      - ansible_facts['distribution'] == "Ubuntu"

  - name: "Exécuter sur les serveurs web ou en dev"
    ansible.builtin.command: /opt/scripts/setup.sh
    when:
      - "'webservers' in group_names" or
        env == 'development'
----

===== Tests avec les facts Ansible

[source,yaml]
----
tasks:
  - name: "Installer un package spécifique à l'OS"
    ansible.builtin.package:
      name: "{{ 'nfs-common' if ansible_os_family == 'Debian' else 'nfs-utils' }}"
      state: present
    when: ansible_os_family in ["Debian", "RedHat"]

  - name: "Vérifier l'espace disque disponible"
    ansible.builtin.command: df -h
    when: ansible_memtotal_mb < 1024
----

==== Directives de contrôle de tâche

===== Contrôle du statut d'exécution

`changed_when` et `failed_when` permettent de redéfinir ce qui constitue un changement ou une erreur.

[source,yaml]
----
tasks:
  - name: "Vérifier le statut d'un service custom"
    ansible.builtin.command: check_my_service.sh
    register: service_check
    changed_when: "'RESTARTED' in service_check.stdout"
    failed_when:
      - "'ERROR' in service_check.stdout"
      - "service_check.rc != 0"

  - name: "Script avec codes de sortie non standard"
    ansible.builtin.command: /opt/custom_script.sh
    register: script_result
    failed_when:
      - "script_result.rc != 0"
      - "script_result.rc != 2"  # Le code 2 est acceptable
----

===== Gestion des erreurs

`ignore_errors` permet de continuer l'exécution même en cas d'échec.

[source,yaml]
----
tasks:
  - name: "Tentative de connexion à un service optionnel"
    ansible.builtin.wait_for:
      host: "{{ optional_service_host }}"
      port: "{{ optional_service_port }}"
      timeout: 10
    ignore_errors: yes

  - name: "Journaliser l'échec sans interrompre"
    ansible.builtin.debug:
      msg: "Le service optionnel n'est pas disponible"
    when: optional_service_result is failed
----

==== Boucles et itérations

===== Boucle simple avec `loop`

[source,yaml]
----
tasks:
  - name: "Créer plusieurs utilisateurs"
    ansible.builtin.user:
      name: "{{ item }}"
      state: present
      groups: "users"
    loop:
      - alice
      - bob
      - charlie
----

===== Boucle sur des listes complexes

[source,yaml]
----
tasks:
  - name: "Ajouter des clés SSH aux utilisateurs"
    ansible.builtin.authorized_key:
      user: "{{ item.user }}"
      key: "{{ item.key }}"
    loop:
      - { user: 'alice', key: 'ssh-rsa AAAAB3...' }
      - { user: 'bob', key: 'ssh-rsa BBBBBBB...' }
    loop_control:
      label: "{{ item.user }}"  # Affiche seulement le nom dans les logs
----

===== Boucles avec conditions

[source,yaml]
----
tasks:
  - name: "Déployer configs seulement pour les services activés"
    ansible.builtin.template:
      src: "{{ item }}.j2"
      dest: "/etc/{{ item }}.conf"
    loop: "{{ services }}"
    when: item.enabled | default(false) | bool
----

==== Contrôle d'exécution avancé

===== Délégation avec `delegate_to`

[source,yaml]
----
tasks:
  - name: "Vérifier la connectivité depuis le bastion"
    ansible.builtin.wait_for:
      host: "{{ external_service }}"
      port: 443
      timeout: 30
    delegate_to: bastion.example.com

  - name: "Exécuter une tâche locale"
    ansible.builtin.copy:
      src: local_file.txt
      dest: /tmp/
    delegate_to: localhost
----

===== Exécution unique avec `run_once`

[source,yaml]
----
tasks:
  - name: "Générer un certificat SSL (une fois)"
    ansible.builtin.openssl_certificate:
      path: /etc/ssl/certs/app.crt
      privatekey_path: /etc/ssl/private/app.key
      csr_path: /etc/ssl/certs/app.csr
      provider: selfsigned
    run_once: true

  - name: "Copier le certificat généré vers tous les nœuds"
    ansible.builtin.copy:
      src: /etc/ssl/certs/app.crt
      dest: /etc/ssl/certs/
    run_once: true
    delegate_to: "{{ groups['load_balancer'][0] }}"
----

=== Stratégies d'exécution et gestion des erreurs

==== Stratégies au niveau du play

[source,yaml]
----
- name: "Déploiement avec tolérance aux pannes"
  hosts: webservers
  strategy: free  # Chaque hôte progresse indépendamment
  max_fail_percentage: 25  # Maximum 25% d'échecs autorisés
  serial: 3  # 3 hôtes à la fois (rolling update)
  tasks:
    - name: "Mise à jour de l'application"
      ansible.builtin.command: /opt/app/update.sh
----

==== Gestion fine des erreurs avec `block`

[source,yaml]
----
tasks:
  - block:
      - name: "Déployer la nouvelle version"
        ansible.builtin.copy:
          src: app_v2.tar.gz
          dest: /opt/app/

      - name: "Mettre à jour la configuration"
        ansible.builtin.template:
          src: config.j2
          dest: /etc/app/config

    rescue:
      - name: "Restaurer la version précédente"
        ansible.builtin.command: /opt/app/rollback.sh

      - name: "Alerter l'équipe"
        ansible.builtin.mail:
          subject: "Échec du déploiement sur {{ inventory_hostname }}"
          body: "Le déploiement a échoué et a été rollback"
          to: "devops@example.com"

    always:
      - name: "Nettoyer les fichiers temporaires"
        ansible.builtin.file:
          path: /tmp/deploy_lock
          state: absent
----

=== Conditions avec les tags

==== Définition

Les tags permettent un contrôle sélectif de l'exécution depuis la ligne de commande.

[source,yaml]
----
tasks:
  - name: "Configuration de base"
    ansible.builtin.lineinfile:
      path: /etc/security/limits.conf
      line: "* soft nofile 4096"
    tags:
      - base
      - security

  - name: "Configuration avancée"
    ansible.builtin.template:
      src: advanced.j2
      dest: /etc/app/advanced.conf
    tags: advanced

  - name: "Tâche de débogage"
    ansible.builtin.debug:
      var: ansible_facts
    tags: debug
----

==== Tags et Stratégies de Filtrage

[source,yaml]
----
tags:
  - always       # (Avec prudence) Toujours exécuté
  - installation # Paquets, bibliothèques
  - configuration # Fichiers de config, templates
  - service      # Gestion des services
  - validation   # Tests, vérifications
  - cleanup      # Nettoyage
----

[source,bash]
----
# Exécuter seulement les tâches tagguées 'base'
ansible-playbook playbook.yml --tags "base"

# Exécuter toutes les tâches SAUF celles tagguées 'debug'
ansible-playbook playbook.yml --skip-tags "debug"

# Lister toutes les tâches et leurs tags
ansible-playbook playbook.yml --list-tags
----

=== Conditions avec les handlers

Les handlers peuvent être conditionnels et utiliser le système de `listen`.

[source,yaml]
----
tasks:
  - name: "Mettre à jour la configuration Apache"
    ansible.builtin.template:
      src: apache.conf.j2
      dest: /etc/apache2/apache2.conf
    notify: "restart apache"

  - name: "Mettre à jour la configuration SSL"
    ansible.builtin.copy:
      src: ssl.conf
      dest: /etc/apache2/ssl.conf
    notify: "reload apache"

handlers:
  - name: "restart apache"
    ansible.builtin.service:
      name: apache2
      state: restarted
    listen: "apache service"

  - name: "reload apache"
    ansible.builtin.service:
      name: apache2
      state: reloaded
    listen: "apache service"
    when: apache_reloadable | bool
----

=== Conditions au niveau des plays et des rôles

Les conditions ne s'appliquent pas seulement aux tâches, mais aussi aux plays entiers et aux rôles.

[source,yaml]
----
- name: "Play conditionnel pour les environnements de production"
  hosts: all
  when: env == 'production'
  tasks:
    - name: "Configuration de sécurité renforcée"
      ansible.builtin.iptables:
        chain: INPUT
        rule: "-p tcp --dport 22 -j ACCEPT"

- name: "Inclusion conditionnelle de rôle"
  hosts: app_servers
  roles:
    - role: monitoring_agent
      when: install_monitoring | bool
    - role: log_forwarder
      when:
        - env == 'production'
        - use_central_logging | bool
----

==== Bonnes pratiques pour les conditions

1. **Éviter la complexité excessive** dans les conditions
2. **Utiliser des variables booléennes** pour plus de clarté
3. **Tester les conditions** avec `ansible -m debug`
4. **Documenter les conditions complexes**
5. **Utiliser des filtres Jinja2** pour les transformations

[source,yaml]
----
# Bonne pratique: utiliser des filtres pour garantir le type
when: maintenance_mode | default(false) | bool

# Bonne pratique: conditions documentées
when:
  # Exécuter seulement sur les serveurs Ubuntu 20.04+
  - ansible_facts['distribution'] == "Ubuntu"
  - ansible_facts['distribution_version'] is version('20.04', '>=')
----

== Les rôles

=== Architecture exhaustive d'un rôle

[source,yaml]
----
roles/
│   └── base_setup/
│       ├── tasks/ # dossier central, nos tâches
│       │   ├── main.yml
│       │   ├── secondary_task.yml
│       │   └── cleanup_task.yml
│       ├── handlers/ # handlers, tâches notifiée au changemnt uniquement
│       │   └── main.yml
│       ├── templates/ # templates jinja2
│       │   └── systemd/
│       │       └── custom_service.service.j2
│       ├── files/ # fichiers statiques à copier, donne la vraie arborescence si possible
│       │   ├── etc/
│       │   │   └── motd
│       │   └── usr/
│       │       └── local/
│       │           └── bin/
│       │               └── custom_script.sh
│       ├── vars/ # variables difficilement surchargeables, à disposition du rôle uniquement
│       │   ├── main.yml
│       │   ├── Debian.yml
│       │   └── RedHat.yml
│       ├── defaults/
│       │   └── main.yml # variables par défaut facilement surchargeables
│       ├── meta/ # le dossier de la documentation
│       │   ├── arguments_specs.yml # déclare les variables attendues, c'est la documentation
│       │   └── main.yml # décrit le rôle (notamment pour ansible galaxy)
│       ├── library/ # nos custom modules
│       ├── module_utils/ # dossier partagés pour nos custom modules
│       ├── lookup_plugins/ # lookup disponible dans les templates ou les tasks
│       ├── filter_plugins/ # filter disponible dans les templates ou les tasks
│       └── tests/ # tests d'intégration basés sur les molécules
│           ├── inventory
│           └── test.yml
----

=== Le dossier meta

* meta/main.yaml => décrit le rôle (auteur, version, dépendances, tags, compatibilité, etc)
* meta/arguments_specs.yml => déclare les variables attendues avec le type, la valeur par défaut, les choix possibles, etc, c'est un contrat, il sert à ansible de validation

==== Exemple exhaustif de main.yaml

[source, yaml]
----
# Fichier: roles/mon_role/meta/main.yml
# Objectif: décrire le rôle (pour Galaxy & tooling), déclarer les dépendances, borner les collections, etc.
galaxy_info:
  # --- Identité & description ---
  namespace: rridane           # Fortement recommandé pour Galaxy NG et ansible-lint
  role_name: mon_role          # Nom du rôle côté Galaxy (évite les surprises avec le répertoire local)
  author: "Rida Ridane"        # Auteur (affiché dans Galaxy)
  description: >
    Rôle d’exemple ultra-documenté qui illustre toutes les options meta possibles :
    compatibilité, dépendances, collections, et bonnes pratiques de publication.
  company: "Ridane Consulting" # Optionnel – affichage Galaxy

  # --- Licences & versions ---
  license: MIT                 # SPDX recommandé (ex: MIT, Apache-2.0, BSD-3-Clause, GPL-3.0-only, etc.)
  min_ansible_version: "2.15"  # Version minimale d’Ansible requise par le rôle

  # --- Compatibilité plateformes ---
  platforms:
    # Nom d’OS reconnu par Galaxy + liste de versions supportées
    - name: Debian
      versions: ["bullseye", "bookworm"]
    - name: Ubuntu
      versions: ["focal", "jammy"]
    - name: EL            # Enterprise Linux (RHEL / Rocky / Alma)
      versions: ["8", "9"]

  # --- Mots-clés pour la recherche Galaxy ---
  galaxy_tags:
    - devops
    - ha
    - loadbalancer
    - haproxy
    - keepalived
    - system

  # --- Liens utiles (affichés sur Galaxy) ---
  # Non requis par Ansible à l’exécution, mais utiles pour la doc/publication
  # Les champs suivants ne sont pas "validés" par Ansible, mais Galaxy peut les afficher.
  # Si tu ne publies pas sur Galaxy, tu peux les ignorer.
  #homepage: "https://github.com/rridane/ansible-mon_role"
  #issue_tracker_url: "https://github.com/rridane/ansible-mon_role/issues"

# --- Dépendances de rôles ---
# Ces rôles seront exécutés AVANT le rôle courant.
dependencies:
  # Forme simple (juste le nom du rôle) (rridane correspond au namespace que galaxy ira chercher)
  - rridane.common_base

  # Forme riche avec passage de variables, tags et condition
  - role: rridane.keepalived
    vars:
      vip: "10.0.0.10/24"
      iface: "eth0"
      priority: 110
    tags: ["ha", "network"]      # Les tâches de la dépendance recevront ces tags
    when: keepalived is defined  # Conditionner l’exécution de la dépendance

# --- Déduplication / ré-entrance ---
# Par défaut Ansible déduplique l’exécution des rôles/dépendances identiques.
# Place cette clé dans LE RÔLE qui doit pouvoir s’exécuter plusieurs fois "tel quel".
allow_duplicates: false

# --- Collections à charger prioritairement pour la résolution des FQCN ---
# Bonne pratique: lister explicitement ce dont ton rôle dépend (modules, plugins).
collections:
  - ansible.builtin
  - community.general
  - ansible.posix

# NOTE:
# - D’autres clés "exotiques" existent parfois dans la doc de Galaxy/Ansible, mais ne sont pas
#   toutes interprétées par le moteur d’exécution (ex: champs additionnels de publication).
# - Concentre-toi sur: galaxy_info / dependencies / allow_duplicates / collections.
----

==== Exemple exhaustif d'arguments_spec.yaml

[source,yaml]
----
# Fichier: roles/mon_role/meta/argument_specs.yml
# NOTE IMPORTANTE :
# - Les valeurs par défaut "réelles" doivent être alignées avec defaults/main.yml.
#   Ici, 'default' sert à documenter et à valider -> fais en sorte que ça corresponde.
# - La spec des rôles accepte (pour chaque option) UNIQUEMENT :
#   description, version_added, type, required, default, choices, elements, options.
#   (Pas de mutually_exclusive / required_if / aliases, etc. – réservés aux modules.)
#   Réf. "Role argument validation" + "Specification format".
# - Types permis (pour 'type') : str, bool, int, float, path, list, dict, raw.
#   (Tu peux aussi croiser 'list' avec 'elements': str/int/dict, etc.)

argument_specs:

  # Entrée principale du rôle (correspond à tasks/main.yml)
  main:
    short_description: "Configure et vérifie un service applicatif avec options avancées."
    description:
      - "Cet entrypoint montre la totalité des possibilités de la spec :"
      - "- types (str, bool, int, float, path, list, dict, raw)"
      - "- contraintes (required, default, choices)"
      - "- structures imbriquées (options pour dict, elements pour list)"
      - "Utilise-le comme gabarit pour documenter/valider tes variables de rôle."
    author: ["Ton Nom", "Autre Auteur"]  # Peut être une chaîne OU une liste
    version_added: "1.0.0"               # Version à laquelle CET entrypoint a été ajouté

    options:

      # --- 1) STR simple (défaut + description) --------------------------------
      name:
        type: str
        default: "my-service"
        description:
          - "Nom logique du service (utilisé pour générer fichiers/ressources)."

      # --- 2) BOOL --------------------------------------------------------------
      enabled:
        type: bool
        default: true
        description:
          - "Active ou désactive complètement les tâches du rôle."

      # --- 3) INT ---------------------------------------------------------------
      max_connections:
        type: int
        default: 2000
        description:
          - "Seuil numérique (ex. pour un service réseau)."

      # --- 4) FLOAT -------------------------------------------------------------
      ratio:
        type: float
        default: 0.75
        description:
          - "Coefficient décimal (ex. pondération d’un calcul)."

      # --- 5) PATH (souvent requis) --------------------------------------------
      config_path:
        type: path
        required: true
        description:
          - "Chemin absolu du fichier de configuration généré."

      # --- 6) RAW (aucune validation de type) ----------------------------------
      passthrough:
        type: raw
        required: false
        description:
          - "Valeur transmise telle quelle (utile pour données déjà typées)."

      # --- 7) ENUM / CHOICES ---------------------------------------------------
      state:
        type: str
        default: "present"
        choices: ["present", "absent", "noop"]
        description:
          - "Mode opératoire. 'noop' n’applique rien et sert à la vérification."

      # --- 8) LISTE d'éléments scalaires (strings) -----------------------------
      extra_packages:
        type: list
        elements: str
        default: []
        description:
          - "Paquets additionnels à installer."

      # --- 9) LISTE d'INT (autre exemple 'elements') ---------------------------
      ports:
        type: list
        elements: int
        default: [80, 443]
        description:
          - "Ports à ouvrir/exposer."

      # --- 10) LISTE de DICTS (schéma interne via 'options') -------------------
      backends:
        type: list
        elements: dict           # Chaque élément est un dict validé ci-dessous
        required: false
        description:
          - "Cibles applicatives (ex. serveurs derrière un load balancer)."
        options:                 # Schéma des clés attendues dans CHAQUE dict
          name:
            type: str
            required: true
            description: ["Identifiant du backend."]
          servers:
            type: list
            elements: str
            required: true
            description:
              - "Liste 'host:port' (ex. 10.0.0.11:8080)."
          balance:
            type: str
            default: "roundrobin"
            choices: ["roundrobin", "leastconn", "source"]
            description: ["Algorithme de répartition."]

      # --- 11) DICT avec sous-options (imbriqué) --------------------------------
      defaults:
        type: dict
        required: true
        description:
          - "Paramètres par défaut appliqués si non précisés ailleurs."
        options:
          mode:
            type: str
            default: "http"
            choices: ["http", "tcp"]
            description: ["Mode d’exploitation par défaut."]
          timeouts:
            type: dict
            required: false
            description: ["Regroupe les réglages de temporisation."]
            options:
              connect:
                type: str
                default: "5s"
                description: ["Timeout de connexion."]
              client:
                type: str
                default: "50s"
                description: ["Timeout côté client."]
              server:
                type: str
                default: "50s"
                description: ["Timeout côté serveur."]

      # --- 12) Option ajoutée dans une version ultérieure -----------------------
      # Montre l'usage de 'version_added' au NIVEAU OPTION.
      advanced_debug:
        type: bool
        default: false
        version_added: "1.1.0"  # Cette option n’existait pas en 1.0.0
        description:
          - "Active des sorties supplémentaires pour le diagnostic."

      # --- 13) DICT pour un composant optionnel (VIP Keepalived par ex.) -------
      # Exemple d’objet optionnel avec champs requis internes.
      ha:
        type: dict
        required: false
        description:
          - "Active la haute disponibilité si fourni."
        options:
          vip:
            type: str
            required: true
            description: ["Adresse VIP au format CIDR (ex. 10.0.0.10/24)."]
          iface:
            type: str
            required: true
            description: ["Interface réseau qui porte la VIP."]
          priority:
            type: int
            default: 100
            description: ["Priorité VRRP (plus haut = maître)."]
          state:
            type: str
            default: "MASTER"
            choices: ["MASTER", "BACKUP"]
            description: ["État initial du nœud VRRP."]

----

[CAUTION]
----
Le champ default dans l'arguments_specs.yaml n'est qu'informatif, et il fait doublon avec le default/main.yaml. Ou plus précisément c'est le default/main.yml qui est obligatoire
----

=== Le dossier default

==== default/main.yaml associé

Voici par ex le default qui doit être implémenté:

[source,yaml]
----
---
# Fichier: roles/mon_role/defaults/main.yml
# Valeurs par défaut alignées avec meta/argument_specs.yml

# 1) STR simple
name: "my-service"

# 2) BOOL
enabled: true

# 3) INT
max_connections: 2000

# 4) FLOAT
ratio: 0.75

# 5) PATH (required: true → pas de valeur par défaut)
# config_path doit être fourni par l’utilisateur !

# 6) RAW (optionnel, pas de valeur par défaut)
# passthrough:

# 7) ENUM / CHOICES
state: "present"

# 8) LISTE de STR
extra_packages:
  - "curl"
  - "htop"
  - "vim"

# 9) LISTE d'INT
ports:
  - 80
  - 443
  - 8080

# 10) LISTE de DICTS
backends:
  - name: "api"
    servers:
      - "10.0.0.11:8080"
      - "10.0.0.12:8080"
    balance: "roundrobin"
  - name: "static"
    servers:
      - "10.0.0.21:8080"
      - "10.0.0.22:8080"
    balance: "leastconn"

# 11) DICT avec sous-options (obligatoire)
defaults:
  mode: "http"
  timeouts:
    connect: "5s"
    client: "50s"
    server: "50s"

# 12) Option bool (ajoutée en 1.1.0)
advanced_debug: false

# 13) DICT optionnel (haute dispo)
ha:
  vip: "10.0.0.10/24"
  iface: "eth0"
  priority: 100
  state: "MASTER"
----

=== Le dossier vars

Il s'agit de variables qui n'ont pas vocation à être surchargées.

[source,yml]
----
# Noms de service par famille d’OS (ex : certains packages renomment le service)
service_name_map:
  Debian: "webapp"
  RedHat: "webapp"

# Paquets “noyau” imposés par le rôle, par OS (l'utilisateur ne devrait pas toucher)
base_packages_map:
  Debian: ["webapp", "ca-certificates"]
  RedHat: ["webapp", "ca-certificates"]

# Répertoires “internes” selon l’OS (utilisés dans les tasks/templates)
config_dir_map:
  Debian: "/etc/webapp"
  RedHat: "/etc/webapp"

# Valeurs “sûres” que l’on ne veut pas voir surchargées facilement
system_user: "webapp"
system_group: "webapp"
----

CAUTION: par défaut, ansible charge automatiquement **var/main.yml** et **defaults/main.yml**. Si l'on a une structure plus complète de variable il faut ajouter un include_vars pour les charger.

.Exemple de structure du vars/
[source,yml]
----
vars/
├─ main.yml     # commun
├─ Debian.yml   # spécifique Debian
├─ RedHat.yml   # spécifique RHEL
----

.on charge ainsi les variables de l'os qui ne sont pas chargées par défaut
[source,yml]
----
- name: Charger les variables spécifiques à l’OS
  ansible.builtin.include_vars:
    file: "{{ lookup('first_found', params) }}"
  vars:
    params:
      files:
        - "{{ ansible_facts.os_family }}.yml"
        - "default.yml"
      paths:
        - "{{ role_path }}/vars"
----

=== Le dossier tasks

C'est le coeur du rôle, quelques bonnes pratiques:

* imdempotence : Chaque tâche doit pouvoir être rejouée sans créer de changements inutiles
* tags partout (par fonctionnalité) + noms explicites ('Web :: Installer plugin')
* Utiliser **block/rescue/always** pour regrouper les erreurs
* Réespecte **check_mode** (si le module le supporte) et **diff** pour les fichiers
* utiliser **notify** -> handlers pour redémarrer / recharger, on utilise les handlers que si c'est nécessaires
* **no_log: true** pour les secrets, **validate** sur **template** quand c'est possible
* favoriser les **modules ansible** plutôt que **shell/command**

Voici un exemple très complet

[source,yaml]
----
# tasks/main.yml — exemple riche “état de l’art”

# 0) Chargement optionnel de variables spécifiques (multi-OS / profils)
- name: "Vars :: Charger les variables spécifiques à l’OS (si présentes)"
  ansible.builtin.include_vars:
    file: "{{ lookup('ansible.builtin.first_found', params) }}"
  vars:
    params:
      files:
        - "{{ ansible_facts.os_family }}.yml"  # ex: Debian.yml / RedHat.yml
        - "default.yml"
      paths:
        - "{{ role_path }}/vars"
  tags: [vars]
  # safe: si le fichier n’existe pas, first_found passera au suivant → pas d’erreur

# 1) Validation d’entrée (rôle + inventaire)
- name: "Assert :: Variables minimales valides"
  ansible.builtin.assert:
    that:
      - name is string
      - enabled is boolean
      - ports is sequence
      - (defaults.mode in ['http','tcp'])
    fail_msg: "Contrat brisé: vérifie argument_specs.yml et tes variables."
  tags: [assert]

# 2) Préparation système / répertoires
- name: "FS :: Créer le répertoire de configuration"
  ansible.builtin.file:
    path: "{{ config_dir_map[ansible_facts.os_family] | default('/etc/webapp') }}"
    state: directory
    owner: "{{ system_user }}"
    group: "{{ system_group }}"
    mode: "0755"
  tags: [fs]

# 3) Installation de base (paquets)
- name: "Pkg :: Installer paquets de base"
  ansible.builtin.package:
    name: "{{ (base_packages_map[ansible_facts.os_family] | default(['webapp'])) + extra_packages }}"
    state: present
  tags: [pkg]

# 4) Déploiement de fichiers statiques
- name: "Files :: Déployer /etc/motd (exemple)"
  ansible.builtin.copy:
    src: "etc/motd"
    dest: "/etc/motd"
    owner: root
    group: root
    mode: "0644"
  tags: [files]

# 5) Gestion de fichiers “ligne à ligne” (ajout idempotent)
- name: "Cfg :: Ajouter un paramètre dans un fichier (idempotent)"
  ansible.builtin.lineinfile:
    path: "/etc/sysctl.conf"
    regexp: "^net.ipv4.ip_nonlocal_bind"
    line: "net.ipv4.ip_nonlocal_bind = 1"
    backup: true
  notify: ["Sysctl :: Apply"]
  tags: [cfg, sysctl]

# 6) Génération d’un template validé (rollback si invalide)
- name: "Cfg :: Rendre unit systemd (avec validate)"
  ansible.builtin.template:
    src: "systemd/custom_service.service.j2"
    dest: "/etc/systemd/system/{{ name }}.service"
    owner: root
    group: root
    mode: "0644"
    validate: "systemd-analyze verify %s"  # %s = fichier rendu temporaire
  notify:
    - "Systemd :: Daemon-reload"
  tags: [cfg, systemd]

# 7) Exemple d’utilisation de no_log (secret)
- name: "Secret :: Créer un utilisateur DB (exemple)"
  community.postgresql.postgresql_user:
    name: "appuser"
    password: "{{ db_password }}"
    state: present
  no_log: true               # masque les logs (stdout/stderr, diff, etc.)
  when: db_password is defined
  tags: [secret, db]

# 8) Boucles & sous-objets (liste de backends)
- name: "Cfg :: Déployer la conf backends (fichier conf.d/)"
  ansible.builtin.template:
    src: "conf.d/backend.conf.j2"
    dest: "/etc/webapp/conf.d/{{ item.name }}.conf"
    owner: root
    group: root
    mode: "0644"
  loop: "{{ backends }}"
  loop_control:
    label: "{{ item.name }}"
  notify: ["Webapp :: Reload"]
  tags: [cfg, confd]

# 9) Service principal
- name: "Svc :: Activer / démarrer le service"
  ansible.builtin.service:
    name: "{{ name }}"
    state: "{{ 'started' if enabled else 'stopped' }}"
    enabled: "{{ enabled }}"
  tags: [svc]

# 10) Santé applicative avec gestion d’erreurs (block / rescue / always)
- block:
    - name: "Health :: Attendre que le port {{ ports[0] }} écoute"
      ansible.builtin.wait_for:
        port: "{{ ports[0] }}"
        timeout: 10
      when: enabled | bool
      tags: [health]

    - name: "Health :: Probe HTTP (si mode http)"
      ansible.builtin.uri:
        url: "http://127.0.0.1:{{ ports[0] }}/health"
        status_code: [200, 204]
        return_content: false
      register: health_uri
      changed_when: false               # lecture seule → ne doit pas marquer changed
      when:
        - enabled | bool
        - defaults.mode == 'http'
      tags: [health]
  rescue:
    - name: "Health :: Dump journal (dernier 100)"
      ansible.builtin.command: "journalctl -u {{ name }} -n 100 --no-pager"
      changed: false
      tags: [health, debug]
    - name: "Health :: Afficher port / sockets ouverts"
      ansible.builtin.command: "ss -ltnp"
      changed: false
      tags: [health, debug]
  always:
    - name: "Always :: Forcer un flush handlers si besoin"
      ansible.builtin.meta: flush_handlers
      tags: [always]

# 11) Assertions finales (post-conditions)
- name: "Assert :: Post-conditions (si enabled)"
  ansible.builtin.assert:
    that:
      - not enabled or (health_uri is defined)
    success_msg: "Service opérationnel."
    fail_msg: "Service non accessible alors qu’il est 'enabled'."
  when: defaults.mode == 'http'
  tags: [assert, health]

# 12) Tâches “check-mode friendly” (exemples)
- name: "Check :: Prévisualiser un fichier rendu (diff) — pas d’écriture"
  ansible.builtin.template:
    src: "dryrun/example.conf.j2"
    dest: "/etc/webapp/example.conf"
  check_mode: true             # force le dry-run sur cette tâche uniquement
  diff: true                   # afficher le diff du rendu vs existant
  tags: [check, diff]

# 13) Tâche lente en asynchrone (ex: migration, build, etc.)
- name: "Async :: Lancer une opération longue"
  ansible.builtin.command: "/usr/local/bin/{{ name }} --migrate"
  async: 300                   # max 5 minutes
  poll: 5                      # interroger toutes les 5s
  register: migrate_job
  changed_when: migrate_job.rc == 0
  when: enabled | bool
  tags: [async]

# 14) Retry/until (ex: attendre qu’un endpoint réponde une valeur précise)
- name: "Retry :: Vérifier un compteur prêt (endpoint interne)"
  ansible.builtin.uri:
    url: "http://127.0.0.1:{{ ports[0] }}/metrics?name=ready_gauge"
    status_code: 200
    return_content: true
  register: ready_metric
  until: "'ready_gauge 1' in (ready_metric.content | default(''))"
  retries: 12
  delay: 5
  changed_when: false
  when: enabled | bool
  tags: [retry, health]

# 15) Délégation / run_once (ex: action unique côté bastion)
- name: "Bastion :: Vérifier accès externe (HTTP/HEAD)"
  ansible.builtin.uri:
    url: "https://example.org/health"
    method: HEAD
    status_code: 200
  delegate_to: bastion.example.org
  run_once: true
  changed_when: false
  tags: [bastion, health]

# 16) set_fact contrôlé (cacheable) pour réutilisation ultérieure
- name: "Facts :: Définir un fait pour d’autres rôles/plays"
  ansible.builtin.set_fact:
    webapp_unit_path: "/etc/systemd/system/{{ name }}.service"
    cacheable: true
  tags: [facts]

# 17) Nettoyage conditionnel
- name: "Cleanup :: Retirer des fichiers obsolètes"
  ansible.builtin.file:
    path: "/etc/webapp/obsolete.conf"
    state: absent
  when: state == 'present'
  tags: [cleanup]

# 18) Inclus de tâches conditionnels (gros rôles → modulariser)
- name: "Include :: Tâches de maintenance si demandées"
  ansible.builtin.include_tasks: maintenance.yml
  when: state == 'noop'
  tags: [maintenance]
----

=== Le dossier handlers

Il s'agit des actions déclenchées par notify, que l'on utilise en règle générale pour les reload/restart. Les handlers ne tournent que si ils sont déclenchés.

Une bonne pratique générale sur systemd consiste à chainer **reload** et **daemon-reload** si une unit a changé.

[source,yaml]
----
# handlers/main.yml
- name: "Systemd :: Daemon-reload"
  ansible.builtin.command: systemctl daemon-reload
  become: true

- name: "Systemd :: Reload"
  ansible.builtin.service:
    name: "{{ name }}"
    state: reloaded
  listen: "Systemd :: Reload"

- name: "Systemd :: Restart"
  ansible.builtin.service:
    name: "{{ name }}"
    state: restarted
----

=== le dossier files

Il contient les artefacts statiques.

Bonnes pratiques :

* arborescence qui mime la destination (**file/etc...**) pour la clarté
* utiliser **copy** avec checksum implicite -> notifie uniquement si changement
* pour de gros fichiers préférer **get_url** ou un **package**

[source,yaml]
----
# tasks/files.yml
- name: "Files :: Déployer /etc/motd"
  ansible.builtin.copy:
    src: "etc/motd"
    dest: "/etc/motd"
    owner: root
    group: root
    mode: "0644"
  notify: ["Systemd :: Restart"]   # si ton app lit /etc/motd au démarrage

----

=== le dossier template

Les templates sont générés à l'aide de Jinja2.

Bonnes pratiques:

* Garder la logique minimale dans le template (pas de grosses conditions complexes).
* Rendre les espaces/indentations stables (éviter les diffs inutiles).
* Valider quand c’est possible (validate: côté tâche).
* Séparer les snippets si c’est gros (include Jinja).


==== Concepts clés des templates

Les types de templates :

* *config* → fichiers de configuration principaux (nginx.conf, config.yml…).
* *units* → fichiers systemd (service, timer, socket).
* *conf.d* → fragments modulaires inclus (un fichier par backend/site/etc.).

En pratique :
- 1 template principal pour la config,
- 1 template unit systemd,
- des templates fragments dans conf.d/,
- éventuellement des sous-templates *partials/* ou *macros.j2* pour factoriser.

==== Jinja2 utiles

*Filtres/tests*
[source,jinja]
----
{{ var | default('value') }}
{{ var | mandatory }}
{{ list | join(',') }}
{{ dict | to_nice_yaml(indent=2) }}
{{ items | selectattr('enabled','equalto',true) | list }}
{{ items | map(attribute='name') | list }}
{{ mylist | unique | list }}
{{ a_list | difference(b_list) }}
----

*Contrôle de flux*
[source,jinja]
----
{% if defaults.mode == 'http' %}
  ...
{% elif ... %}
  ...
{% else %}
  ...
{% endif %}

{% for b in backends %}
# {{ loop.index }}. {{ b.name }}
{% endfor %}
----

*Gestion espaces/indentations*
[source,jinja]
----
{{ mydict | to_nice_yaml(indent=2) | indent(4) }}
{%- for item in list -%} ... {%- endfor -%}
----

*Factorisation*
[source,jinja]
----
{% include 'partials/tls_block.j2' %}
{% from 'macros.j2' import emit_kv %}
----

==== Exemple concret : Config (fichier YAML appli)

.templates/config.yml.j2
[source, jinja]
----
app: {{ name }}
enabled: {{ enabled | bool }}
server:
  mode: {{ defaults.mode | default('http') }}
  listen_port: {{ listen_port | default(8080) }}
backends:
{% for b in backends %}
  - name: {{ b.name }}
    balance: {{ b.balance | default('roundrobin') }}
    servers:
{%   for s in b.servers %}
      - {{ s }}
{%   endfor %}
{% endfor %}
----

.Tâche associée
[source,yaml]
----
- name: "Cfg :: Générer /etc/webapp/config.yml"
  ansible.builtin.template:
    src: "config.yml.j2"
    dest: "/etc/webapp/config.yml"
    owner: "{{ system_user }}"
    group: "{{ system_group }}"
    mode: "0644"
  notify: ["Webapp :: Reload"]
  tags: [cfg]
----

==== Exemples concrets : Units (systemd service)

.templates/systemd/service.j2
[source,ini]
----
[Unit]
Description={{ name }} service
After=network.target

[Service]
User={{ system_user }}
Group={{ system_group }}
ExecStart=/usr/local/bin/{{ name }} --port {{ listen_port | default(8080) }}
Restart=always

[Install]
WantedBy=multi-user.target
----

.Tâche associée
[source,yaml]
----
- name: "Systemd :: Déployer unit"
  ansible.builtin.template:
    src: "systemd/service.j2"
    dest: "/etc/systemd/system/{{ name }}.service"
    mode: "0644"
    validate: "systemd-analyze verify %s"
  notify:
    - "Systemd :: Daemon-reload"
    - "Webapp :: Restart"
----

==== Exemple concrets :conf.d (fragments modulaires)
.templates/conf.d/backend.conf.j2
[source,jinja]
----
# {{ item.name }}
backend {{ item.name }}
  balance {{ item.balance | default('roundrobin') }}
{% for s in item.servers %}
  server {{ item.name }}-{{ loop.index }} {{ s }} check
{% endfor %}
----

.Tâche associée
[source,yaml]
----
- name: "Cfg :: Déployer fragments conf.d/"
  ansible.builtin.template:
    src: "conf.d/backend.conf.j2"
    dest: "/etc/webapp/conf.d/{{ item.name }}.conf"
  loop: "{{ backends }}"
  loop_control:
    label: "{{ item.name }}"
  notify: ["Webapp :: Reload"]
  tags: [cfg, confd]
----


==== Includes & Macros

.Partials (include)
[source,jinja]
----
{% if tls.enabled | default(false) %}
tls:
  cert: {{ tls.cert_path }}
  key:  {{ tls.key_path }}
{% endif %}
----

.Macros
.templates/macros.j2
[source,jinja]
----
{% macro emit_kv(d) -%}
{%- for k,v in d.items() -%}
{{ k }}={{ v }}
{%- endfor -%}
{%- endmacro %}
----

.Utilisation
[source,jinja]
----
{% from 'macros.j2' import emit_kv %}
env:
{{ emit_kv(env_map) | indent(2) }}
----

===== Sécurité & robustesse

* `validate:` protège avant d’écraser un fichier
* `no_log: true` masque secrets
* `mandatory` pour crash si une var manque
* `ansible_managed` bannière automatique

.Exemple
[source,yaml]
----
- name: "Déployer config nginx"
  ansible.builtin.template:
    src: "nginx.conf.j2"
    dest: "/etc/nginx/nginx.conf"
    validate: "nginx -t -c %s"
    owner: root
    group: root
    mode: "0644"
----

=== Le dossier library

C'est ici que l'on peut trouver des modules custom (quand les modules natifs ne suffisent pas)

[source,python]
----
# library/my_echo.py
from ansible.module_utils.basic import AnsibleModule

def run_module():
    args = dict(
        message=dict(type='str', required=True),
        uppercase=dict(type='bool', default=False),
    )
    module = AnsibleModule(argument_spec=args, supports_check_mode=True)

    msg = module.params['message']
    if module.params['uppercase']:
        msg = msg.upper()

    # Idempotence: pas de changement -> changed=False
    result = dict(changed=False, echo=msg)

    module.exit_json(**result)

def main():
    run_module()

if __name__ == '__main__':
    main()
----

[source,yaml]
----
- name: "Echo via module custom"
  my_echo:
    message: "hello"
    uppercase: true
  register: echo_out

- debug: var=echo_out.echo

----

=== Le dossier module_utils

C'est un dossier helpers partagés entre tous les modules custom. Voici un exemple détaillé.

[source,bash]
----
roles/webapp/
├── library/
│   └── my_check_http.py
├── module_utils/
│   └── http_helpers.py
└── tasks/
    └── main.yml
----

[source,python]
----
# roles/webapp/module_utils/http_helpers.py
import urllib.request

def http_get(url, timeout=5):
    """Effectue un GET HTTP basique et retourne (status, body)."""
    with urllib.request.urlopen(url, timeout=timeout) as r:
        return r.status, r.read().decode()
----

[source,python]
----
# roles/webapp/library/my_check_http.py
from ansible.module_utils.basic import AnsibleModule
from ansible.module_utils.http_helpers import http_get  # import helper

def run_module():
    args = dict(
        url=dict(type='str', required=True),
        timeout=dict(type='int', default=5)
    )
    module = AnsibleModule(argument_spec=args, supports_check_mode=True)

    try:
        status, body = http_get(module.params['url'], module.params['timeout'])
        result = dict(changed=False, status=status, body=body[:200])  # tronque output
        module.exit_json(**result)
    except Exception as e:
        module.fail_json(msg=f"Erreur HTTP: {e}")

def main():
    run_module()

if __name__ == '__main__':
    main()
----

[source,yaml]
----
---
- name: "Health :: Vérifier endpoint HTTP"
  webapp.my_check_http:   # FQCN = <role>.<module> si collection, sinon juste nom du fichier
    url: "http://127.0.0.1:8080/health"
    timeout: 3
  register: health

- name: "Debug :: Afficher le status"
  ansible.builtin.debug:
    msg: "HTTP status = {{ health.status }}"

----

=== Les dossiers filter_plugins et lookup_plugins

Exemple détaillé.

[source,bash]
----
roles/webapp/
├─ lookup_plugins/
│  └─ kv.py
├─ filter_plugins/
│  └─ strings.py
├─ files/
│  └─ data/
│     └─ kv.yml
├─ templates/
│  └─ config.env.j2
├─ tasks/
│  └─ main.yml
└─ defaults/
   └─ main.yml
----

[source,python]
----
# roles/webapp/lookup_plugins/kv.py
from __future__ import annotations
from ansible.plugins.lookup import LookupBase
from ansible.errors import AnsibleError
import os
import yaml

class LookupModule(LookupBase):
    """
    Usage basique:
      - debug: msg="{{ lookup('webapp.kv', 'app.name') }}"
    Avec options:
      - debug: msg="{{ lookup('webapp.kv', 'app.name', source='file', path='files/data/kv.yml') }}"
      - debug: msg="{{ lookup('webapp.kv', 'db.pass', source='vars', varname='kv_map') }}"
    wantlist:
      - set_fact: keys="{{ lookup('webapp.kv', 'app.name','env', wantlist=True) }}"
    """

    def _load_map_from_file(self, path: str) -> dict:
        try:
            with open(path, 'r', encoding='utf-8') as f:
                data = yaml.safe_load(f) or {}
                if not isinstance(data, dict):
                    raise AnsibleError(f"Le fichier '{path}' ne contient pas un dict YAML.")
                return data
        except FileNotFoundError as e:
            raise AnsibleError(f"Fichier introuvable: {path}") from e
        except Exception as e:
            raise AnsibleError(f"Erreur de lecture YAML: {path}: {e}") from e

    def run(self, terms, variables=None, **kwargs):
        """
        terms: liste de clés à chercher ("a.b.c")
        kwargs supportés:
          - source: "file" | "vars" | "auto" (defaut: auto)
          - path: chemin vers un YAML (relatif au role si non absolu)
          - varname: nom de la variable dict à utiliser si source="vars"
          - default: valeur par défaut si clé manquante (sinon lève AnsibleError)
          - sep: séparateur de chemin (defaut ".")
          - wantlist: renvoyer une liste (Ansible gère ce flag, mais on l’accepte)
        """
        sep = kwargs.get("sep", ".")
        source = kwargs.get("source", "auto")
        default_value = kwargs.get("default", None)
        varname = kwargs.get("varname", "kv_map")
        rel_path = kwargs.get("path", "files/data/kv.yml")

        # Résolution du fichier YAML relatif au rôle si besoin
        if not os.path.isabs(rel_path):
            # base_dir: répertoire de base du play/rôle
            base_dir = self.get_basedir(variables)
            # Dans un rôle, files/ est relatif au role_path
            # On tente role_path/files/... s'il existe
            role_path = variables.get('role_path') if variables else None
            candidates = []
            if role_path:
                candidates.append(os.path.join(role_path, rel_path))
            candidates.append(os.path.join(base_dir, rel_path))
            file_path = next((p for p in candidates if os.path.exists(p)), rel_path)
        else:
            file_path = rel_path

        # Charger les données
        data_map = {}
        if source in ("auto", "vars"):
            if variables and varname in variables and isinstance(variables[varname], dict):
                data_map.update(variables[varname])
            elif source == "vars":
                raise AnsibleError(f"Variable dict '{varname}' introuvable ou invalide (source=vars).")

        if source in ("auto", "file"):
            # Les données du fichier complètent (mais ne remplacent pas) celles du dict
            # (priorité au dict si même clé)
            file_map = self._load_map_from_file(file_path)
            for k, v in file_map.items():
                data_map.setdefault(k, v)

        # Recherche de chaque clé
        results = []
        for term in terms:
            try:
                node = data_map
                for part in str(term).split(sep):
                    if isinstance(node, dict) and part in node:
                        node = node[part]
                    else:
                        raise KeyError(part)
                results.append(node)
            except KeyError:
                if 'default' in kwargs:
                    results.append(default_value)
                else:
                    raise AnsibleError(f"Clé '{term}' introuvable (source={source}, path={file_path}, varname={varname}).")

        return results
----

[source,yaml]
----
# roles/webapp/files/data/kv.yml
app:
  name: webapp
  env: prod
db:
  host: 10.0.0.10
  pass: CHANGEMOI
----

[source,yaml]
----
# roles/webapp/defaults/main.yml
kv_map:
  app:
    name: "webapp-default"
    env: "dev"
----

[source,yaml]
----
# roles/webapp/filter_plugins/strings.py
from __future__ import annotations

def slug(value: str) -> str:
    """
    Transforme 'My App PROD' -> 'my-app-prod'
    """
    if value is None:
        return ""
    return str(value).strip().lower().replace(" ", "-")

def dict_merge(a: dict, b: dict) -> dict:
    """
    Merge superficiel de deux dicts (a <- b). b écrase a sur les mêmes clés.
    """
    res = dict(a or {})
    res.update(b or {})
    return res

def to_ini_block(section: str, mapping: dict) -> str:
    """
    Rend un bloc INI à partir d'une section et d'un mapping.
    """
    lines = [f"[{section}]"]
    for k, v in (mapping or {}).items():
        lines.append(f"{k}={v}")
    return "\n".join(lines)

class FilterModule(object):
    def filters(self):
        return {
            "slug": slug,
            "dict_merge": dict_merge,
            "to_ini_block": to_ini_block,
        }

----

[source,jinja]
----
# Fichier généré par Ansible — ne pas éditer
APP_NAME={{ (lookup('webapp.kv','app.name') | slug) }}
APP_ENV={{ lookup('webapp.kv','app.env', default='dev') }}

# Exemple d’utilisation d’une liste de clés (wantlist)
# Renvoie une liste → join pour produire une seule ligne
APP_KEYS={{ (lookup('webapp.kv','app.name','app.env', wantlist=True) | join(',')) }}

# Exemple de to_ini_block sur une map fusionnée
{{ {'log_level':'info'} | dict_merge(extra_env_map|default({})) | to_ini_block('env') }}

DB_HOST={{ lookup('webapp.kv','db.host', default='127.0.0.1') }}
----

[source,yaml]
----
---
- name: "Cfg :: Rendre config.env depuis template (lookup + filters)"
  ansible.builtin.template:
    src: "config.env.j2"
    dest: "/etc/webapp/config.env"
    owner: root
    group: root
    mode: "0640"
  vars:
    # injecte des données à fusionner dans to_ini_block via notre filtre dict_merge
    extra_env_map:
      FEATURE_X: "enabled"
  tags: [cfg]

- name: "Lookup :: Récupérer plusieurs clés (wantlist)"
  ansible.builtin.set_fact:
    app_keys: "{{ lookup('webapp.kv', 'app.name', 'app.env', wantlist=True) }}"
  tags: [lookup]

- name: "Debug :: Montre le résultat du lookup wantlist"
  ansible.builtin.debug:
    var: app_keys
  tags: [lookup]

- name: "Debug :: Démo filtres (slug, dict_merge, to_ini_block)"
  ansible.builtin.debug:
    msg: |
      SLUG={{ 'My PROD App' | slug }}
      MERGE={{ {'a':1} | dict_merge({'b':2}) }}
      INI:
      {{ to_ini_block('section', {'k1':'v1','k2':'v2'}) }}
  tags: [filters]

----

Quelques remarques:

* Si un rôle est packagé en collection, le lookup s'appellera **collection_namespace.collection_name.py**. En rôle nu, **webapp.py** fonctionne si Anisble trouve le plugin dans **lookup_plugins**
* Gestion des erreurs : On lève **AnsibleError** avec un message explicite (chemin, source...)
* **wantlist** : penser à le supporter  - très utile pour récupérer plusieurs clés d'un coup
* **chemins** : Le lookup résout un chemin **relatif au rôle** (via **role_path**) ou au basedir si nécessaire. ça éviter d'avoir à mettre des chemins absolus dans les tasks.
* **filtres** : gardent les templates **propres** (pas de logique python dans les tâches)
* **tests rapides** : on peut tester le lookup en ad-hoc :
[source,bash]
----
ansible localhost -m debug -a "msg={{ lookup('webapp.kv','app.name') }}"
----

=== Le dossier tests

Il s'agit du dossier des tests d'intégration. Les tests ansible ont plusieurs drivers disponibles (docker/podman, vagrant, kvm..). L'état de l'art travaille avec la notion de molecule qui contient plusieurs fichiers / étapes (create -> converge -> verify -> destroy).

Etat de l'art :
* molecule pour tester
* lint automatique: **ansible-lint**, **yamllint**
* différents scénarios (default, debianb, rhel, upgrade...)
* etapes molécules : **create** -> **converge** -> **verify** -> **destroy**

Voici un exemple complet:

[source,bash]
----
roles/base_setup/
└─ molecule/default/
   ├─ converge.yml
   ├─ verify.yml
   └─ molecule.yml
----

.molecule.yml
[source,yaml]
----
driver:
  name: docker
platforms:
  - name: instance
    image: "geerlingguy/docker-debian11-ansible:latest"
provisioner:
  name: ansible
  playbooks:
    converge: converge.yml
verifier:
  name: ansible
----

.converge.yml
[source,yaml]
----
- hosts: all
  become: true
  roles:
    - role: base_setup
----

.verify.yml
[source,yaml]
----
- hosts: all
  tasks:
    - name: "Vérifier que le service est présent"
      ansible.builtin.command: "systemctl status {{ name }}"
      register: out
      changed: false
    - assert:
        that:
          - out.rc == 0
----

== Deep Dive sur les Playbooks

=== Structure et Anatomie d'un Playbook

Un playbook est composé d'un ou plusieurs *plays*. Chaque play cible un groupe d'hôtes et exécute une liste de *tasks*.

[source,yaml]
----
- name: Premier Play - Configuration de base
  hosts: all
  become: yes
  vars:
    motd_message: "Bienvenue sur ce serveur"
  tasks:
    - name: Déployer le MOTD
      ansible.builtin.template:
        src: motd.j2
        dest: /etc/motd

- name: Deuxième Play - Déploiement applicatif
  hosts: webservers
  become: yes
  vars_files:
    - vars/app_config.yml
  roles:
    - role: nginx
    - role: app_server
  tasks:
    - name: Vérifier l'état de l'application
      ansible.builtin.uri:
        url: "http://localhost:{{ app_port }}"
        status_code: 200
----

=== Directives Principales d'un Play

.Hosts et regroupement
[source,yaml]
----
hosts: all                      # Tous les hôtes
hosts: webservers               # Groupe spécifique
hosts: webservers:&staging      # Intersection de groupes
hosts: webservers:!loadbalancer # Exclusion
hosts: server[1:5]              # Plage d'hôtes
hosts: "{{ target_group }}"     # Variable dynamique
----

.Accès et privilèges
[source,yaml]
----
become: yes                     # Activer l'escalade de privilèges
become_user: root               # Utilisateur cible
become_method: sudo             # Méthode (sudo/su/doas/etc.)
remote_user: deploy             # Utilisateur SSH
----

.Collecte d'informations
[source,yaml]
----
gather_facts: true              # Activer la collecte de facts (défaut)
gather_facts: false             # Désactiver pour plus de rapidité
gather_subset: minimal          # Sous-ensemble de facts
gather_timeout: 30              # Timeout pour la collecte
----

=== Gestion des Variables dans les Playbooks

==== Déclaration et Hiérarchie

Les variables peuvent être définies à plusieurs niveaux, par ordre de priorité (croissant) :

1. Rôle `defaults/` (priorité la plus basse)
2. Rôle `vars/`
3. Variables d'inventaire (`group_vars/`, `host_vars/`)
4. Variables de play (`vars:` au niveau playbook)
5. Variables incluses (`vars_files:`)
6. Variables de tâche (`vars:` au niveau tâche)
7. Variables en ligne de commande (`-e`) (priorité la plus haute)

[NOTE]
--
On appelle variable de tâche les variables directement définies au niveau de la tâche par un **vars:** de la façon suivante :
[source,yaml]
----
- name: Installer un paquet spécifique
  ansible.builtin.package:
    name: "{{ pkg_name }}"
    state: present
  vars:
    pkg_name: "htop"
----

Mais pas seulement, la variable d'une itération dans une loop est également, item par défaut ici:

[source,yaml]
----
- name: Ajouter des entrées hosts
  lineinfile:
    dest: /etc/hosts
    line: "{{ item.ip }} {{ item.hostname }}"
  loop:
    - { ip: "10.0.0.1", hostname: "db1" }
    - { ip: "10.0.0.2", hostname: "db2" }
----

Ou autre si elle est renommée:

[source,yaml]
----
- name: Ajouter des entrées hosts
  lineinfile:
    dest: /etc/hosts
    line: "{{ host.ip }} {{ host.hostname }}"
  loop:
    - { ip: "10.0.0.1", hostname: "db1" }
    - { ip: "10.0.0.2", hostname: "db2" }
  loop_control:
    loop_var: host
----

Mais attention, cette variable renommée sera prioritaire sur les groups_vars, host_vars ou vars définies au niveau playbook. Il convient donc de choisir habillement le nom de cette variable pour ne pas avoir de soucis. (item par defaut est très bien en ce sens)

Autre cas, le register lorsque le créé une variable avec la sortie d'une tâche.
register crée une variable portée au host (disponible pour les tâches suivantes de ce host dans le même play). Elle reste moins forte que des vars de tâche ou des -e de la CLI, mais peut masquer des variables d’inventaire homonymes.

[source,yaml]
----
- name: Vérifier la version de python
  command: python3 --version
  register: py_version
----

--

==== Méthodes de Déclaration

.Directement dans le play
[source,yaml]
----
vars:
  http_port: 80
  max_workers: 5
  feature_flags:
    - enabled
    - debug_mode
----

.Via des fichiers externes
[source,yaml]
----
vars_files:
  - vars/common.yml
  - vars/secrets.yml        # Souvent chiffré avec Ansible Vault
----

.Prompt utilisateur
[source,yaml]
----
vars_prompt:
  - name: db_password
    prompt: "Entrez le mot de passe de la base de données"
    private: yes
----

.En ligne de commande
[source,bash]
----
ansible-playbook playbook.yml -e "http_port=8080 env=prod"
----

==== Blocks de tâches et gestion d'erreurs

[source,yaml]
----
- block:
    - name: Tâche critique 1
      ansible.builtin.command: /bin/critical_task.sh

    - name: Tâche critique 2
      ansible.builtin.command: /bin/another_task.sh

  rescue:
    - name: En cas d'échec
      ansible.builtin.debug:
        msg: "Les tâches critiques ont échoué"

    - name: Collecter les logs
      ansible.builtin.command: journalctl -u app.service

  always:
    - name: Nettoyage toujours exécuté
      ansible.builtin.file:
        path: /tmp/lockfile
        state: absent
----

==== Délégation et exécution contrôlée

[source,yaml]
----
- name: Vérifier la connectivité externe
  ansible.builtin.command: ping -c 1 example.com
  delegate_to: localhost      # Exécute sur la machine locale
  run_once: true              # Exécute une seule fois

- name: Opération sur le bastion
  ansible.builtin.command: /opt/scripts/check_firewall.sh
  delegate_to: bastion_host   # Exécute sur un hôte spécifique
  become: yes
----



==== Tâches asynchrones

[source,yaml]
----
- name: Exécuter une tâche longue
  ansible.builtin.command: /opt/app/long_running_task.sh
  async: 600                  # Timeout de 600 secondes
  poll: 30                    # Vérification toutes les 30s
  register: async_result

- name: Vérifier le résultat
  ansible.builtin.async_status:
    jid: "{{ async_result.ansible_job_id }}"
  register: job_result
  until: job_result.finished
  retries: 30
  delay: 10
----

=== Handlers et notifications

Les handlers sont des tâches déclenchées uniquement par des notifications, généralement pour redémarrer des services.

[source,yaml]
----
tasks:
  - name: Mettre à jour la configuration
    ansible.builtin.template:
      src: nginx.conf.j2
      dest: /etc/nginx/nginx.conf
    notify: Restart nginx   # Notification

handlers:
  - name: Restart nginx
    ansible.builtin.service:
      name: nginx
      state: restarted

  - name: Reload configuration
    ansible.builtin.service:
      name: nginx
      state: reloaded
    listen: "nginx config"   # Handler écoutant un canal

# Notification multiple
- name: Mettre à jour plusieurs configurations
  ansible.builtin.template:
    src: app.conf.j2
    dest: /etc/app.conf
  notify:
    - Restart nginx
    - Restart app
----

---

=== Inclusion et Modularisation

.Inclusion de playbooks
[source,yaml]
----
- import_playbook: database.yml
- import_playbook: webserver.yml
----

.Inclusion de tâches (statique)
[source,yaml]
----
- import_tasks: common_tasks.yml
- import_tasks: security_tasks.yml
  when: security_hardening
----

.Inclusion de tâches (dynamique)
[source,yaml]
----
- include_tasks: setup_{{ os_family }}.yml
- include_tasks: "{{ include_file }}"
----

=== module ansible vs shell/command

Un module sait gérer une ressource de manière idempotent, il faut donc privilégier les modules. Dans l'exemple ci-dessous, package n'est executé qu'une fois tandis que le command est executé à chaque fois.

[source,yml]
----
- name: "Installer nginx"
  ansible.builtin.package:
    name: nginx
    state: present
----

[source,yml]
----
- name: "Installer nginx"
  ansible.builtin.command: apt-get install -y nginx
----

=== check_mod et diff

* **check_mode** **--check** : c'est le dry-run d'ansible, il montre ce qui serait changé sans appliquer
* **diff** **--diff** : uniquement pour les fichiers/templates, il affiche les différences entre l'existant et ce qui serait appliqué.

.La combinaison des deux donne un dry-un complet.
[source,bash]
----
ansible-playbook site.yml --check --diff
----

=== no_log & validate

* **no_log: true** : masque la sortie d'une tâche qui manipule des secrets (sinon Ansible affichet tout)

[source,yml]
----
- name: "Créer l’utilisateur DB avec mot de passe"
  community.postgresql.postgresql_user:
    name: appuser
    password: "{{ db_password }}"
  no_log: true   # empêche l’affichage de db_password dans les logs
----

* **validate** : permets de tester un fichier générer avant de le déployer (évite de casser un service avec un fichier invalide). A note que dans l'exemple **%s** est remplacé par le chemin temporaire du fichier généré.

[source,yml]
----
- name: "Déployer config nginx et valider avant"
  ansible.builtin.template:
    src: nginx.conf.j2
    dest: /etc/nginx/nginx.conf
    validate: "nginx -t -c %s"
----



== Autres Composants d'un Projet Ansible

=== Inventaire Dynamique et Construit

L'inventory n'est pas limité à des fichiers statiques. Il peut être généré dynamiquement.

.Inventory statique YAML
[source,yaml]
----
# inventories/prod/hosts.yml
all:
  children:
    webservers:
      hosts:
        web1.prod.example.com:
          ansible_host: 192.168.1.10
        web2.prod.example.com:
          ansible_host: 192.168.1.11
    databases:
      hosts:
        db1.prod.example.com:
          ansible_host: 192.168.1.20
          db_role: primary
        db2.prod.example.com:
          ansible_host: 192.168.1.21
          db_role: replica
----

.Inventory construit (dynamique)
[source,yaml]
----
# inventories/constructed.yml
plugin: constructed
strict: false
groups:
  # Groupe dynamique basé sur les facts
  debian_servers: "ansible_facts['os_family'] == 'Debian'"
  multi_core: "ansible_facts['processor_cores'] > 1"
  # Groupe basé sur des variables personnalisées
  high_memory: "memory_mb > 16384"

compose:
  # Variables composées dynamiquement
  ansible_ssh_common_args: >
    "-o ProxyCommand='ssh -W %h:%p bastion.example.com'"
----

.Inventory dynamique (script)
[source,python]
----
#!/usr/bin/env python3
# inventories/ec2.py
import json
import boto3

ec2 = boto3.client('ec2')
instances = ec2.describe_instances(Filters=[...])

inventory = {'_meta': {'hostvars': {}}}
for reservation in instances['Reservations']:
    for instance in reservation['Instances']:
        if instance['State']['Name'] == 'running':
            hostname = instance['PrivateDnsName']
            inventory['_meta']['hostvars'][hostname] = {
                'ansible_host': instance['PrivateIpAddress'],
                'instance_type': instance['InstanceType']
            }
            for tag in instance.get('Tags', []):
                if tag['Key'] == 'Role':
                    if tag['Value'] not in inventory:
                        inventory[tag['Value']] = {'hosts': []}
                    inventory[tag['Value']]['hosts'].append(hostname)

print(json.dumps(inventory))
----

Lorsque l'on donne un script python dans les inventory, ansible comprends qu'il doit l'executer. Il attends en retour un inventory au format _meta json:

[source,json]
----
{
  "<group>": {
    "hosts": ["<hostname>", "..."],
    "vars": { "<varname>": "<value>", "...": "..." },
    "children": ["<subgroup>", "..."]
  },
  "_meta": {
    "hostvars": {
      "<hostname>": {
        "<varname>": "<value>",
        "...": "..."
      }
    }
  }
}
----

Le contrat minimal est le suivant :

[source,json]
----
{
  "_meta": {
    "hostvars": {}
  }
}
----

.propriétés attendues par le contrat
[cols="1,1,1,5",options="header"]
|===
| Clé | Type | Optionnel | Exemple

| `<group>`
| objet
| oui
a|
[source,json]
----
"webservers": {
  "hosts": ["web1", "web2"],
  "vars": { "nginx_port": 80 },
  "children": ["frontend"]
}
----
| `<group>.hosts`
| tableau de chaînes
| oui
| `["web1", "web2"]`

| `<group>.vars`
| objet (clé=string, valeur=any)
| oui
| `{ "ansible_user": "ubuntu" }`

| `<group>.children`
| tableau de chaînes (noms de sous-groupes)
| oui
| `["frontend", "backend"]`

| `_meta`
| objet
| oui (recommandé)
a|
[source,json]
----
"_meta": { "hostvars": {} }
----

| `_meta.hostvars`
| objet (clé=hostname, valeur=objet)
| oui
a|
[source,json]
----
"hostvars": {
  "web1": { "ansible_host": "10.0.0.1" },
  "db1":  { "ansible_host": "10.0.0.2" }
}
----
|===


=== Collections Ansible

Les collections sont le nouveau format de distribution de contenu Ansible (modules, roles, plugins).

.Installation de collections
[source,yaml]
----
# requirements.yml
collections:
  - name: ansible.posix
    version: 1.4.0
  - name: community.general
    version: 6.6.0
  - name: community.docker
    version: 3.8.0
  - name: amazon.aws
    version: 6.1.0
----

[source,bash]
----
ansible-galaxy collection install -r requirements.yml
----

==== Structure d'une Collection

Une collection est un package regroupant:
- Modules
- Plugins
- Rôles
- Documentation
- Playbooks

Organisés par espaces de noms (namespace.name) pour une distribution modulaire.

==== Collections Principales (90% des cas d'usage)

[width="100%",cols="2,3",options="header"]
|===
| Collection | Usage Typique
| `ansible.builtin` | Modules core: `copy`, `file`, `template`, `package`, `service`
| `community.general` | Modules divers: `git`, `homebrew`, `openssl`, `lsof`
| `ansible.posix` | Systèmes POSIX: `firewalld`, `seboolean`, `sysctl`
| `community.docker` | Conteneurs Docker: `docker_container`, `docker_image`
| `community.aws` | Amazon AWS: `ec2_instance`, `s3_bucket`, `lambda_function`
| `community.azure` | Microsoft Azure: `azure_rm_virtualmachine`, `azure_rm_webapp`
| `google.cloud` | Google Cloud: `gcp_compute_instance`, `gcp_storage_bucket`
| `community.crypto` | Cryptographie: `openssh_key`, `acme_certificate`
| `community.network` | Réseau: `aci_tenant`, `vyos_config`, `ios_command`
| `community.postgresql` | PostgreSQL: `postgresql_user`, `postgresql_db`
| `community.mysql` | MySQL: `mysql_user`, `mysql_db`
| `kubernetes.core` | Kubernetes: `k8s_deployment`, `k8s_service`
| `community.grafana` | Monitoring: `grafana_dashboard`, `grafana_datasource`
| `community.hashi_vault` | HashiCorp Vault: `hashi_vault_secret`
| `community.proxmox` | Virtualisation Proxmox: `proxmox_vm`
| `community.windows` | Windows: `win_feature`, `win_domain`
| `ansible.windows` | Modules Windows core: `win_copy`, `win_service`
|===

==== Utilisation dans les Playbooks

[source,yaml]
----
# Méthode 1: Préfixage explicite
- community.general.git:
    repo: "https://github.com/example/repo.git"
    dest: /opt/repo

# Méthode 2: Déclaration en en-tête
- hosts: all
  collections:
    - community.general
    - community.docker
  tasks:
    - git:
        repo: "https://github.com/example/repo.git"
        dest: /opt/repo
    - docker_container:
        name: app
        image: nginx
----

.Utilisation dans les playbooks
[source,yaml]
----
- name: Utiliser un module d'une collection
  community.docker.docker_container:
    name: myapp
    image: nginx:latest
    state: started

- name: Inclure un rôle d'une collection
  hosts: all
  roles:
    - community.postgresql.postgresql
----

=== Plugins Personnalisés

Les plugins étendent les fonctionnalités d'Ansible (filtres, tests, lookups, etc.).

.Structure de répertoire pour les plugins
[source,bash]
----
project/
├── filter_plugins/
│   └── custom_filters.py
├── lookup_plugins/
│   └── custom_lookup.py
├── callback_plugins/
│   └── custom_callback.py
└── inventory/
    └── custom_inventory.py
----

.Exemple de plugin de filtre
[source,python]
----
# filter_plugins/custom_filters.py
def to_upper(value):
    """Convertit une chaîne en majuscules"""
    return value.upper()

def reverse_list(value):
    """Inverse une liste"""
    return list(reversed(value))

class FilterModule(object):
    def filters(self):
        return {
            'to_upper': to_upper,
            'reverse_list': reverse_list
        }
----

.Utilisation dans un playbook
[source,yaml]
----
- name: Utiliser un filtre personnalisé
  ansible.builtin.debug:
    msg: "{{ 'hello' | to_upper }}"

- name: Utiliser un lookup personnalisé
  ansible.builtin.debug:
    msg: "{{ lookup('custom_lookup', 'param') }}"
----

=== Tests & linting

.Mode check et diff
[source,bash]
----
ansible-playbook playbook.yml --check --diff
----

.Validation et Linting
[source,bash]
----
# Validation syntaxique
ansible-playbook --syntax-check playbook.yml

# Vérification des bonnes pratiques
ansible-lint playbook.yml

# Validation YAML
yamllint .

# Test dry-run
ansible-playbook --check --diff playbook.yml
----

[NOTE]
Molecule est un framework de test qui permet de créer et gérer des environnements de test temporaires pour valider vos rôles Ansible.

.Workflow Molecule
[source,bash]
----
molecule test        # Cycle complet: create → converge → verify → destroy
molecule create      # Crée l'environnement de test (containers/VM)
molecule converge    # Applique le rôle (équivalent ansible-playbook)
molecule verify      # Exécute les tests de vérification
molecule destroy     # Nettoie l'environnement
molecule lint        # Vérifie la syntaxe et les bonnes pratiques
----

.Structure typique
[source,bash]
----
roles/mon_role/
└── molecule/
    └── default/           # Scénario par défaut
        ├── molecule.yml   # Configuration du scénario
        ├── converge.yml   # Playbook de test principal
        └── verify.yml     # Tests de validation
----

.Exemple molecule.yml
[source,yaml]
----
dependency:
  name: galaxy           # Gestion des dépendances
driver:
  name: docker          # Pilote (docker, vagrant, etc.)
platforms:
  - name: instance
    image: debian:11     # Image de base
provisioner:
  name: ansible         # Utilise Ansible comme provisioner
verifier:
  name: ansible         # Utilise Ansible pour la vérification
----

.Exemple converge.yml
[source,yaml]
----
- hosts: all
  roles:
    - role: ../../      # Teste le rôle courant
      vars:
        enabled: true
        state: present
----

.Exemple verify.yml
[source,yaml]
----
- hosts: all
  tasks:
    - name: "Vérifier service actif"
      service:
        name: "{{ name }}"
        state: started
      changed_when: false

    - name: "Vérifier port en écoute"
      wait_for:
        port: "{{ ports[0] }}"
        timeout: 5
----

=== Gestion des Secrets avec Ansible Vault

Ansible Vault chiffre (AES256) tes variables/fichiers au repos pour pouvoir les committer sans exposer les secrets. Au runtime, Ansible décrypte en mémoire si tu fournis le mot de passe. Très concrètement, on stocke nos fichiers cryptés de manière symétrique à l'aide d'un mot de passe. A l'execution du playbook avec l'option --ask-vault-pass ou avec l'option --vault-password-file, le fichier est decrypté en mémoire et les variables sont chargées. Donc on ne commit jamais de mot de passes.


==== Fichier chiffré auto-chargé via group_vars/host_vars

Le fichier n'a pas besoin d'être explicitement chargé avec include_vars puisqu'il est dans le group_vars qui est chargé par défaut par ansible.

[source,bash]
----
# Créer un fichier chiffré dans l'inventaire
ansible-vault create inventories/staging/group_vars/all/vault.yml
----

[source,yaml]
----
# Contenu du fichier vault.yml
db_user: "appuser"
db_password: "Tr3sS3cret!"
----

[source,yaml]
----
# Utilisation dans les playbooks/roles
- name: "Créer l'utilisateur DB"
  community.postgresql.postgresql_user:
    name: "{{ db_user }}"
    password: "{{ db_password }}"
    state: present
  no_log: true
----

[source,bash]
----
# Exécution
ansible-playbook -i inventories/staging/hosts.ini playbooks/site.yml --ask-vault-pass
# ou
ansible-playbook -i inventories/staging/hosts.ini playbooks/site.yml --vault-password-file ~/.vault_pass
----

==== Fichier chiffré "ailleurs" + inclusion explicite (vars_files)

Il faut le charger explicitement, ansible ne charge pas de dossiers vars.

[source,bash]
----
# Créer un fichier chiffré hors inventaire
ansible-vault create playbooks/vars/secrets.yml
----

[source,yaml]
----
# playbooks/site.yml
- hosts: web
  vars_files:
    - "{{ playbook_dir }}/vars/secrets.yml"
  tasks:
    - name: "Utiliser le secret"
      ansible.builtin.debug:
        msg: "User DB = {{ db_user }}"
      no_log: true
----

==== Éditer / Voir / Rechiffrer

[source,bash]
----
# Éditer
ansible-vault edit inventories/staging/group_vars/all/vault.yml

# Voir (lecture seule)
ansible-vault view inventories/staging/group_vars/all/vault.yml

# Chiffrer un fichier existant
ansible-vault encrypt path/to/file.yml

# Déchiffrer un fichier
ansible-vault decrypt path/to/file.yml

# Changer le mot de passe
ansible-vault rekey inventories/staging/group_vars/all/vault.yml
----

==== Chiffrer une variable individuelle

[source,bash]
----
# Générer le snippet
ansible-vault encrypt_string 'Tr3sS3cret!' --name 'db_password'
----

[source,yaml]
----
# Coller la sortie dans un fichier YAML
db_password: !vault |
  $ANSIBLE_VAULT;1.1;AES256
  3236633830...
----

==== Fournir le mot de passe

[source,bash]
----
# Interactif
ansible-playbook ... --ask-vault-pass

# Fichier (chmod 600 recommandé)
echo 'ton-mot-de-passe' > ~/.vault_pass
ansible-playbook ... --vault-password-file ~/.vault_pass

# Variable d'environnement
export ANSIBLE_VAULT_PASSWORD_FILE=~/.vault_pass
ansible-playbook ...

# Vault IDs (plusieurs mots de passe)
ansible-playbook ... --vault-id dev@prompt --vault-id prod@~/.vault_pass_prod
----

==== Bonnes pratiques

- Choisis un seul pattern: group_vars/host_vars auto-chargés OU vars_files
- Ne commit jamais le fichier de mot de passe Vault
- Utilise `no_log: true` pour les tâches manipulant des secrets
- Pour l'échappement YAML, préfère `encrypt_string`
- Fais une rotation régulière avec `ansible-vault rekey`
- En CI/CD, passe le mot de passe via des secrets de pipeline
- Garde les secrets dans un fichier dédié pour des diffs propres

=== Optimisation des Performances

.Configuration pour la performance
[source,bash]
----
# ansible.cfg
[defaults]
forks = 50                     # Augmente le parallélisme
host_key_checking = False      # Désactive la vérification des clés
pipelining = True              # Active le pipelining SSH
fact_caching = jsonfile        # Active le cache de facts
fact_caching_connection = ~/.ansible/facts
fact_caching_timeout = 86400   # 24 heures

[ssh_connection]
ssh_args = -C -o ControlMaster=auto -o ControlPersist=60s
----

.Stratégies d'exécution parallèle
[source,yaml]
----
- name: Play avec stratégie free
  hosts: large_group
  strategy: free
  tasks:
    - name: Tâche longue
      ansible.builtin.command: /opt/long_task.sh
----

=== Workflows Avancés

.Exécution conditionnelle avec tags
[source,yaml]
----
tasks:
  - name: Installation de base
    ansible.builtin.package:
      name: base_package
      state: present
    tags: base

  - name: Configuration avancée
    ansible.builtin.template:
      src: advanced.conf.j2
      dest: /etc/advanced.conf
    tags: advanced
----

[source,bash]
----
ansible-playbook playbook.yml --tags "base"       # Seulement base
ansible-playbook playbook.yml --skip-tags "advanced"  # Tout sauf advanced
----

.Pré-tasks et post-tasks
[source,yaml]
----
- name: Play avec hooks
  hosts: all
  pre_tasks:
    - name: Préparation
      ansible.builtin.command: /bin/prepare.sh

  roles:
    - role: main_role

  post_tasks:
    - name: Nettoyage
      ansible.builtin.command: /bin/cleanup.sh

  handlers:
    - name: Redémarrage
      ansible.builtin.service:
        name: app
        state: restarted
----

=== Intégration avec CI/CD

.Exemple de pipeline GitLab CI
[source,yaml]
----
# .gitlab-ci.yml
stages:
  - test
  - deploy

ansible-lint:
  stage: test
  image: cytopia/ansible-lint
  script:
    - ansible-lint playbooks/

molecule-test:
  stage: test
  image: geerlingguy/docker-ubuntu2004-ansible
  script:
    - molecule test

deploy-staging:
  stage: deploy
  image: ansible/ansible
  script:
    - ansible-playbook playbooks/site.yml -i inventories/staging/
  only:
    - main

deploy-production:
  stage: deploy
  image: ansible/ansible
  script:
    - ansible-playbook playbooks/site.yml -i inventories/production/
  only:
    - tags
  when: manual
----

.Exemple de workflow GitHub Actions
[source,yaml]
----
# .github/workflows/ansible.yml
name: Ansible Playbook

on: [push, pull_request]

jobs:
  ansible:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3

    - name: Setup Ansible
      run: |
        sudo apt-get update
        sudo apt-get install -y ansible

    - name: Run ansible-lint
      run: ansible-lint playbooks/

    - name: Run playbook in check mode
      run: |
        ansible-playbook playbooks/site.yml -i inventories/test/ --check --diff
----

=== Debug Avancé

==== Debug Tasks

[source,yaml]
----
- debug:
    msg: "Message visible seulement avec -vvv"
    verbosity: 3

- debug:
    msg: "Message toujours visible"
    changed_when: false
----

==== Verbosité et Variables d'Environnement

[source,bash]
----
# Niveaux de verbosité
ansible-playbook -vvv playbooks/site.yml
ansible -vvv all -m ping

# Debug interne Ansible (stack trace)
ANSIBLE_DEBUG=1 ansible-playbook playbooks/site.yml

# Conserver les fichiers temporaires
ANSIBLE_KEEP_REMOTE_FILES=1 ansible-playbook playbooks/site.yml

# Forcer un fichier de config spécifique
ANSIBLE_CONFIG=./ansible.cfg ansible-playbook playbooks/site.yml

# Debug SSH hors Ansible
ssh -vvv -i ~/.ssh/id_ed25519 user@host
----

==== Introspection de Configuration et Inventaire

[source,bash]
----
# Voir la configuration appliquée
ansible-config view
ansible-config dump --only-changed

# Lister l'inventaire
ansible-inventory -i inventories/prod/hosts.ini --graph
ansible-inventory -i inventories/prod/hosts.ini --list --yaml

# Documentation des modules
ansible-doc -l
ansible-doc template
----

==== Diagnostiquer les Changements et Échecs

[source,bash]
----
# Dry-run avec diff
ansible-playbook site.yml --check --diff -vv

# Format de sortie YAML
ANSIBLE_STDOUT_CALLBACK=yaml ansible-playbook site.yml -vv
----

==== SSH et Transport

[source,bash]
----
# Tester la chaîne SSH manuellement
ssh -vvv -o ProxyCommand='ssh -W %h:%p bastion' user@target

# Désactiver le multiplexing
ANSIBLE_SSH_ARGS="-o ControlMaster=no" ansible -m ping all -vvv

# Tester les timeouts
ansible -m wait_for -a "host=example.com port=22 timeout=5" localhost
----

==== Privilege Escalation (sudo)

[source,bash]
----
# Tester sudo
ansible all -m command -a "id -u" -b -K -vv

# Désactiver pipelining temporairement
ANSIBLE_PIPELINING=0 ansible all -m setup -vv
----

==== Facts et Interpréteur Python

[source,bash]
----
# Vérifier Python distant
ansible all -m setup -a 'filter=ansible_python*' -vv

# Interpréteur auto_silent
ANSIBLE_CONFIG=./ansible.cfg ansible all -m ping -vv

# Désactiver facts
ansible-playbook site.yml -e "gather_facts=false" -vv
----

==== Inspection des Fichiers Distants

[source,bash]
----
# Avec ANSIBLE_KEEP_REMOTE_FILES=1, sur l'hôte distant:
sudo ls -la /root/.ansible/tmp/
sudo cat /root/.ansible/tmp/ansible-tmp-*/debug_payload
----

==== Performance et Exécution Pas-à-Pas

[source,bash]
----
# Profilage des tâches
ANSIBLE_CONFIG=./ansible.cfg ansible-playbook site.yml -vv

# Exécution interactive
ansible-playbook site.yml --step -vv
----


==== Connexion SSH via Bastion

[source,ini]
----
# Inventaire
[prod]
web1 ansible_host=10.1.0.10 ansible_ssh_common_args='-o ProxyJump=user@bastion.example.com'

# Group vars
ansible_ssh_common_args: '-o ProxyJump=user@bastion.example.com'
----

==== Erreurs Fréquentes et Solutions

.Error Patterns & Quick Fixes
[source,text]
----
"FAILED! => {'msg': 'Missing sudo password'}"
→ Utiliser -K, configurer become/become_user, vérifier NOPASSWD

"Timeout (12s) waiting for privilege escalation prompt"
→ Nettoyer /etc/sudoers.d, tester -K, réduire MOTD interactif

"python not found" / "MODULE FAILURE"
→ Installer python3, utiliser interpreter_python=auto_silent
ou: ansible all -m raw -a "apt-get update && apt-get install -y python3"

Diff systemd invalide
→ Ajouter validate: "systemd-analyze verify %s" sur le template

Fichier rendu invalide (nginx/haproxy)
→ Utiliser validate: "nginx -t -c %s" / "haproxy -c -f %s" + --check --diff
----

.Astuce Finale
[source,text]
----
Réduire le scope pour isoler (un hôte, une tâche, -vvv) puis élargir progressivement
----

== Bonnes Pratiques de Structuration

=== Organisation Multi-Environnements

[source,bash]
----
inventories/
├── production/
│   ├── hosts
│   ├── group_vars/
│   │   ├── all.yml
│   │   ├── webservers.yml
│   │   └── databases.yml
│   └── host_vars/
│       ├── web1.prod.example.com.yml
│       └── db1.prod.example.com.yml
├── staging/
│   ├── hosts
│   ├── group_vars/
│   │   └── all.yml
│   └── host_vars/
└── development/
    ├── hosts
    └── group_vars/
        └── all.yml
----

=== Variables par Environnement

[source,yaml]
----
# inventories/production/group_vars/all.yml
environment: production
app_version: "2.5.0"
db_host: db-prod.internal
deploy_user: prod-deploy

# inventories/staging/group_vars/all.yml
environment: staging
app_version: "2.5.0-rc1"
db_host: db-staging.internal
deploy_user: staging-deploy
----

=== Templates Conditionnels par Environnement

[source,jinja]
----
# templates/app.conf.j2
{% if environment == "production" %}
log_level: warn
max_connections: 1000
{% elif environment == "staging" %}
log_level: info
max_connections: 100
{% else %}
log_level: debug
max_connections: 10
{% endif %}
----

=== Documentation et Maintenance

.Playbook de documentation
[source,yaml]
----
- name: Documentation du projet
  hosts: localhost
  connection: local
  gather_facts: false
  tasks:
    - name: Afficher l'inventaire
      ansible.builtin.debug:
        msg: "{{ groups }}"

    - name: Afficher les variables disponibles
      ansible.builtin.debug:
        msg: "{{ vars }}"

    - name: Générer la documentation
      ansible.builtin.template:
        src: README.md.j2
        dest: documentation/README.md
----


== Structure de projet avancée

.Arborescence type
[source,bash]
----
ansible/
├─ ansible.cfg
├─ inventories/
│ ├─ staging/
│ │ ├─ hosts.ini
│ │ ├─ group_vars/
│ │ │ ├─ all.yml
│ │ │ ├─ web.yml
│ │ │ └─ db.yml
│ │ └─ host_vars/
│ │ ├─ web-01.yml
│ │ └─ db-01.yml
│ └─ prod/...
├─ playbooks/
│ ├─ site.yml # point d’entrée
│ ├─ web.yml # playbook focalisé “web”
│ ├─ db.yml # playbook focalisé “db”
│ ├─ includes/
│ │ ├─ tasks_common.yml # tâches importables réutilisables
│ │ └─ handlers_common.yml
│ └─ vars/
│ ├─ defaults.yml # vars transverses chargées par vars_files
│ └─ secrets.yml # (chiffré avec Vault)
├─ roles/
│ ├─ base_setup/
│ │ ├─ defaults/main.yml
│ │ ├─ vars/main.yml
│ │ ├─ tasks/main.yml
│ │ ├─ handlers/main.yml
│ │ ├─ templates/... # j2
│ │ └─ files/...
│ └─ webapp/...
├─ collections/ # si utilisées (galaxy)
├─ plugins/
│ ├─ filter/
│ ├─ lookup/
│ └─ inventory/ # (constructed, custom)
├─ library/ # modules custom
├─ group_vars/ # si inventaire “à plat” (non recommandé si multi-env)
└─ .fact_cache/ # cache des facts (hors VCS)
----
