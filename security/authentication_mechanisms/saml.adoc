:author-url: https://github.com/rridane
:author: rridane
:source-highlighter: rouge
:hardbreaks:
:table-caption!:
:toc: left

= Authentification SAML 2.0

== üß≠ Vue macro du flux SAML SP-initi√©

L'authentification SAML se base sur un √©change de messages entre un Service Provider (SP) et un Identity Provider (IdP), structur√© comme un aller-retour HTTP.

Chaque entit√© publie un fichier `metadata.xml` :

- Le `metadata.xml` du **IdP** est fourni au **SP** pour :
- identifier l‚Äô`EntityID` de l‚ÄôIdP
- conna√Ætre le point d‚Äôentr√©e SSO (`SingleSignOnService`)
- v√©rifier les signatures des `SAMLResponse`

- Le `metadata.xml` du **SP** est fourni au **IdP** pour :
- conna√Ætre les URLs autoris√©es (`AssertionConsumerService`)
- v√©rifier les signatures des `SAMLRequest`
- chiffrer des assertions avec la cl√© publique du SP si n√©cessaire

Le flux ici d√©crit correspond au binding HTTP-Redirect (GET) initi√© par le SP.

=== √âtape 1 : Requ√™te SAML (GET avec SAMLRequest en base64)

Le client tente d'acc√©der √† une ressource prot√©g√©e sur le SP. Le SP le redirige vers l'IdP avec une requ√™te `SAMLRequest`.

Ce `SAMLRequest` est :

- compress√© (`deflate`)
- encod√© en base64
- transmis en tant que param√®tre d‚ÄôURL

[source]
----
GET https://idp.example.com/sso?SAMLRequest=...&RelayState=...&SigAlg=...&Signature=...
----

La SAMLRequest contient **deux informations critiques** :

1. `Issuer` : identifie le SP (`EntityID`)
2. `AssertionConsumerServiceURL` : indique √† l‚ÄôIdP o√π renvoyer la r√©ponse

Ces deux informations suffisent en th√©orie √† garantir la s√©curit√©. L'IdP peut v√©rifier l'identit√© du SP avec l'issuer et l'url de redirection demand√© avec l'AssertionConsumerServiceURL. Mais dans les faits, on prot√®ge souvent le flux d'authentification de signatures suppl√©mentaires:

* Une signature des param√®tres de l'URL: SAMRequest=...&RelayState=... sign√©e √† l'aide de la cl√© priv√©e du SP, d√©crypt√©e √† l'aide de la cl√© publique contenue dans le metadata.xml fourni par le SP √† l'IdP.
* Un chiffrement de tout ou partie de la SAMLRequest √† l'int√©rieur de celle-ci, √† l'aide de la cl√© publique contenue dans le metadata.xml fourni par l'IdP au SP.

La signature permets de v√©rifier que l'url n'a pas √©t√© modifi√© depuis le d√©tenteur de la cl√© priv√©e, donc le SP.

Le chiffrement permets de chiffrer les informations d√©tenus dans la SAMLRequest, seul l'IdP pourra alors d√©crypter √† l'aide de sa cl√© priv√©e.

[NOTE]
--
üîÅ En r√©alit√©, on ne chiffre quasiment jamais la SAMLRequest, et quand c‚Äôest le cas, c‚Äôest le SP qui chiffre une partie √† destination de l‚ÄôIdP avec la cl√© publique de l‚ÄôIdP.

Mais dans le flux standard Redirect (GET), la SAMLRequest est sign√©e, pas chiffr√©e. C‚Äôest la SAMLResponse, ou plus pr√©cis√©ment l‚ÄôAssertion, qui peut √™tre chiffr√©e, avec la cl√© publique du SP.
--

== üîê M√©canisme de s√©curit√© c√¥t√© IdP

√Ä ce stade, l‚Äôutilisateur **n‚Äôest pas encore authentifi√©**. L‚ÄôIdP va :

- Lire la `SAMLRequest`
- Identifier l'`Issuer`
- Valider que le `AssertionConsumerServiceURL` correspond bien √† une valeur **connue et enregistr√©e** pour ce `Issuer`

C‚Äôest **l‚Äôunique rempart contre les `SAMLRequest` forg√©es** quand elles ne sont **pas sign√©es**.

(En r√©alit√©, cette validation (Issuer + AssertionConsumerServiceURL) est vuln√©rable aux attaques de rejeu si aucun autre m√©canisme (ex: ID unique + timestamp) n'est impl√©ment√©.)

Quand l'url est sign√©, il va utiliser la cl√© publique d√©tenue par le metadata.xml fournie par le SP pour v√©rifier l'authenticit√© des param√®tres d'url

Quand la SAMLRequest est chiffr√©e, il va utiliser sa cl√© priv√©e pour la d√©crypter.

== Etape 2 - SAMLResponse

L'IdP g√©n√®re un ou plusieurs assertions et signe cette r√©ponse √† l'aide de sa cl√© priv√©e. En pratique la r√©ponse contient souvent une assertion, mais il est tout √† fait possible qu'une assertion contienne l'identit√© de l'utilisateur et une autre contienne les droits d'acc√®s par ex (XACML, etc), une assertion peut aussi contenir une preuve d'authentification ou des extensions personnalis√©es.

Ces assertions peuvent √©galement √™tre chiffr√©es √† l'aide de la cl√© publique du SP. Dans ce cas la SAMLResponse contient d'une part une signature globale, mais contient √©galement des assertions chiffr√©es.

Le SP validera la signature √† l'aide de la cl√© publique fournie par l'IdP dans le metadata.xml et d√©cryptera les assertions √† l'aide de sa cl√© priv√©e.

== üîê Mod√®le de confiance

|===
| R√¥le | Poss√®de la **cl√© priv√©e** pour ‚Ä¶ | Fait circuler la **cl√© publique / certificat** via ‚Ä¶
|------|---------------------------------|------------------------------------------------------
| **IdP** | ‚Ä¢ Signer chaque `SAMLResponse` (et √©ventuellement l‚Äô`Assertion`) | `metadata.xml` de l‚ÄôIdP ‚áí remis au **SP**
| **SP** | ‚Ä¢ *Optionnel* : signer la `SAMLRequest`<br>‚Ä¢ *Optionnel* : d√©chiffrer une `EncryptedAssertion` | `metadata.xml` du SP ‚áí remis √† l‚Äô**IdP**, signer les param√®tres d'URL.
|===

* Remarque : si l‚Äô`Assertion` est chiffr√©e, l‚ÄôIdP chiffre avec la **cl√© publique du SP** et seul le SP peut d√©chiffrer avec sa cl√© priv√©e.

== üì§ Exemple complet de `SAMLRequest`

[source,xml]
----
<samlp:AuthnRequest
    xmlns:samlp="urn:oasis:names:tc:SAML:2.0:protocol"
    xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion"
    ID="_12345"
    Version="2.0"
    IssueInstant="2025-07-10T08:00:00Z"
    Destination="https://idp.example.com/sso"
    AssertionConsumerServiceURL="https://sp.example.com/saml/acs"
    ProtocolBinding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST">
  <saml:Issuer>https://sp.example.com/metadata</saml:Issuer>
  <samlp:NameIDPolicy
      Format="urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress"
      AllowCreate="true"/>
  <samlp:RequestedAuthnContext Comparison="exact">
    <saml:AuthnContextClassRef>
      urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport
    </saml:AuthnContextClassRef>
  </samlp:RequestedAuthnContext>
</samlp:AuthnRequest>
----

== üì• Exemple complet de `SAMLResponse`

[source,xml]
----
<samlp:Response
    xmlns:samlp="urn:oasis:names:tc:SAML:2.0:protocol"
    ID="_response123"
    InResponseTo="_12345"
    Version="2.0"
    IssueInstant="2025-07-10T08:00:10Z"
    Destination="https://sp.example.com/saml/acs">
  <saml:Issuer xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion">
    https://idp.example.com
  </saml:Issuer>
  <samlp:Status>
    <samlp:StatusCode Value="urn:oasis:names:tc:SAML:2.0:status:Success"/>
  </samlp:Status>

  <saml:Assertion xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion"
      ID="_assertion123"
      IssueInstant="2025-07-10T08:00:10Z"
      Version="2.0">
    <saml:Issuer>https://idp.example.com</saml:Issuer>

    <saml:Subject>
      <saml:NameID Format="urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress">
        user@example.com
      </saml:NameID>
      <saml:SubjectConfirmation Method="urn:oasis:names:tc:SAML:2.0:cm:bearer">
        <saml:SubjectConfirmationData
            InResponseTo="_12345"
            NotOnOrAfter="2025-07-10T08:05:00Z"
            Recipient="https://sp.example.com/saml/acs"/>
      </saml:SubjectConfirmation>
    </saml:Subject>

    <saml:Conditions NotBefore="2025-07-10T08:00:00Z" NotOnOrAfter="2025-07-10T08:05:00Z">
      <saml:AudienceRestriction>
        <saml:Audience>https://sp.example.com/metadata</saml:Audience>
      </saml:AudienceRestriction>
    </saml:Conditions>

    <saml:AuthnStatement AuthnInstant="2025-07-10T08:00:05Z">
      <saml:AuthnContext>
        <saml:AuthnContextClassRef>
          urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport
        </saml:AuthnContextClassRef>
      </saml:AuthnContext>
    </saml:AuthnStatement>

    <saml:AttributeStatement>
      <saml:Attribute Name="email">
        <saml:AttributeValue>user@example.com</saml:AttributeValue>
      </saml:Attribute>
      <saml:Attribute Name="groups">
        <saml:AttributeValue>admin</saml:AttributeValue>
      </saml:Attribute>
    </saml:AttributeStatement>
  </saml:Assertion>
</samlp:Response>
----

== üìã D√©tails des param√®tres

=== `AuthnRequest` ‚Äì Param√®tres XML (contenus dans le SAMLRequest)

|===
| √âl√©ment / Attribut | Obligatoire | Description

| `ID` | Oui | Identifiant unique pour le couplage avec `InResponseTo`.
| `IssueInstant` | Oui | Timestamp ISO 8601.
| `Destination` | Recommand√© | Endpoint SSO de l‚ÄôIdP (doit matcher celui du metadata).
| `AssertionConsumerServiceURL` | Oui | Endpoint ACS du SP.
| `ProtocolBinding` | Non | Binding attendu pour la r√©ponse (`POST`, `Artifact`, etc.).
| `Issuer` | Oui | `EntityID` du SP.
| `ForceAuthn` / `IsPassive` | Non | Requiert une nouvelle authentification / pas d‚Äôinteraction utilisateur.
| `NameIDPolicy` | Non | Format du `NameID` souhait√© (ex: email, transient).
| `RequestedAuthnContext` | Non | Niveau d‚Äôauthentification requis (ex: MFA, password).
| `Signature` (XML-DSig) | Facultatif | Signature XML de la requ√™te (en mode POST, principalement).
|===

=== `AuthnRequest` ‚Äì Param√®tres de transport (hors XML, en query string)

|===
| Param√®tre HTTP | Obligatoire | Description

| `RelayState` | Non | Donn√©e opaque transmise par le SP, renvoy√©e telle quelle par l‚ÄôIdP.
| `SigAlg` | Oui si `Signature` | Algorithme utilis√© pour signer (`rsa-sha256`, etc.).
| `Signature` | Oui si signature | Signature HMAC/DSig de la cha√Æne canonique (base64 du SAMLRequest + SigAlg + RelayState).
|===

=== `SAMLResponse` / `Assertion`

*XML global

|===
| √âl√©ment / Attribut | Obligatoire | Description

| `ID` (`Response`) | Oui | Identifiant de la r√©ponse.
| `InResponseTo` | Oui | Fait r√©f√©rence √† l‚Äô`ID` de la requ√™te.
| `Destination` | Oui | Doit matcher l‚ÄôACS connue du SP.
| `Issuer` (`Response`) | Oui | `EntityID` de l‚ÄôIdP.
| `StatusCode` | Oui | R√©sultat (`Success`, `Responder`, etc.).
|===

*Bloc `Assertion`*

|===
| `ID` (`Assertion`) | Oui | Identifiant unique.
| `Issuer` (`Assertion`) | Oui | IdP √©metteur.
| `Subject` / `NameID` | Oui | Identit√© de l‚Äôutilisateur.
| `SubjectConfirmation` | Oui | Contr√¥le de r√©ception (Recipient, NotOnOrAfter‚Ä¶).
| `Conditions` | Oui | Fen√™tre de validit√©, restrictions d‚Äôaudience.
| `AuthnStatement` | Non | Date et contexte d‚Äôauth.
| `AttributeStatement` | Non | Attributs (`email`, `groups`, etc.).
| `Signature` | Oui | Sign√©e par la **cl√© priv√©e de l‚ÄôIdP**.
|===

== üß© Subtilit√©s et options avanc√©es

* **Bindings** : Redirect (GET, deflate+base64), POST (body base64), Artifact (indirection).
* **Chiffrement** : `<EncryptedAssertion>` ‚Üí IdP chiffre avec la cl√© publique du SP.
* **RelayState** : jamais sensible, v√©rifier qu‚Äôil ne permet pas de redirection externe.
* **Conditions** : timestamps anti-replay, `AudienceRestriction`, `Recipient`.
* **NameID formats** : `emailAddress`, `persistent`, `transient`, `unspecified`.
* **AuthnContext** : impose password, MFA, certificat X.509, etc.

[NOTE]
--
üîê √Ä propos de RelayState

Le param√®tre RelayState permet au SP de conserver un contexte tout au long du cycle SAML (par exemple : URL d'origine, identifiant de session interne, etc.).

Quelques r√®gles et bonnes pratiques :

- Sa valeur est opaque pour l‚ÄôIdP, qui la retransmet telle quelle dans la r√©ponse.
- Elle ne doit jamais contenir de donn√©es sensibles (ni token, ni identifiant utilisateur).
- Elle ne doit pas contenir d'URL externe non ma√Ætris√©e, pour √©viter les attaques de type open redirect.
- Le SP doit toujours valider cette valeur apr√®s r√©ception (ex. : correspondance avec une session temporaire, inclusion dans une whitelist, etc.).

üëâ En r√©sum√© : c‚Äôest un champ libre, mais √† manipuler avec pr√©caution, car l‚ÄôIdP ne le prot√®ge pas.
--

== üîÄ Autres bindings SAML (flux alternatifs)

SAML 2.0 propose plusieurs m√©thodes de transport pour les messages (`AuthnRequest`, `Response`, etc.), appel√©es *bindings*. Chaque binding d√©finit la fa√ßon dont le message est encod√©, transmis et sign√©.

=== 1. HTTP-Redirect Binding (SP-initi√© via GET)

* Utilis√© pour : `AuthnRequest`
* Transport : Requ√™te GET avec `SAMLRequest` compress√© (deflate), encod√© en base64 dans l‚ÄôURL
* Signature : des param√®tres d‚ÄôURL (`SAMLRequest`, `RelayState`, `SigAlg`, `Signature`)
* Avantages :
** Simplicit√© d‚Äôimpl√©mentation
** Aucun besoin de page HTML (GET direct)
* Inconv√©nients :
** Taille maximale de l‚ÄôURL (‚âà 2 Ko)
** Signature XML non possible (seulement signature d‚ÄôURL)

=== 2. HTTP-POST Binding (SP ou IdP via POST)

* Utilis√© pour : `AuthnRequest`, `SAMLResponse`
* Transport : Donn√©e encod√©e en base64, transmise dans un champ `input` d‚Äôun formulaire HTML
* Signature : XML-DSig (signature int√©gr√©e dans le message XML)
* Avantages :
** Pas de limite de taille
** Signature XML compl√®te possible
* Inconv√©nients :
** N√©cessite une soumission HTML (formulaires)
** Moins adapt√© aux flux purement API

[NOTE]
====
üß† Lors du retour du `SAMLResponse` en binding POST, l‚ÄôIdP **ne redirige pas** le navigateur.

Il retourne une **page HTML** contenant un formulaire (g√©n√©ralement cach√©) avec la `SAMLResponse` en base64, ciblant l‚Äô`AssertionConsumerService` du SP.

Ce formulaire est souvent automatiquement soumis via JavaScript (`onload=submit()`).

üö® Ce n‚Äôest **pas une redirection HTTP (302)**, mais bien une **r√©ponse HTTP 200** contenant du HTML.
Le navigateur charge cette page, puis le formulaire s‚Äôauto-soumet : c‚Äôest ce qui cr√©e la requ√™te `POST` vers le SP.
====

=== 3. HTTP-Artifact Binding

* Utilis√© pour : `AuthnRequest`, `SAMLResponse` (indirect)
* Transport :
** Le SP envoie une `AuthnRequest` comme d‚Äôhabitude
** L‚ÄôIdP ne renvoie pas directement une `SAMLResponse`, mais un `Artifact` (identifiant court)
** Le SP r√©sout ensuite cet `Artifact` via une requ√™te SOAP (`ArtifactResolve`)
* Avantages :
** L‚Äô`Assertion` ne transite pas dans le navigateur (meilleure s√©curit√©)
* Inconv√©nients :
** Impl√©mentation plus complexe
** Requiert un canal backchannel SOAP s√©curis√©

=== 4. SOAP Binding (backchannel s√©curis√©)

* Utilis√© pour : op√©rations serveur-√†-serveur (ex : `ArtifactResolve`, `LogoutRequest`, `AttributeQuery`)
* Transport : Requ√™tes POST avec messages XML envelopp√©s dans du SOAP
* Avantages :
** Tr√®s s√©curis√©
** Permet des √©changes silencieux et synchrones entre serveurs
* Inconv√©nients :
** Plus complexe √† mettre en ≈ìuvre
** Peu adapt√© aux interactions front utilisateur

=== üìä R√©capitulatif

|===
| Binding | M√©thode HTTP | Message typique | Utilisation principale | Signature support√©e

| HTTP-Redirect | GET (URL query) | `SAMLRequest` | AuthnRequest (SP-initi√©) | Signature d‚ÄôURL (query string)
| HTTP-POST | POST (formulaire) | `SAMLResponse`, `SAMLRequest` | R√©ponse IdP ‚Üí SP (ACS) | Signature XML (XML-DSig)
| HTTP-Artifact | GET + POST SOAP | `Artifact` + `SAMLResponse` | Transmission s√©curis√©e des r√©ponses | Signature XML (dans r√©ponse r√©solue)
| SOAP | POST (XML/SOAP) | `LogoutRequest`, `AttributeQuery` | Backchannel / API | Signature XML
|===

[NOTE]
--
üéØ En pratique :

- **HTTP-Redirect** est souvent utilis√© pour initier l‚Äôauthentification.
- **HTTP-POST** est le plus courant pour la transmission des `SAMLResponse`.
- **HTTP-Artifact** est utilis√© quand la confidentialit√© prime (ex : √©changes sensibles).
- **SOAP** est r√©serv√© aux op√©rations silencieuses ou techniques (ex : d√©connexion, r√©solution d‚Äô`Artifact`).
--

== üîÑ Flux IdP-initi√©

Dans le sc√©nario *IdP-initi√©*, l'utilisateur commence sa navigation sur le portail de l'Identity Provider (IdP), souvent via un tableau de bord ou un bouton "Acc√©der √† l'application".

=== üîÅ D√©roul√© du flux

1. L'utilisateur s‚Äôauthentifie sur l‚ÄôIdP (ex : via login/password ou SSO d‚Äôentreprise).
2. Depuis le portail de l‚ÄôIdP, il clique sur un lien ou un bouton pour acc√©der √† une application (SP).
3. L‚ÄôIdP g√©n√®re une `SAMLResponse` √† destination du SP :
- Cette r√©ponse est encod√©e en base64
- Elle est incluse dans un formulaire HTML `POST` pointant vers l'`AssertionConsumerService` (ACS) du SP
4. L‚ÄôIdP sert une **page HTML contenant un formulaire cach√©** (le lien m√®ne simplement vers cette page), avec `onload="document.forms[0].submit()"`.
5. Le navigateur **charge cette page** (r√©ponse `HTTP 200`), puis le formulaire est **automatiquement soumis en `POST`** vers le SP.


[source,html]
----
<html>
  <body onload="document.forms[0].submit()">
    <form action="https://sp.example.com/saml/acs" method="POST">
      <input type="hidden" name="SAMLResponse" value="MIIC...."/>
      <input type="hidden" name="RelayState" value="xyz123"/>
    </form>
  </body>
</html>
----

=== ‚ùó Points importants

* Ce **n‚Äôest pas une redirection HTTP directe vers le SP**, mais un encha√Ænement :
** Redirection 302 vers une page HTML contenant un `form`
** Ce formulaire effectue un `POST` automatiquement
* Ce flux fonctionne **sans SAMLRequest** : c‚Äôest l‚ÄôIdP qui prend l‚Äôinitiative d‚Äô√©mettre une `SAMLResponse`.

=== üìå Cas d‚Äôusage typique

* Portail interne listant toutes les applications disponibles pour un utilisateur authentifi√©
* Lien unique re√ßu par email pour acc√©der √† une application, g√©n√©r√© depuis l‚ÄôIdP

=== üìä R√©capitulatif

|===
| Binding | M√©thode HTTP | Message typique | Utilisation principale | Signature support√©e

| HTTP-Redirect | GET (URL query) | `SAMLRequest` | AuthnRequest (SP-initi√©) | Signature d‚ÄôURL (query string)
| HTTP-POST | POST (formulaire) | `SAMLResponse`, `SAMLRequest` | R√©ponse IdP ‚Üí SP (ACS) | Signature XML (XML-DSig)
| HTTP-Artifact | GET + POST SOAP | `Artifact` + `SAMLResponse` | Transmission s√©curis√©e des r√©ponses | Signature XML (dans r√©ponse r√©solue)
| SOAP | POST (XML/SOAP) | `LogoutRequest`, `AttributeQuery` | Backchannel / API | Signature XML
|===

[NOTE]
--
üéØ En pratique :

- **HTTP-Redirect** est souvent utilis√© pour initier l‚Äôauthentification.
- **HTTP-POST** est le plus courant pour la transmission des `SAMLResponse`.
- **HTTP-Artifact** est utilis√© quand la confidentialit√© prime (ex : √©changes sensibles).
- **SOAP** est r√©serv√© aux op√©rations silencieuses ou techniques (ex : d√©connexion, r√©solution d‚Äô`Artifact`).
--

== üß† NOTE ANNEXE - M√©canismes cryptographiques (signature vs chiffrement)

|===
| Objectif | Cl√© utilis√©e pour √©crire | Cl√© utilis√©e pour lire | Sens d'utilisation

| **Signature** | Cl√© **priv√©e** de l‚Äô√©metteur | Cl√© **publique** de l‚Äô√©metteur | ¬´‚ÄØJe prouve que **moi seul** ai √©crit √ßa‚ÄØ¬ª
| **Chiffrement** | Cl√© **publique** du destinataire | Cl√© **priv√©e** du destinataire | ¬´‚ÄØJe t‚Äôenvoie un message que **toi seul** peux lire‚ÄØ¬ª
|===

* Une **signature** authentifie l‚Äô√©metteur.
* Un **chiffrement** garantit la confidentialit√©.

== Annexe : S√©curit√© avanc√©e SAML

=== ‚ö† 1. Dangers critiques de RelayState

==== Risque principal : Open Redirect

Lorsque le relayState est utilis√© comme redirection cela ouvre la porte √† cette faille:

[plantuml]
----
@startuml
actor "Attaquant" as A
participant "Victime" as V
participant "SP" as SP
participant "IdP" as IdP

V -> A : "Navigue sur un site de l'attaquant"
A -> V : "Lien vers ressource SP\navec RelayState=hacker.com"
V -> SP : GET /ressource-proteg√©e
SP -> IdP : REDIRECT 302\nLocation: /sso?SAMLRequest=...&RelayState=hacker.com
IdP -> V : 200 OK + Formulaire auth
V -> IdP : POST /login (credentials)
IdP -> SP : 200 OK + HTML auto-submit\n(SAMLResponse + RelayState=hacker.com)
SP -> V : REDIRECT 302\nLocation: hacker.com?session=xxx
V -> A : GET hacker.com?session=vol√©e
@enduml
----

==== Contre-mesures obligatoires

[source,ruby]
----
# Validation du RelayState (exemple Ruby)
def valid_relay_state?(state)
  allowed_domains = [
    'https://app.mon-domaine.fr',
    'https://portail.mon-domaine.fr'
  ]
  allowed_domains.any? { |domain| state.start_with?(domain) }
end
----

==== Bonnes pratiques

* Ne jamais utiliser `RelayState` pour des URLs compl√®tes
* Stocker un identifiant de session c√¥t√© SP ‚Üí mapper √† une URL interne
* Impl√©menter une allowlist stricte de domaines
* Auditer r√©guli√®rement les redirections

=== ‚è± 2. Bonnes pratiques des timestamps

==== Param√®tres critiques
[source,xml]
----
<!-- Assertion -->
<Conditions NotBefore="2025-07-17T09:00:00Z"
           NotOnOrAfter="2025-07-17T09:05:00Z">

<!-- SubjectConfirmation -->
<SubjectConfirmationData
  NotOnOrAfter="2025-07-17T09:05:00Z"
  Recipient="https://sp.example.com/acs"/>
----

==== R√®gles de validation
[cols="1,2,2"]
|===
| Param√®tre | Tol√©rance max | V√©rification c√¥t√© SP
| `NotBefore` | 1 minute | Refuser si > heure courante + tol√©rance
| `NotOnOrAfter` | 3 minutes | Refuser si < heure courante
| `IssueInstant` | 5 minutes | Rejet si d√©passement
|===

==== Impl√©mentation recommand√©e
[source,python]
----
# Pseudocode de validation
def validate_timestamps(assertion):
    now = datetime.utcnow()
    if assertion.not_before > now + timedelta(minutes=1):
        raise InvalidAssertion("NotBefore trop dans le futur")
    if assertion.not_on_or_after < now - timedelta(minutes=3):
        raise InvalidAssertion("Assertion expir√©e")
----

=== üîè 3. Statut des signatures

==== Signature des Assertions (SAMLResponse)
[WARNING]
====
*OBLIGATOIRE* dans 99% des cas +
Seul m√©canisme fiable d'authentification de l'IdP +
Exceptions rares : environnements ferm√©s de test
====

==== Signature des Requ√™tes (SAMLRequest)
[cols="2,2"]
|===
| Contexte | Recommandation
| Binding HTTP-Redirect (GET) | **Fortement conseill√©e**
| Binding HTTP-POST | Optionnelle
| Environnements sensibles | Obligatoire
| IdP publics (Azure AD, Okta) | Souvent requise
|===

==== Checklist de s√©curit√©
* [*] Toujours valider la signature des assertions
* [*] Signer les SAMLRequest en Redirect (GET)
* [*] V√©rifier les metadata IdP/SP r√©guli√®rement
* [*] Utiliser des ID uniques par requ√™te

==== Mesures compl√©mentaires contre le rejeu
* Utiliser des identifiants uniques (`ID`) avec expiration courte (‚â§ 5 min)
* Impl√©menter un registre temporaire des requ√™tes trait√©es
* Signer syst√©matiquement les requ√™tes