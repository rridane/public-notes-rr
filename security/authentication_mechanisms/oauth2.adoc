:author-url: https://github.com/rridane
:author: rridane
:source-highlighter: rouge
:hardbreaks:
:table-caption!:
:toc: left
:toclevels: 3
:numbered:

= OAuth 2.0 – Fiche complète

== 🧩 Aperçu des différents flux OAuth 2.0

OAuth 2.0 définit plusieurs flux (*grant types*) adaptés à différents types de clients et de cas d’usage. Chaque flux détermine comment un client obtient un *access token* auprès d’un serveur d’autorisation pour accéder à une ressource protégée.

Les principaux flux sont :

* *Authorization Code* – Pour les applications côté serveur (clients confidentiels) type front php. Sécurisé, recommandé dans la majorité des cas.
* *Authorization Code + PKCE* – Variante renforcée du flux précédent pour les applications publiques (SPA, mobile), évitant l’exposition du token. Pour toutes les applications type react, angular, vue, flutter... Toutes les applications dont le code est accessible pour un attaquant.
* *Client Credentials* – Pour les communications machine-à-machine, sans intervention utilisateur.
* *Device Code* – Pour les appareils sans navigateur (TV, IoT), où l’utilisateur s’authentifie sur un autre terminal.
* *Refresh Token* – Pour obtenir de nouveaux tokens sans ré-authentification de l’utilisateur.
* *Implicit Flow* – Ancien flux désormais déconseillé, car les tokens transitent dans l’URL du navigateur. (Non abordé ici)

Chaque flux possède ses spécificités de sécurité, ses avantages, et des scénarios recommandés.

== Flux Authorization Code

Le flux Authorization Code est le plus robuste et sécurisé pour les clients confidentiels (serveur back-end). Il est également recommandé pour les clients publics (mobile, SPA) avec PKCE (Voir section suivante).

Le client n’obtient jamais directement le token via le navigateur : il passe par un code d’autorisation échangé ensuite côté serveur contre un access token.

=== Étape 1 – Requête d’autorisation & redirection vers l’Authorization Server

[plantuml]
----
@startuml
actor "Utilisateur" as User
participant "Navigateur"
participant "Client (App Web)" as Client
participant "Authorization Server (AS)" as AS

== Accès initial ==
User -> Navigateur : Accès à une ressource protégée (/photos)
Navigateur -> Client : GET /photos

Client -> Navigateur : Redirection 302 vers AS

note right of Navigateur
Redirection vers :
https://auth.example.com/authorize?
- response_type=code
- client_id=client123
- redirect_uri=https://client.com/callback
- scope=read:photos
- state=xyz123
end note

Navigateur -> AS : GET /authorize avec paramètres

note right of AS
L’AS :
- Identifie le client via client_id
- Vérifie redirect_uri
- Affiche une page de login
end note

AS -> Navigateur : Page HTML avec formulaire de login
@enduml
----

=== Étape 2 – Authentification, consentement et obtention du token

[plantuml]
----
@startuml
actor "Utilisateur" as User
participant "Navigateur"
participant "Client (App Web)" as Client
participant "Authorization Server (AS)" as AS

== Authentification ==
User -> Navigateur : Remplit login / mot de passe
Navigateur -> AS : POST /login avec credentials

AS -> AS : Vérifie les identifiants

== Consentement ==
note right of AS
Affiche une page de consentement :
- Scopes demandés
- Nom du client
- Bouton "Autoriser"
end note

User -> Navigateur : Clique sur "Autoriser"
Navigateur -> AS : POST /consent

== Génération du code ==
note right of AS
L’AS :
- Génère un code unique (ex: abc123)
- Associe code + client_id + utilisateur + scopes
- Stocke en base temporairement
end note

AS -> Navigateur : Redirection 302 vers redirect_uri

note right of Navigateur
Redirection vers :
https://client.com/callback?
- code=abc123
- state=xyz123
end note

Navigateur -> Client : GET /callback?code=abc123&state=xyz123

== Échange de code contre token ==
Client -> AS : POST /token

note right of Client
Body :
- grant_type=authorization_code
- code=abc123
- redirect_uri=https://client.com/callback
- client_id + client_secret (ou header Basic)
end note

AS -> AS : Vérifie code, expiration, client_id

AS -> Client : access_token + refresh_token (JSON)
@enduml
----

=== 🔐 Détails techniques – Échange du code contre un token

L’échange du code d’autorisation contre un access_token s’effectue côté serveur uniquement, via une requête POST du client vers l’Authorization Server.

==== 📦 Paramètres de la requête /token

[source,http]
----
POST /token HTTP/1.1
Host: auth.example.com
Content-Type: application/x-www-form-urlencoded
Authorization: Basic base64(client_id:client_secret)
grant_type=authorization_code&
code=abc123&
redirect_uri=https://client.com/callback
----

Ou, sans en-tête Authorization :
[source,x-www-form-urlencoded]
----
grant_type=authorization_code
&code=abc123
&redirect_uri=https://client.com/callback
&client_id=client123
&client_secret=secret456
----

==== 🔁 Pourquoi faut-il renvoyer redirect_uri ?

Si le redirect_uri a été fourni lors de l'étape /authorize, il doit impérativement être renvoyé à l'étape /token.

Cela permet à l’Authorization Server de valider que la redirection est identique à celle utilisée précédemment. Ce mécanisme protège contre des attaques de substitution ou de redirection malveillante.

==== 🔐 À quoi sert le client_secret ?

Le client_secret est un secret partagé connu uniquement du client et de l’Authorization Server.

    Il est attribué lors de l’enregistrement du client.
    Il permet de prouver que l’appel /token provient bien du client déclaré.

    Il ne doit jamais être exposé dans le navigateur ou des apps mobiles (voir PKCE).

Ce secret est utilisé uniquement par les clients confidentiels (ex : backend d’une webapp ou service serveur-serveur).

==== 🧾 Qu’est-ce que Authorization: Basic ?

OAuth 2.0 permet de transmettre les identifiants client de deux façons :

. En les incluant dans le body (client_id, client_secret)
. Ou via l’en-tête HTTP Authorization: Basic ... (recommandé)

Le format Basic suit la RFC 7617 :
[source,http]
----
Authorization: Basic <base64(client_id:client_secret)>

# Exemple
Authorization: Basic Y2xpZW50MTIzOnNlY3JldDEyMw==
décodé = client123:secret123
----

Cette méthode est plus propre, car :

    conforme aux standards HTTP
    permet d’éviter de logger accidentellement les secrets dans les corps de requêtes

==== ✅ Bonnes pratiques

    Ne jamais exposer le client_secret dans un environnement non sécurisé

    Toujours valider le redirect_uri strictement

    Utiliser l'en-tête Authorization: Basic si possible

    Mettre en place une politique d’expiration courte pour le code

    Activer PKCE pour les clients publics (mobile, SPA)

== Flux Authorization Code + PKCE

PKCE (Proof Key for Code Exchange) a été conçu pour **permettre l’utilisation du flux Authorization Code dans les clients publics (SPA, mobile, desktop)**, c’est-à-dire des applications qui **ne peuvent pas stocker un `client_secret` en toute sécurité**.

Dans le flux classique, un client confidentiel prouve son identité à l’étape `/token` grâce à un `client_secret`. Or, dans un client public, ce secret pourrait être compromis (ex : code accessible, reverse engineering, logs, etc.).

PKCE permet de **remplacer ce `client_secret` par une preuve éphémère**, générée dynamiquement et propre à la session d’authentification, à l’aide de deux éléments :

* `code_verifier` : une chaîne aléatoire secrète, conservée uniquement en mémoire côté client
* `code_challenge` : une empreinte dérivée du `code_verifier`, généralement `base64url(SHA256(code_verifier))`

À l’étape 1, seul le code_challenge est envoyé avec la requête /authorize.
À l’étape 2, le client présente le code_verifier pour prouver qu’il est bien à l’origine de l’étape 1.

Même si un attaquant parvient à intercepter le code (et même le code_challenge), il ne peut pas déduire le code_verifier.

Ce dernier est conservé uniquement en mémoire locale, jamais transmis tant que l’application n’est pas prête à obtenir un token.

PKCE corrige donc **la vulnérabilité principale des clients publics** utilisant le flux Authorization Code sans `client_secret`, en garantissant que seul le client initial peut finaliser l’échange.

=== Étape 1 – Requête d’autorisation avec code_challenge

[plantuml]
----
@startuml
actor "Utilisateur" as User
participant "Navigateur (App SPA/Mobile)" as App
participant "Authorization Server (AS)" as AS

== Génération côté client ==
note right of App
Avant toute redirection :
- Génère un `code_verifier` (chaîne aléatoire)
- Calcule `code_challenge = BASE64URL(SHA256(code_verifier))`
end note

User -> App : Demande une ressource protégée
App -> AS : Redirection vers /authorize

note right of App
GET /authorize?
- response_type=code
- client_id=public123
- redirect_uri=https://app.com/callback
- code_challenge=xyz987
- code_challenge_method=S256
- scope=read:photos openid
- state=abc999
end note

App -> AS : GET /authorize avec code_challenge
AS -> App : Affiche page login / mot de passe
@enduml
----

=== Étape 2 – Authentification, autorisation, et échange avec code_verifier

[plantuml]
----
@startuml
actor "Utilisateur" as User
participant "Navigateur (App SPA/Mobile)" as App
participant "Authorization Server (AS)"

== Authentification ==
User -> App : Saisie identifiants
App -> AS : POST /login (username, password)
AS -> AS : Vérifie l'identité

== Consentement ==
note right of AS
Affiche consentement :
- Scopes demandés
- Client concerné
- Bouton "Autoriser"
end note

User -> App : Autorise les accès
App -> AS : POST /consent

== Redirection avec code ==
note right of AS
L’AS :
- Génère un code unique (auth code)
- L’associe au client + code_challenge + scopes
end note

AS -> App : Redirection 302 vers redirect_uri?code=abc123&state=abc999
App -> App : Extrait le code d'autorisation

== Échange avec code_verifier ==
App -> AS : POST /token

note right of App
POST :
- grant_type=authorization_code
- code=abc123
- redirect_uri=https://app.com/callback
- code_verifier = original string générée
- client_id = public123
(end note)

AS -> AS : Vérifie code + calcule SHA256(code_verifier)

note right of AS
Vérifie que :
SHA256(code_verifier) == code_challenge reçu à l’étape /authorize
end note

AS -> App : Renvoie access_token (+ id_token, refresh_token si OIDC)
@enduml
----

== Flux Client Credentials

Le flux Client Credentials est utilisé lorsqu’une application souhaite accéder à une API en son propre nom, sans utilisateur final.
C’est le cas typique des appels machine-to-machine (M2M), des scripts backend ou des microservices.
Ce flux n’implique aucune redirection, ni interaction utilisateur. La sécurité repose essentiellement sur le fait que le client_secret est considéré en sécurité sur le serveur. Le couple client_id client_secret peut être fourni en paramètre, ou comme lors des flux précédents via le header Authorization ce qui est plus propre.

=== 🔐 Cas d’usage typiques

    Un microservice qui appelle une API centrale

    Un script batch qui consulte un backend

    Une application CLI qui accède à  des métriques, logs, jobs, etc.

    Un service qui veut authentifier sa propre identité pour effectuer des actions automatisées

=== 🧭 Vue d’ensemble du flux

[plantuml]
----
@startuml
participant "Client (Backend Service)" as Client
participant "Authorization Server (AS)" as AS
participant "Resource Server (API)" as API

== Authentification ==
Client -> AS : POST /token

note right of Client
Body :
grant_type=client_credentials
client_id=backend-app
client_secret=s3cr3t
scope=read:logs (optionnel)
end note

AS -> AS : Vérifie client_id + client_secret
AS -> Client : access_token (JSON)

== Appel API ==
Client -> API : GET /resource
note right of Client
Authorization: Bearer <access_token>
end note

API -> Client : Données autorisées
@enduml
----

=== 📦 Requête /token

[source,http]
----
POST /token HTTP/1.1
Host: auth.example.com
Content-Type: application/x-www-form-urlencoded
Authorization: Basic base64(client_id:client_secret)
grant_type=client_credentials
&scope=read:logs

Ou sans en-tête Authorization, dans le corps :
[source,x-www-form-urlencoded]
grant_type=client_credentials
&client_id=backend-app
&client_secret=s3cr3t
&scope=read:logs
----

=== 🔐 Détails techniques

|====
| Élément	| Obligatoire | 	Description
| grant_type	| ✅	 | Toujours client_credentials
| client_id	| ✅	 | Identifiant du client (application)
| client_secret| 	✅	 | Secret partagé enregistré avec le client
| scope	| ❌	 | Optionnel, permissions souhaitées (peut être fixée côté AS)
|====

=== 🔁 Réponse
[source,json]
----
{
"access_token": "eyJhbGciOiJIUzI1NiIsInR...",
"token_type": "Bearer",
"expires_in": 3600,
"scope": "read:logs"
}
----

Le token est généralement un JWT signé, ou un token opaque, selon l’implémentation.

=== ✅ Bonnes pratiques

    Toujours utiliser TLS (HTTPS) entre tous les acteurs

    Appliquer un scope minimal pour chaque client

    Faire expirer les tokens rapidement (expires_in court)

    Utiliser des client_id/secret rotatables

    Auditer les tokens utilisés : fréquence, étendue, logs

    Appliquer le principe du least privilege




== Flux Device Code

Le flux *Device Authorization Grant* (ou *Device Code*) est conçu pour les appareils **dépourvus de navigateur** ou avec **interface utilisateur limitée** (TV, consoles, imprimantes, IoT).
Il délègue l’authentification à un second appareil disposant d’un navigateur.

=== 🔐 Cas d’usage typiques

* Une TV qui affiche un code et demande à l’utilisateur de se rendre sur `example.com/activate`
* Une console de jeu ou imprimante connectée
* Un appareil IoT qui doit accéder à une API avec autorisation utilisateur

=== 🧭 Vue d’ensemble du flux

[plantuml]
----
@startuml
actor "Utilisateur" as User
participant "Device (Appareil)" as Device
participant "Authorization Server (AS)" as AS
participant "Navigateur (sur autre appareil)" as Browser
participant "Resource Server (API)" as API

== 1. Demande de code ==
Device -> AS : POST /device_authorization
note right of Device
Paramètres :
- client_id
- scope
end note

AS -> Device : device_code + user_code + verification_uri
note right of AS
Réponse :
- device_code
- user_code
- verification_uri
- verification_uri_complete
- expires_in
- interval
end note

== 2. L'utilisateur autorise ==
Device -> User : Affiche user_code + URL
User -> Browser : Va sur verification_uri
User -> AS : S’authentifie et saisit le user_code
AS -> User : Demande consentement
User -> AS : Autorise l’accès

== 3. Polling token ==
loop polling
Device -> AS : POST /token
note right of Device
Paramètres :
- grant_type=device_code
- device_code
- client_id
end note

AS -> Device : pending / slow_down / access_token
end loop

== 4. Accès API ==
Device -> API : Authorization: Bearer <access_token>
API -> Device : Données autorisées
@enduml
----

=== 🧪 Détail des étapes

==== Étape 1 – L’appareil demande un code

[source,http]
----
POST /device_authorization
Host: auth.example.com
Content-Type: application/x-www-form-urlencoded

client_id=client123&
scope=read:profile
----

Réponse :

[source,json]
----
{
  "device_code": "abc123xyz",
  "user_code": "XY12-ZZ45",
  "verification_uri": "https://auth.example.com/activate",
  "verification_uri_complete": "https://auth.example.com/activate?user_code=XY12-ZZ45",
  "expires_in": 1800,
  "interval": 5
}
----

==== Étape 2 – L’utilisateur autorise l’accès

L’appareil affiche :
----
Pour continuer, rendez-vous sur : https://auth.example.com/activate
Code : XY12-ZZ45
----


L’utilisateur :

. Ouvre son navigateur sur un autre appareil
. Va sur la `verification_uri`
. S’authentifie (login/mot de passe)
. Saisit le `user_code`
. Accepte les scopes demandés

==== Étape 3 – Le device interroge régulièrement le serveur

[source,http]
----
POST /token
Host: auth.example.com
Content-Type: application/x-www-form-urlencoded

grant_type=urn:ietf:params:oauth:grant-type:device_code&
device_code=abc123xyz&
client_id=client123
----

Réponses possibles :

* `authorization_pending` → l’utilisateur n’a pas encore validé
* `slow_down` → trop de requêtes
* `access_token` → succès

Exemple :

[source,json]
----
{
  "access_token": "eyJhbGciOi...",
  "token_type": "Bearer",
  "expires_in": 3600,
  "scope": "read:profile"
}
----

==== Étape 4 – Utilisation du token

[source,http]
----
GET /me HTTP/1.1
Host: api.example.com
Authorization: Bearer eyJhbGciOi...
----

=== ✅ Résumé des champs

[cols="1,3",options="header"]
|===
| Élément | Description

| client_id | Identifiant de l’appareil ou de l’application
| device_code | Jeton secret côté appareil, utilisé pour le polling
| user_code | Code affiché à l’utilisateur
| verification_uri | URL à visiter pour autoriser l’accès
| access_token | Jeton d’accès final une fois l’autorisation donnée
| interval | Temps (en secondes) à attendre entre deux requêtes de polling
|===

=== 🔐 Sécurité et bonnes pratiques

* Aucun `client_secret` n’est requis
* Le `device_code` expire rapidement (ex : 10-15 min)
* Le polling doit respecter l’`interval` pour éviter un rejet
* L’access_token ne doit pas être stocké durablement sur l’appareil
* L’utilisateur peut annuler ou révoquer l’autorisation



== Flux Refresh Token

Le flux *Refresh Token* permet à un client d’obtenir un nouveau `access_token` **sans interaction utilisateur**, une fois que le token d’origine a expiré.

Ce mécanisme permet :

* d’éviter de redemander une authentification trop fréquente,
* de maintenir des sessions utilisateur actives sur le long terme,
* de ne pas exposer directement les credentials à chaque requête.

Le `refresh_token` est obtenu à l’issue d’un flux principal (généralement Authorization Code ou Device Code) si ce dernier l’autorise.

=== 🔐 Cas d’usage typiques

* Une SPA ou application mobile qui souhaite maintenir une session utilisateur
* Un client confidentiel qui veut renouveler silencieusement ses accès à des API
* Une application web qui renouvelle le `access_token` en arrière-plan

=== 🧭 Vue d’ensemble du flux

.refresh_token avec client sûr
[plantuml]
----
@startuml
actor "Utilisateur" as User
participant "Client (App)" as Client
participant "Authorization Server (AS)" as AS
participant "Resource Server (API)" as API

== 1. Flux initial ==
User -> Client : Authentification initiale (ex: code)
Client -> AS : POST /token
AS -> Client : access_token + refresh_token

== 2. Appel API ==
Client -> API : Authorization: Bearer access_token
API -> Client : Données

== 3. Le token expire ==
note right of Client
access_token expiré (ex: 3600s)
end note

== 4. Rafraîchissement ==
Client -> AS : POST /token
note right of Client
Paramètres :
- grant_type=refresh_token
- refresh_token
- client_id (+ client_secret si confidentiel)
end note

AS -> Client : Nouveau access_token (+ refresh_token si rotation)
@enduml
----

.client publique non sûr (pkce)

[plantuml]
----
@startuml
actor "Utilisateur" as User
participant "Client (SPA – public)" as Client
participant "Authorization Server (AS)" as AS
participant "Resource Server (API)" as API

== 1. Flux initial ==
User -> Client : Authentification initiale (avec PKCE)
Client -> AS : POST /token (code + code_verifier)
AS -> Client : access_token + refresh_token

== 2. Appel API ==
Client -> API : Authorization: Bearer access_token
API -> Client : Données

== 3. Le token expire ==
note right of Client
access_token expiré (ex: 3600s)
end note

== 4. Rafraîchissement ==
Client -> AS : POST /token

note right of Client
Paramètres :
- grant_type=refresh_token
- refresh_token
- client_id
(N.B. : PAS de client_secret)
end note

AS -> Client : Nouveau access_token (+ refresh_token si rotation)
@enduml
----

=== 📦 Requête /token pour le rafraîchissement

[source,http]
----
POST /token HTTP/1.1
Host: auth.example.com
Content-Type: application/x-www-form-urlencoded
Authorization: Basic base64(client_id:client_secret)

grant_type=refresh_token
&refresh_token=def456uvw
----

Ou dans le corps :

[source,x-www-form-urlencoded]
----
grant_type=refresh_token
&client_id=client123
&client_secret=s3cr3t # Si applicable
&refresh_token=def456uvw
----

=== 🔁 Réponse typique

[source,json]
----
{
  "access_token": "eyJhbGciOi...",
  "token_type": "Bearer",
  "expires_in": 3600,
  "scope": "read:profile",
  "refresh_token": "ghi789rst" // optionnel, si rotation activée
}
----

=== 🔄 Refresh Token Rotation

Certains serveurs OAuth (ex: Auth0, Keycloak, Google) activent par défaut une stratégie de **rotation de refresh_token** :

* À chaque appel réussi de `/token`, un nouveau `refresh_token` est fourni
* L’ancien est invalidé
* Empêche le vol ou la réutilisation frauduleuse

Cette rotation permet une meilleure détection d’usage simultané ou de fuite du refresh token.

=== ⚠️ Erreurs fréquentes

[source,json]
----
{
  "error": "invalid_grant",
  "error_description": "Refresh token expired or revoked"
}
----

Autres erreurs possibles :

* `invalid_client` → mauvais client_id/secret
* `invalid_scope` → scope non autorisé
* `unauthorized_client` → ce client n’est pas autorisé à rafraîchir

=== ✅ Bonnes pratiques

* Ne jamais exposer un `refresh_token` dans un navigateur (localStorage, JS)
* Activer la rotation de refresh_token quand possible
* Coupler chaque refresh_token à un seul appareil/session
* Révoquer les refresh_token en cas de logout
* Ne pas donner de durée de vie infinie (ex: 30j max, puis re-auth obligatoire)
* Protéger l’endpoint `/token` contre les brute force

=== 🔐 Où sont stockés les refresh_token ?

[cols="1,3",options="header"]
|===
| Type de client | Recommandation

| Application mobile | Stockage sécurisé (Keychain, Android Keystore)
| WebApp SPA (JS)    | ⚠️ À éviter (ne pas exposer de refresh_token côté client)
| Client confidentiel (backend) | Base de données sécurisée
|===

=== 🔍 À noter

* Le `refresh_token` n’est **jamais envoyé** à une API métier.
* Il n’est utilisé **que** pour obtenir un nouveau `access_token` depuis l’AS.
* Il peut être accompagné ou non d’un nouveau `refresh_token` (rotation ou non).

== ❓ Où est l’IdP dans OAuth 2.0 ?

Il n’y en a pas, car OAuth 2.0 est un protocole d’autorisation, pas d’authentification.

    L’Authorization Server peut faire office d’IdP implicitement,
    Mais OAuth ne fournit pas de garantie sur l’identité de l’utilisateur.

C’est pour cela qu’est né OpenID Connect (OIDC), une surcouche d’authentification sur OAuth 2.0.

=== 🔓 OpenID Connect (Voir fiche associée pour plus de détail)

OpenID Connect introduit la notion d’Identity Provider (IdP) en ajoutant :

    un id_token (JWT signé contenant l’identité de l’utilisateur),

    des endpoints supplémentaires (/.well-known/openid-configuration, /userinfo),

    un scope openid obligatoire.

.OAuth vs OIDC
|===
| Protocole | Token principal | Concerne | Fournit l'identité ? | Présence d’un IdP

| OAuth 2.0 | access_token | Accès à des API | ❌ Non | ❌ Non
| OIDC | id_token + access_token | Authentification + autorisation | ✅ Oui | ✅ Oui
|===

Pour faire simple :

    OAuth → "Puis-je accéder à cette ressource au nom de l’utilisateur ?"

    OIDC → "Qui est cet utilisateur, et puis-je lui faire confiance ?"

== 🔐 Gestion de l’URL cible et du state

Lorsque l’utilisateur tente d’accéder à une ressource protégée (ex : `/photos/1234`), il est redirigé vers le serveur d’autorisation pour authentification. Une fois le flux OAuth terminé, l’application doit rediriger l’utilisateur vers **la ressource initialement demandée**.

Comme le protocole OAuth 2.0 ne fournit pas de mécanisme standard pour transporter cette information (contrairement à SAML avec `RelayState`), c’est au client d’assurer ce lien.

=== 🧭 Mécanismes possibles

1. **Stockage côté serveur** :
Le client génère un identifiant `state` (aléatoire, sécurisé) et associe l’URL initiale à ce `state` dans une session côté serveur (ex : en mémoire ou via Redis).

2. **Encodage direct dans le `state`** :
L’URL cible est encodée directement dans la valeur du `state`, souvent séparée par un délimiteur :

----
state=csrf123___/photos/1234
----

e format permet d’associer protection CSRF et redirection.

=== 🔄 Exemple en Ruby

[source,ruby]
----
state_id = SecureRandom.hex(16)
session[state_id] = {
original_url: "/photos/1234",
created_at: Time.now
}
redirect_to "https://auth.example.com/authorize?state=#{state_id}"
----

=== 📥 Récupération à la fin du flux

Une fois l’utilisateur redirigé vers le client avec `?code=abc123&state=csrf123___/photos/1234`, le client :

. vérifie la partie anti-CSRF (`csrf123`)
. récupère ou décode l’URL d’origine (`/photos/1234`)
. effectue la redirection finale vers la ressource cible

=== ✅ Bonnes pratiques

* Toujours signer et vérifier le paramètre `state` pour prévenir les attaques CSRF.
* Limiter la durée de vie des entrées `state` en session.
* Ne jamais faire confiance à une URL transmise directement par l’utilisateur (ex : paramètre `redirect=` non vérifié).
* Valider systématiquement que l’URL de redirection est interne à l’application.


== 🚨 Vulnérabilités connues (et contre-mesures)

[cols="2,4"]
|===
|Problème |Mitigation

|Interception du code | Toujours échanger le code côté serveur
|CSRF / attaque de session | Utiliser un state robuste et signé
|Redirection externe | Ne jamais autoriser d’URI dynamique, uniquement des valeurs whitelistées
|Token volé | Limiter la durée (expires_in) + rotation des tokens
|===

== Configurations avancées

=== 🔐 JAR – JWT Authorization Request

Le mécanisme *JAR* (JWT Authorization Request) permet d’envoyer une requête `/authorize` encapsulée dans un JWT signé, au lieu de passer tous les paramètres dans l’URL.

[source,http]
----
GET /authorize?request=eyJhbGciOiJSUzI1NiIsImtpZCI6ImtleS0xIn0... (JWT signé)
----

Ce JWT contient tous les paramètres OAuth habituels, comme :
- `client_id`
- `redirect_uri`
- `response_type`
- `scope`
- `state`
- `exp`, `aud`, `iss` (normes JWT)

La signature garantit :
- l’**intégrité** des paramètres (aucune modification possible),
- l’**authenticité** du client,
- la **protection contre les attaques par injection de paramètres** (`redirect_uri`, `scope`, etc.).

==== 📎 Pourquoi utiliser JAR ?

* Les URL `/authorize?...` sont visibles dans le navigateur, interceptables dans des logs, modifiables côté client.
* Avec JAR, toute la requête est encapsulée et signée avec une **clé privée**, que seul le client possède.
* Le serveur d’autorisation valide la signature et **rejette** toute requête falsifiée.

==== 🧾 Exemple de JWT pour request=

Un JWT typique dans JAR pourrait contenir ceci :

.En-tête (header)
[source,json]
----
{
  "alg": "RS256",
  "typ": "JWT",
  "kid": "client-key-1"
}
----

.Payload (claims)
[source,json]
----
{
  "response_type": "code",
  "client_id": "client123",
  "redirect_uri": "https://client.example.com/callback",
  "scope": "openid profile",
  "state": "abcXYZ123",
  "nonce": "n-0S6_WzA2Mj",
  "aud": "https://auth.example.com",
  "iss": "client123",
  "exp": 1710000000
}
----

.Signature
Signée avec la clé privée du client, référencée par `kid`.

Ce JWT est ensuite passé en paramètre :
[source,http]
----
GET /authorize?request=eyJhbGciOi...
----

==== 🔑 Comment l’Authorization Server vérifie la signature ?

Le client doit avoir **déclaré sa clé publique** au préalable. Deux options :

===== 📍 1. Via un `jwks_uri` (JSON Web Key Set URI)

Le client fournit une URL lors de son enregistrement (statique ou dynamique) :

[source,json]
----
{
  "client_id": "client123",
  "jwks_uri": "https://client.example.com/jwks.json"
}
----

Exemple de `jwks.json` publié par le client :

[source,json]
----
{
  "keys": [
    {
      "kty": "RSA",
      "kid": "client-key-1",
      "use": "sig",
      "alg": "RS256",
      "n": "MIIBIjANBgkqhk...",  // clé publique modulaire (base64url)
      "e": "AQAB"
    }
  ]
}
----

===== 📍 2. Ou via `jwks` inline à l’enregistrement

[source,json]
----
{
  "client_id": "client123",
  "jwks": {
    "keys": [ ... ] // même format que ci-dessus
  }
}
----

==== ✅ Bonnes pratiques

* Toujours signer le JWT avec une clé forte (RS256 ou ES256)
* Ne jamais exposer la clé privée dans le navigateur ou mobile
* Lier l’en-tête `kid` à un JWKS public bien exposé
* Utiliser un `exp` court dans le JWT (ex: 5 min)
* Rejeter toute requête `/authorize` non signée en contexte FAPI

==== 📎 Spécifications associées

- RFC 9101 – OAuth 2.0 JWT-Secured Authorization Request (JAR)
- https://openid.net/specs/openid-financial-api-part-2.html (FAPI Advanced Security Profile)

=== 📦 JARM – JWT Secured Authorization Response Mode

JARM (*JWT Secured Authorization Response Mode*) permet à l’Authorization Server de **renvoyer la réponse `/authorize` encapsulée dans un JWT signé**, au lieu de transmettre les paramètres (`code`, `state`, etc.) directement dans l’URL.

Cela renforce la sécurité en assurant :
- l’**intégrité** des données renvoyées,
- l’**authenticité** de l’Authorization Server,
- la **non-altération** du `code`, du `state`, etc.,
- une compatibilité avec la **non-répudiation**.

==== 🧭 Exemple de flux avec JARM

[source,http]
----
GET /authorize?response_mode=jwt
----

Au lieu d’un retour classique :
[source,http]
----
302 Found
Location: https://client.com/callback?code=abc123&state=xyz456
----

L’AS renvoie :
[source,http]
----
302 Found
Location: https://client.com/callback?response=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...
----

Le client doit ensuite :
. décoder le JWT contenu dans `response=`
. valider la signature avec la **clé publique de l’AS**
. extraire les champs comme `code`, `state`, etc.

==== 🔐 Exemple de JWT `response=...`

.En-tête
[source,json]
----
{
  "alg": "RS256",
  "kid": "as-key-1",
  "typ": "JWT"
}
----

.Payload
[source,json]
----
{
  "iss": "https://auth.example.com",
  "aud": "client123",
  "exp": 1710000000,
  "iat": 1709999400,
  "code": "abc123",
  "state": "xyz456",
  "redirect_uri": "https://client.com/callback"
}
----

.Signature
Signée par l’Authorization Server avec sa clé privée.

==== 🔑 Vérification côté client

Le client doit :
. Vérifier la signature avec la clé publique de l’AS (`jwks_uri` de l’AS)
. Vérifier les claims `iss`, `aud`, `exp`
. Extraire le `code` et le `state` du payload

==== 📎 Où trouver la clé publique de l’AS ?

Comme pour tous les JWT OIDC, l’AS expose sa clé via son fichier de configuration OIDC :

[source,http]
----
GET /.well-known/openid-configuration
----

Extrait typique :
[source,json]
----
{
  "issuer": "https://auth.example.com",
  "jwks_uri": "https://auth.example.com/.well-known/jwks.json"
}
----

Le client récupère les clés :
[source,json]
----
{
  "keys": [
    {
      "kty": "RSA",
      "kid": "as-key-1",
      "alg": "RS256",
      "use": "sig",
      "n": "...",
      "e": "AQAB"
    }
  ]
}
----

==== 📌 Comparaison classique vs JARM

| Élément transmis | Mode classique | Avec JARM |
|------------------|----------------|-----------|
| `code`           | Dans l’URL     | Dans le JWT |
| `state`          | Dans l’URL     | Dans le JWT |
| Signature        | ❌ Non         | ✅ Oui |
| Protection       | ❌ Aucune      | ✅ Signature cryptographique |
| Rejeu ou injection | Possible     | Impossible si bien vérifié |

==== ✅ Bonnes pratiques

* Activer `response_mode=jwt` pour tous les flux sensibles (FAPI)
* Toujours vérifier la signature du JWT (`RS256` ou `ES256`)
* Vérifier `aud`, `iss`, `exp`, `iat`
* Ne jamais traiter un JWT `response=` sans validation stricte

==== 📚 Spécifications associées

* https://openid.net/specs/oauth-v2-jarm.html – OAuth 2.0 JWT-Secured Authorization Response Mode (JARM)
* Utilisé et requis dans le profil `FAPI Advanced Security Profile`

=== 🔐 DPoP – Demonstration of Proof-of-Possession

DPoP (*Demonstration of Proof-of-Possession*) est une extension OAuth 2.0 visant à **protéger les access tokens contre le vol et le rejeu**.

Un token de type `Bearer` peut être volé et réutilisé n’importe où. DPoP introduit une **preuve cryptographique de possession de la clé privée liée au token**, à chaque requête.

Il s’agit d’une solution **légère**, sans certificat (contrairement à MTLS), basée sur la signature d’un JWT transmis dans l’en-tête `DPoP`.

==== Vulgarisation du fonctionnement

Dans chaque access_token on trouve une clé publique, il s'agit tout simplement de celle fournie par le client, lors de la demande de token. Le client peut mettre la clé publique de son choix. La seule condition est que si il utilise cet access_token il doit prouver qu'il détient la clé privée associée. Cela se fait via le champ DPoP, qui contient un jwt signé par la clé privée associée à la clé publique.

Autrement dit, l'utilisateur du token doit prouver qu'il détient la clé privée associée à la clé publique.

==== 🔐 Objectif

Empêcher qu’un `access_token` volé soit utilisable ailleurs.

Avec DPoP :
- Le `access_token` est lié à une **clé publique** (incluse dans `cnf.jwk`)
- Chaque requête API doit inclure une **preuve de possession** : un JWT signé avec la **clé privée**
- Le serveur vérifie que la **clé publique** utilisée pour signer correspond à celle déclarée dans le token

==== 🧭 Vue d’ensemble du fonctionnement


. Le client génère localement une **paire de clés** asymétriques (ex: EC P-256)
. Lors de l’appel `/token`, il envoie un JWT signé dans l’en-tête HTTP `DPoP`, qui contient :
- la **clé publique** dans le champ `jwk` de l’en-tête du JWT
- la méthode HTTP (`htm`)
- l’URL cible (`htu`)
- un `jti` unique
- un timestamp `iat`
- et est **signé avec la clé privée correspondant à la clé publique fournie**
. L’Authorization Server :
- extrait la **clé publique (`jwk`) de l’en-tête du JWT**
- vérifie que la signature est correcte avec cette clé
- **l’inclut dans l’`access_token`** via le champ `cnf.jwk`

. Lors des appels aux APIs, le client :
  - signe chaque requête avec un nouveau JWT DPoP
  - fournit le même `access_token`, précédé du mot-clé `DPoP`
. Le serveur de ressources :
  - vérifie que le JWT est signé avec la même clé publique que celle liée au token
  - rejette les appels dont la clé ne correspond pas ou dont le `jti` a déjà été vu (anti-rejeu)

==== 📦 Appel `/token` avec DPoP

Exemple :

[source,http]
----
POST /token
Host: auth.example.com
Authorization: Basic base64(client_id:client_secret)
Content-Type: application/x-www-form-urlencoded
DPoP: eyJhbGciOiJFUzI1NiIsInR5cCI6ImRwb3Arand0Iiwian... (JWT signé)

grant_type=authorization_code
&code=abc123
&redirect_uri=https://client.com/callback
----

L’en-tête `DPoP` est un JWT signé avec la **clé privée** du client.

==== 📄 Contenu du JWT DPoP (appel `/token`)

.Header :
[source,json]
----
{
  "typ": "dpop+jwt",
  "alg": "ES256",
  "jwk": {
    "kty": "EC",
    "crv": "P-256",
    "x": "f83OJ3D2xF4U2hK2Y7KiGH2V",
    "y": "x_FEzRu9bktM6uZ7RzvJ2HiV"
  }
}
----

.Payload :
[source,json]
----
{
  "htu": "https://auth.example.com/token",
  "htm": "POST",
  "iat": 1723212345,
  "jti": "550e8400-e29b-41d4-a716-446655440000"
}
----

.Signature :
- Faite avec la **clé privée associée au `jwk` ci-dessus**
- Le `jti` est un ID **unique généré par le client**, utilisé pour l’anti-rejeu
- Le `iat` est un timestamp Unix (en secondes)
- Le `htm` (HTTP Method) et `htu` (Target URI) lient la preuve à la requête

==== 🎟️ Réponse `/token` avec `access_token` lié à la clé publique

L’Authorization Server inclut la **clé publique du client** dans le `access_token`, sous le champ `cnf.jwk`.

Exemple de payload JWT :

[source,json]
----
{
  "sub": "user123",
  "iss": "https://auth.example.com",
  "aud": "https://api.example.com",
  "scope": "read:profile",
  "exp": 1723216000,
  "cnf": {
    "jwk": {
      "kty": "EC",
      "crv": "P-256",
      "x": "f83OJ3D2xF4U2hK2Y7KiGH2V",
      "y": "x_FEzRu9bktM6uZ7RzvJ2HiV"
    }
  }
}
----

Ce champ `cnf.jwk` signifie :
→ *"Ce token n’est valide que s’il est présenté avec une preuve de possession de cette clé publique."*

==== 📡 Appel à une API protégée avec DPoP

Exemple :

[source,http]
----
GET /me HTTP/1.1
Host: api.example.com
Authorization: DPoP eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
DPoP: eyJhbGciOiJFUzI1NiIsInR5cCI6ImRwb3Arand0Iiwian... (JWT signé)
----

* Le champ `Authorization` contient le `access_token`, précédé du mot-clé `DPoP` (et non `Bearer`)
* Le champ `DPoP` contient un **nouveau JWT signé**, généré pour cette requête spécifique

==== 📄 Contenu du JWT DPoP (appel API)

.Header :
[source,json]
----
{
  "typ": "dpop+jwt",
  "alg": "ES256",
  "jwk": { ... même que précédemment ... }
}
----

.Payload :
[source,json]
----
{
  "htu": "https://api.example.com/me",
  "htm": "GET",
  "iat": 1723212450,
  "jti": "7ca3c4a1-b1f3-43a6-9f4f-f9ea38cfcd99"
}
----

==== ✅ Vérification côté API

L’API doit vérifier :

* que le JWT DPoP est bien formé et non expiré
* que le `jwk` dans le header correspond au `cnf.jwk` du token
* que la signature est valide (avec la clé publique)
* que le `htm` et `htu` correspondent à la requête réelle
* que le `jti` n’a jamais été vu (anti-rejeu)

==== 🔒 Résumé vs Bearer / MTLS

|====
| Élément                     | Bearer Token          | DPoP                          | MTLS (Mutual TLS)
| Clé publique liée au token  | ❌ Non                | ✅ Oui (`cnf.jwk`)            | ✅ Oui (certificat TLS)
| Signature de la requête     | ❌ Aucune             | ✅ JWT signé (`DPoP`)         | ✅ Implicite via TLS
| Rejeu du token possible     | ✅ Oui                | ❌ Non (preuve requise)       | ❌ Non
| Complexité déploiement      | ✅ Simple             | ⚠️ Moyenne (gestion clé)      | ❌ Élevée (certificats)
| Usage sur mobile/JS         | ✅ Facile             | ✅ Facile                     | ❌ Difficile
|====

==== ✅ Bonnes pratiques DPoP

* Générer une paire de clés solide (EC P-256 ou RSA 2048)
* Ne jamais exposer la **clé privée**
* Générer un `jti` unique par requête (UUID v4 recommandé)
* Définir un `iat` raisonnablement court (0–5 min de tolérance)
* Côté API, stocker en mémoire les derniers `jti` pour éviter les rejets
* Utiliser HTTPS systématiquement pour tous les échanges
* Refuser les tokens `Bearer` sur les endpoints sensibles

==== 📚 Spécifications associées

* https://datatracker.ietf.org/doc/html/draft-ietf-oauth-dpop
* https://oauth.net/2/dpop/

=== 🔐 MTLS – Mutual TLS (certificat client + access_token lié)

Mutual TLS (*mTLS*) est un **protocole réseau standard**, utilisé pour établir une connexion HTTPS où **le client présente également un certificat X.509**, en plus de celui du serveur.

OAuth 2.0 **réutilise** ce mécanisme TLS pour deux objectifs spécifiques :

. Authentifier le client OAuth via son certificat lors de l’appel `/token`
. Lier l’`access_token` au certificat, pour qu’il **ne puisse être utilisé que par le même client**

Ce mécanisme est défini dans la RFC officielle :
https://tools.ietf.org/html/rfc8705

==== 📎 mTLS : protocole standard au niveau TLS

mTLS est une **fonctionnalité native de TLS**, utilisée dans de nombreux contextes (VPN, bases de données, SI industriels, etc.) :

. Le serveur envoie son certificat TLS
. Il demande un **certificat client** (`CertificateRequest`)
. Le client envoie un **certificat X.509**, signé par une CA
. La session TLS est établie uniquement si le certificat client est **valide et approuvé**

Ce processus est purement réseau, et se produit **avant même l’échange de données HTTP**.

==== 🧭 Dans OAuth 2.0 : une couche d’authentification et de liaison

OAuth 2.0 **détourne mTLS** pour deux usages bien précis :

1. 🔐 **Authentification du client OAuth**
- Le client **présente son certificat** lors du handshake TLS vers `/token`
- Le serveur OAuth (AS) utilise ce certificat pour **identifier et authentifier le `client_id`**

- Deux modes sont possibles :

a. `tls_client_auth` : certificat signé par une CA connue, c'est le full handshake qui valide le certificat
b. `self_signed_tls_client_auth` : certificat auto-signé, mais dont la **clé publique est pré-enregistrée**, c'est l'étape /token qui valide le certificat en comparant la clé publique fournie avec celles enregistrées

2. 🔗 **Liaison de l’`access_token` à ce certificat**
- L’AS extrait l’empreinte SHA-256 du certificat présenté
- Il l’intègre dans le `access_token` (JWT) dans le champ `cnf.x5t#S256`
- Ainsi, **le token ne pourra être utilisé que via mTLS avec ce même certificat**

.tls_client_auth
[plantuml]
----
@startuml
actor "Client OAuth" as Client
participant "Auth Server" as AS
participant "TLS Layer" as TLS

== Connexion TLS mutualisée ==

Client -> TLS : ClientHello (propose mTLS)
TLS -> Client : CertificateRequest
Client -> TLS : Certificat X.509 signé (par CA)
note right of Client
Le client signe un challenge TLS
avec sa clé privée
end note
note right of TLS
Vérifie :
* Validité du CA
* Possession de la clé privée via challenge
end note
TLS -> AS : TLS OK, connexion établie

== Appel /token ==

Client -> AS : POST /token\n(client_id, grant_type, scope)
note right of AS
Compare le certificat reçu avec
celui attendu pour client_id
end note
AS -> AS : Calcule x5t#S256 du certificat
AS -> Client : access_token JWT\n(avec cnf.x5t#S256)
@enduml
----

.self_signed_tls_client_auth
[plantuml]
----
@startuml
actor "Client OAuth" as Client
participant "Auth Server" as AS
participant "TLS Layer" as TLS

== Connexion TLS mutualisée ==

Client -> TLS : ClientHello (propose mTLS)
TLS -> Client : CertificateRequest
Client -> TLS : Certificat X.509 auto-signé
note right of Client
Le client signe un challenge TLS
avec sa clé privée
end note
note right of TLS
Vérifie :
* Possession de la clé privée via challenge
⚠️ Pas de vérification de l’émetteur (auto-signé)
end note
TLS -> AS : TLS OK, connexion établie

== Appel /token ==

Client -> AS : POST /token\n(client_id, grant_type, scope)
note right of AS
Compare la **clé publique** du certificat TLS
avec celle enregistrée pour ce `client_id`
end note
AS -> AS : Calcule x5t#S256 du certificat
AS -> Client : access_token JWT\n(avec cnf.x5t#S256)
@enduml
----

.Récupération du token (identique au deux flux)
[plantuml]
----
@startuml
actor "Client OAuth" as Client
participant "API Server" as API
participant "TLS Layer" as TLS

== Connexion mTLS ==

Client -> TLS : ClientHello (mTLS)
TLS -> Client : CertificateRequest
Client -> TLS : Certificat X.509 (même que /token)
note right of Client
Le client signe un challenge TLS
avec sa clé privée
end note
note right of TLS
Vérifie :
* Validité du CA
* Possession de la clé privée via challenge
end note
TLS -> API : TLS OK, session établie

== Appel API ==

Client -> API : GET /data\nAuthorization: Bearer eyJ...
API -> API : Extrait le certificat de TLS
API -> API : Calcule x5t#S256
API -> API : Compare avec cnf.x5t du token

alt Correspondance OK
  API -> Client : ✅ Donne la ressource
else Mauvaise clé ou token volé
  API -> Client : ❌ 401 Unauthorized
end
@enduml
----


==== 🔄 Flux `/token` avec mTLS

[source,http]
----
POST /token
Host: auth.example.com
Content-Type: application/x-www-form-urlencoded

grant_type=client_credentials
&client_id=backend-app
&scope=read:data
----

✔️ Il n’y a **pas de `client_secret`**
✔️ Le client présente son **certificat X.509** lors du **handshake TLS**
✔️ Dans tous les cas le serveur vérifie à l'aide du challenge la possession de la clé privée
✔️ Dans le cas tls_signed_auth, l'autorité de certification valide la légitimité du certificat, ce qui suffit à l'obtention du token
✔️ Dans le self_signed_tls_client_auth, le handshake tls ne vérifie pas la légitimité du certificat, la clé privée suffit à valider le handshake. L'AS extrait immédiatement après la clé publique du certificat et la compare avec les clés publiques connues et autorisées, si il y a match, le certificat est considéré comme légitime.
✔️ L’AS génère l'emprunte du certificat et délivre un token lié (avec le bon champ cnt.x5t contenant le hash signé du certificat)

==== 🧾 Exemple d’`access_token` JWT émis

[source,json]
----
{
  "sub": "backend-app",
  "aud": "https://api.example.com",
  "exp": 1723216000,
  "scope": "read:data",
  "cnf": {
    "x5t#S256": "FhS7ey5eTxN0GqR5twF7K1v0Vya8lJcvZP9ZT2aPjSo"
  }
}
----

Le champ `cnf.x5t#S256` contient :
- l’empreinte SHA-256 du certificat **présenté à `/token`**
- encodée en base64url (format conforme à JWK Thumbprint)
- calculé comme ceci en accord avec la RFC 7638: thumbprint = base64url(SHA-256(canonicalized certificate))

> Ce token ne pourra être utilisé **qu’avec ce même certificat** dans les appels aux APIs.

==== 📡 Appel API avec access_token lié (via mTLS)

[source,http]
----
GET /me HTTP/1.1
Host: api.example.com
Authorization: Bearer eyJhbGciOiJSUzI1NiIs...
----

✔️ La requête est faite **en HTTPS avec mTLS**
✔️ Le **même certificat client** est présenté que lors de `/token`
✔️ Le serveur API :
- extrait ce certificat de la session TLS
- calcule son empreinte SHA-256
- la compare à `cnf.x5t#S256` dans le JWT

✅ Requête acceptée **uniquement si l’empreinte correspond**

==== 🧩 Détail : les deux modes de mTLS dans OAuth

[cols="1,3a",options="header"]
|===
|Mode |Description

|tls_client_auth
|Certificat client signé par une autorité de certification (CA) connue de l’AS.

    Le client_id est fourni dans la requête /token

    L’AS retrouve la liste de CA autorisées pour ce client

    Le certificat présenté doit être signé par une de ces CA

    Le handshake TLS valide la chaîne de confiance

    L’AS vérifie que le certificat est autorisé pour ce client_id

|self_signed_tls_client_auth
|Certificat auto-signé (pas de CA).

    Le client_id est aussi fourni dans la requête /token

    L’AS a préenregistré la clé publique exacte attendue pour ce client_id

    Lors du handshake, la TLS Layer ne vérifie pas la chaîne de confiance (mode permissif)

    L’AS extrait la clé publique du certificat présenté

    L’AS compare cette clé publique à celle enregistrée pour ce client_id
|===

==== 🧠 Remarques

- 🧾 Le champ `cnf.x5t#S256` est une **empreinte SHA-256** du certificat client
- 🔐 Le certificat **sert à la fois d’identifiant et de preuve de possession**
- ✅ Cela garantit que **seul le client qui possède la clé privée** du certificat peut utiliser le token
- ❌ Même avec le token, un autre client **ne pourra pas l’utiliser** sans ce certificat

==== 🧠 Pourquoi ne pas se contenter de mTLS “classique” ?

Parce que la validation TLS par le serveur HTTP (ex: NGINX, Envoy) ne suffit pas pour :
- garantir que **l’access_token a été émis pour ce certificat**
- **lier le token** à cette identité cryptographique

OAuth a donc défini l’inclusion explicite du `x5t#S256` dans le token, dans la claim `cnf` :
→ cela rend le token inutilisable **sans le certificat**.

==== 📎 Clarification : le mot "mTLS" est ambigu

[NOTE]
====
⚠️ Dans OAuth, le terme “mTLS” est parfois trompeur.

Il ne désigne **pas seulement** l’usage du protocole mTLS (qui est générique),
mais **un ensemble de mécanismes** spécifiques à OAuth :

- Authentification du client OAuth via certificat (au lieu d’un secret)
- Liaison du `access_token` au certificat (via `cnf.x5t#S256`)

Un nom plus explicite aurait pu être :
`mTLS + certificate-bound access tokens`
Mais par usage, on parle simplement de “OAuth mTLS”.
====

==== 🔬 Comparaison mTLS vs DPoP

| Élément                    | DPoP                          | mTLS                               |
|----------------------------|-------------------------------|------------------------------------|
| Objectif principal         | Prouver possession            | Authentifier et lier un token      |
| Preuve envoyée             | JWT signé                     | Certificat client TLS              |
| Lien token ↔ preuve        | `cnf.jwk`                     | `cnf.x5t#S256`                      |
| Certificat requis          | ❌ Non                        | ✅ Oui                             |
| CA ou validation externe   | ❌ Aucune                     | ✅ Chaîne de confiance requise     |
| Token réutilisable ailleurs| ❌ Non                        | ❌ Non                             |
| Déploiement web/mobile     | ✅ Facile                     | ❌ Difficile (certs sur mobile)    |

==== ✅ Bonnes pratiques

* Utiliser une CA interne dédiée à l’écosystème OAuth
* Refuser toute connexion sans certificat client mTLS
* Activer le **token binding** avec `cnf.x5t#S256`
* Mettre en place un mécanisme de **revocation** (CRL ou OCSP)
* Restreindre la validité des certificats (rotation)
* Configurer l’API pour extraire correctement le certificat (via NGINX ou TLS lib)

==== 📚 Spécifications associées

* https://tools.ietf.org/html/rfc8705 – OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound Access Tokens
* https://datatracker.ietf.org/doc/html/rfc7523 – JWT Bearer Token Profiles (pour lier l’identité)
* https://datatracker.ietf.org/doc/html/rfc7517 – JSON Web Key (pour `cnf` structure)

=== 🔐 FAPI – Financial-grade API (OAuth 2.0 durci)

FAPI est une *spécification de l’OpenID Foundation* visant à sécuriser les APIs sensibles (finance, santé, identité…).

Elle repose entièrement sur OAuth 2.0, mais impose une *combinaison stricte de mécanismes existants* pour renforcer l’authentification, l’intégrité, la confidentialité et la non-répudiation.

.Exigences de FAPI
[cols="1,4a",options="header"]
|===
|Élément |Rôle

|*PKCE* (RFC 7636)
|Empêche le vol du code d'autorisation

|*JAR* – JWT Authorization Request
|Signature de la requête `/authorize` (intégrité + non-répudiation)

|*JARM* – JWT Authorization Response
|Signature de la réponse à `/authorize` (intégrité + vérifiabilité)

|*mTLS* ou *DPoP*
|Preuve de possession du client + liaison des tokens (`cnf`)

|*Access Token lié au certificat ou JWK*
|Via `cnf.x5t#S256` (mTLS) ou `cnf.jwk` (DPoP)

|*HTTP Message Signing*
|Protection des appels API contre la falsification

|*Scopes strictement limités*
|Principe du moindre privilège renforcé

|*Rotation obligatoire des refresh_token*
|Réduction de l'impact en cas de vol

|*Pas de token réutilisable hors preuve*
|Les tokens liés à un certificat ou une clé privée ne peuvent pas être réutilisés ailleurs
|===

[NOTE]
====
FAPI *n’est pas un nouveau protocole*, mais un *profil de sécurité OAuth 2.0 renforcé*, souvent requis en Open Banking (Royaume-Uni, UE…).
====

📖 https://openid.net/fapi/[Spécification officielle]
