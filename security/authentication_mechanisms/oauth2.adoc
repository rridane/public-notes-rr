:author-url: https://github.com/rridane
:author: rridane
:source-highlighter: rouge
:hardbreaks:
:table-caption!:
:toc: left
:toclevels: 3
:numbered:

= OAuth 2.0 â€“ Fiche complÃ¨te

== ğŸ§© AperÃ§u des diffÃ©rents flux OAuth 2.0

OAuth 2.0 dÃ©finit plusieurs flux (*grant types*) adaptÃ©s Ã  diffÃ©rents types de clients et de cas dâ€™usage. Chaque flux dÃ©termine comment un client obtient un *access token* auprÃ¨s dâ€™un serveur dâ€™autorisation pour accÃ©der Ã  une ressource protÃ©gÃ©e.

Les principaux flux sont :

* *Authorization Code* â€“ Pour les applications cÃ´tÃ© serveur (clients confidentiels) type front php. SÃ©curisÃ©, recommandÃ© dans la majoritÃ© des cas.
* *Authorization Code + PKCE* â€“ Variante renforcÃ©e du flux prÃ©cÃ©dent pour les applications publiques (SPA, mobile), Ã©vitant lâ€™exposition du token. Pour toutes les applications type react, angular, vue, flutter... Toutes les applications dont le code est accessible pour un attaquant.
* *Client Credentials* â€“ Pour les communications machine-Ã -machine, sans intervention utilisateur.
* *Device Code* â€“ Pour les appareils sans navigateur (TV, IoT), oÃ¹ lâ€™utilisateur sâ€™authentifie sur un autre terminal.
* *Refresh Token* â€“ Pour obtenir de nouveaux tokens sans rÃ©-authentification de lâ€™utilisateur.
* *Implicit Flow* â€“ Ancien flux dÃ©sormais dÃ©conseillÃ©, car les tokens transitent dans lâ€™URL du navigateur. (Non abordÃ© ici)

Chaque flux possÃ¨de ses spÃ©cificitÃ©s de sÃ©curitÃ©, ses avantages, et des scÃ©narios recommandÃ©s.

== Flux Authorization Code

Le flux Authorization Code est le plus robuste et sÃ©curisÃ© pour les clients confidentiels (serveur back-end). Il est Ã©galement recommandÃ© pour les clients publics (mobile, SPA) avec PKCE (Voir section suivante).

Le client nâ€™obtient jamais directement le token via le navigateur : il passe par un code dâ€™autorisation Ã©changÃ© ensuite cÃ´tÃ© serveur contre un access token.

=== Ã‰tape 1 â€“ RequÃªte dâ€™autorisation & redirection vers lâ€™Authorization Server

[plantuml]
----
@startuml
actor "Utilisateur" as User
participant "Navigateur"
participant "Client (App Web)" as Client
participant "Authorization Server (AS)" as AS

== AccÃ¨s initial ==
User -> Navigateur : AccÃ¨s Ã  une ressource protÃ©gÃ©e (/photos)
Navigateur -> Client : GET /photos

Client -> Navigateur : Redirection 302 vers AS

note right of Navigateur
Redirection vers :
https://auth.example.com/authorize?
- response_type=code
- client_id=client123
- redirect_uri=https://client.com/callback
- scope=read:photos
- state=xyz123
end note

Navigateur -> AS : GET /authorize avec paramÃ¨tres

note right of AS
Lâ€™AS :
- Identifie le client via client_id
- VÃ©rifie redirect_uri
- Affiche une page de login
end note

AS -> Navigateur : Page HTML avec formulaire de login
@enduml
----

=== Ã‰tape 2 â€“ Authentification, consentement et obtention du token

[plantuml]
----
@startuml
actor "Utilisateur" as User
participant "Navigateur"
participant "Client (App Web)" as Client
participant "Authorization Server (AS)" as AS

== Authentification ==
User -> Navigateur : Remplit login / mot de passe
Navigateur -> AS : POST /login avec credentials

AS -> AS : VÃ©rifie les identifiants

== Consentement ==
note right of AS
Affiche une page de consentement :
- Scopes demandÃ©s
- Nom du client
- Bouton "Autoriser"
end note

User -> Navigateur : Clique sur "Autoriser"
Navigateur -> AS : POST /consent

== GÃ©nÃ©ration du code ==
note right of AS
Lâ€™AS :
- GÃ©nÃ¨re un code unique (ex: abc123)
- Associe code + client_id + utilisateur + scopes
- Stocke en base temporairement
end note

AS -> Navigateur : Redirection 302 vers redirect_uri

note right of Navigateur
Redirection vers :
https://client.com/callback?
- code=abc123
- state=xyz123
end note

Navigateur -> Client : GET /callback?code=abc123&state=xyz123

== Ã‰change de code contre token ==
Client -> AS : POST /token

note right of Client
Body :
- grant_type=authorization_code
- code=abc123
- redirect_uri=https://client.com/callback
- client_id + client_secret (ou header Basic)
end note

AS -> AS : VÃ©rifie code, expiration, client_id

AS -> Client : access_token + refresh_token (JSON)
@enduml
----

=== ğŸ” DÃ©tails techniques â€“ Ã‰change du code contre un token

Lâ€™Ã©change du code dâ€™autorisation contre un access_token sâ€™effectue cÃ´tÃ© serveur uniquement, via une requÃªte POST du client vers lâ€™Authorization Server.

==== ğŸ“¦ ParamÃ¨tres de la requÃªte /token

[source,http]
----
POST /token HTTP/1.1
Host: auth.example.com
Content-Type: application/x-www-form-urlencoded
Authorization: Basic base64(client_id:client_secret)
grant_type=authorization_code&
code=abc123&
redirect_uri=https://client.com/callback
----

Ou, sans en-tÃªte Authorization :
[source,x-www-form-urlencoded]
----
grant_type=authorization_code
&code=abc123
&redirect_uri=https://client.com/callback
&client_id=client123
&client_secret=secret456
----

==== ğŸ” Pourquoi faut-il renvoyer redirect_uri ?

Si le redirect_uri a Ã©tÃ© fourni lors de l'Ã©tape /authorize, il doit impÃ©rativement Ãªtre renvoyÃ© Ã  l'Ã©tape /token.

Cela permet Ã  lâ€™Authorization Server de valider que la redirection est identique Ã  celle utilisÃ©e prÃ©cÃ©demment. Ce mÃ©canisme protÃ¨ge contre des attaques de substitution ou de redirection malveillante.

==== ğŸ” Ã€ quoi sert le client_secret ?

Le client_secret est un secret partagÃ© connu uniquement du client et de lâ€™Authorization Server.

    Il est attribuÃ© lors de lâ€™enregistrement du client.
    Il permet de prouver que lâ€™appel /token provient bien du client dÃ©clarÃ©.

    Il ne doit jamais Ãªtre exposÃ© dans le navigateur ou des apps mobiles (voir PKCE).

Ce secret est utilisÃ© uniquement par les clients confidentiels (ex : backend dâ€™une webapp ou service serveur-serveur).

==== ğŸ§¾ Quâ€™est-ce que Authorization: Basic ?

OAuth 2.0 permet de transmettre les identifiants client de deux faÃ§ons :

. En les incluant dans le body (client_id, client_secret)
. Ou via lâ€™en-tÃªte HTTP Authorization: Basic ... (recommandÃ©)

Le format Basic suit la RFC 7617 :
[source,http]
----
Authorization: Basic <base64(client_id:client_secret)>

# Exemple
Authorization: Basic Y2xpZW50MTIzOnNlY3JldDEyMw==
dÃ©codÃ© = client123:secret123
----

Cette mÃ©thode est plus propre, car :

    conforme aux standards HTTP
    permet dâ€™Ã©viter de logger accidentellement les secrets dans les corps de requÃªtes

==== âœ… Bonnes pratiques

    Ne jamais exposer le client_secret dans un environnement non sÃ©curisÃ©

    Toujours valider le redirect_uri strictement

    Utiliser l'en-tÃªte Authorization: Basic si possible

    Mettre en place une politique dâ€™expiration courte pour le code

    Activer PKCE pour les clients publics (mobile, SPA)

== Flux Authorization Code + PKCE

PKCE (Proof Key for Code Exchange) a Ã©tÃ© conÃ§u pour **permettre lâ€™utilisation du flux Authorization Code dans les clients publics (SPA, mobile, desktop)**, câ€™est-Ã -dire des applications qui **ne peuvent pas stocker un `client_secret` en toute sÃ©curitÃ©**.

Dans le flux classique, un client confidentiel prouve son identitÃ© Ã  lâ€™Ã©tape `/token` grÃ¢ce Ã  un `client_secret`. Or, dans un client public, ce secret pourrait Ãªtre compromis (ex : code accessible, reverse engineering, logs, etc.).

PKCE permet de **remplacer ce `client_secret` par une preuve Ã©phÃ©mÃ¨re**, gÃ©nÃ©rÃ©e dynamiquement et propre Ã  la session dâ€™authentification, Ã  lâ€™aide de deux Ã©lÃ©ments :

* `code_verifier` : une chaÃ®ne alÃ©atoire secrÃ¨te, conservÃ©e uniquement en mÃ©moire cÃ´tÃ© client
* `code_challenge` : une empreinte dÃ©rivÃ©e du `code_verifier`, gÃ©nÃ©ralement `base64url(SHA256(code_verifier))`

Ã€ lâ€™Ã©tape 1, seul le code_challenge est envoyÃ© avec la requÃªte /authorize.
Ã€ lâ€™Ã©tape 2, le client prÃ©sente le code_verifier pour prouver quâ€™il est bien Ã  lâ€™origine de lâ€™Ã©tape 1.

MÃªme si un attaquant parvient Ã  intercepter le code (et mÃªme le code_challenge), il ne peut pas dÃ©duire le code_verifier.

Ce dernier est conservÃ© uniquement en mÃ©moire locale, jamais transmis tant que lâ€™application nâ€™est pas prÃªte Ã  obtenir un token.

PKCE corrige donc **la vulnÃ©rabilitÃ© principale des clients publics** utilisant le flux Authorization Code sans `client_secret`, en garantissant que seul le client initial peut finaliser lâ€™Ã©change.

=== Ã‰tape 1 â€“ RequÃªte dâ€™autorisation avec code_challenge

[plantuml]
----
@startuml
actor "Utilisateur" as User
participant "Navigateur (App SPA/Mobile)" as App
participant "Authorization Server (AS)" as AS

== GÃ©nÃ©ration cÃ´tÃ© client ==
note right of App
Avant toute redirection :
- GÃ©nÃ¨re un `code_verifier` (chaÃ®ne alÃ©atoire)
- Calcule `code_challenge = BASE64URL(SHA256(code_verifier))`
end note

User -> App : Demande une ressource protÃ©gÃ©e
App -> AS : Redirection vers /authorize

note right of App
GET /authorize?
- response_type=code
- client_id=public123
- redirect_uri=https://app.com/callback
- code_challenge=xyz987
- code_challenge_method=S256
- scope=read:photos openid
- state=abc999
end note

App -> AS : GET /authorize avec code_challenge
AS -> App : Affiche page login / mot de passe
@enduml
----

=== Ã‰tape 2 â€“ Authentification, autorisation, et Ã©change avec code_verifier

[plantuml]
----
@startuml
actor "Utilisateur" as User
participant "Navigateur (App SPA/Mobile)" as App
participant "Authorization Server (AS)"

== Authentification ==
User -> App : Saisie identifiants
App -> AS : POST /login (username, password)
AS -> AS : VÃ©rifie l'identitÃ©

== Consentement ==
note right of AS
Affiche consentement :
- Scopes demandÃ©s
- Client concernÃ©
- Bouton "Autoriser"
end note

User -> App : Autorise les accÃ¨s
App -> AS : POST /consent

== Redirection avec code ==
note right of AS
Lâ€™AS :
- GÃ©nÃ¨re un code unique (auth code)
- Lâ€™associe au client + code_challenge + scopes
end note

AS -> App : Redirection 302 vers redirect_uri?code=abc123&state=abc999
App -> App : Extrait le code d'autorisation

== Ã‰change avec code_verifier ==
App -> AS : POST /token

note right of App
POST :
- grant_type=authorization_code
- code=abc123
- redirect_uri=https://app.com/callback
- code_verifier = original string gÃ©nÃ©rÃ©e
- client_id = public123
(end note)

AS -> AS : VÃ©rifie code + calcule SHA256(code_verifier)

note right of AS
VÃ©rifie que :
SHA256(code_verifier) == code_challenge reÃ§u Ã  lâ€™Ã©tape /authorize
end note

AS -> App : Renvoie access_token (+ id_token, refresh_token si OIDC)
@enduml
----

== Flux Client Credentials

Le flux Client Credentials est utilisÃ© lorsquâ€™une application souhaite accÃ©der Ã  une API en son propre nom, sans utilisateur final.
Câ€™est le cas typique des appels machine-to-machine (M2M), des scripts backend ou des microservices.
Ce flux nâ€™implique aucune redirection, ni interaction utilisateur. La sÃ©curitÃ© repose essentiellement sur le fait que le client_secret est considÃ©rÃ© en sÃ©curitÃ© sur le serveur. Le couple client_id client_secret peut Ãªtre fourni en paramÃ¨tre, ou comme lors des flux prÃ©cÃ©dents via le header Authorization ce qui est plus propre.

=== ğŸ” Cas dâ€™usage typiques

    Un microservice qui appelle une API centrale

    Un script batch qui consulte un backend

    Une application CLI qui accÃ¨de Ã   des mÃ©triques, logs, jobs, etc.

    Un service qui veut authentifier sa propre identitÃ© pour effectuer des actions automatisÃ©es

=== ğŸ§­ Vue dâ€™ensemble du flux

[plantuml]
----
@startuml
participant "Client (Backend Service)" as Client
participant "Authorization Server (AS)" as AS
participant "Resource Server (API)" as API

== Authentification ==
Client -> AS : POST /token

note right of Client
Body :
grant_type=client_credentials
client_id=backend-app
client_secret=s3cr3t
scope=read:logs (optionnel)
end note

AS -> AS : VÃ©rifie client_id + client_secret
AS -> Client : access_token (JSON)

== Appel API ==
Client -> API : GET /resource
note right of Client
Authorization: Bearer <access_token>
end note

API -> Client : DonnÃ©es autorisÃ©es
@enduml
----

=== ğŸ“¦ RequÃªte /token

[source,http]
----
POST /token HTTP/1.1
Host: auth.example.com
Content-Type: application/x-www-form-urlencoded
Authorization: Basic base64(client_id:client_secret)
grant_type=client_credentials
&scope=read:logs

Ou sans en-tÃªte Authorization, dans le corps :
[source,x-www-form-urlencoded]
grant_type=client_credentials
&client_id=backend-app
&client_secret=s3cr3t
&scope=read:logs
----

=== ğŸ” DÃ©tails techniques

|====
| Ã‰lÃ©ment	| Obligatoire | 	Description
| grant_type	| âœ…	 | Toujours client_credentials
| client_id	| âœ…	 | Identifiant du client (application)
| client_secret| 	âœ…	 | Secret partagÃ© enregistrÃ© avec le client
| scope	| âŒ	 | Optionnel, permissions souhaitÃ©es (peut Ãªtre fixÃ©e cÃ´tÃ© AS)
|====

=== ğŸ” RÃ©ponse
[source,json]
----
{
"access_token": "eyJhbGciOiJIUzI1NiIsInR...",
"token_type": "Bearer",
"expires_in": 3600,
"scope": "read:logs"
}
----

Le token est gÃ©nÃ©ralement un JWT signÃ©, ou un token opaque, selon lâ€™implÃ©mentation.

=== âœ… Bonnes pratiques

    Toujours utiliser TLS (HTTPS) entre tous les acteurs

    Appliquer un scope minimal pour chaque client

    Faire expirer les tokens rapidement (expires_in court)

    Utiliser des client_id/secret rotatables

    Auditer les tokens utilisÃ©s : frÃ©quence, Ã©tendue, logs

    Appliquer le principe du least privilege




== Flux Device Code

Le flux *Device Authorization Grant* (ou *Device Code*) est conÃ§u pour les appareils **dÃ©pourvus de navigateur** ou avec **interface utilisateur limitÃ©e** (TV, consoles, imprimantes, IoT).
Il dÃ©lÃ¨gue lâ€™authentification Ã  un second appareil disposant dâ€™un navigateur.

=== ğŸ” Cas dâ€™usage typiques

* Une TV qui affiche un code et demande Ã  lâ€™utilisateur de se rendre sur `example.com/activate`
* Une console de jeu ou imprimante connectÃ©e
* Un appareil IoT qui doit accÃ©der Ã  une API avec autorisation utilisateur

=== ğŸ§­ Vue dâ€™ensemble du flux

[plantuml]
----
@startuml
actor "Utilisateur" as User
participant "Device (Appareil)" as Device
participant "Authorization Server (AS)" as AS
participant "Navigateur (sur autre appareil)" as Browser
participant "Resource Server (API)" as API

== 1. Demande de code ==
Device -> AS : POST /device_authorization
note right of Device
ParamÃ¨tres :
- client_id
- scope
end note

AS -> Device : device_code + user_code + verification_uri
note right of AS
RÃ©ponse :
- device_code
- user_code
- verification_uri
- verification_uri_complete
- expires_in
- interval
end note

== 2. L'utilisateur autorise ==
Device -> User : Affiche user_code + URL
User -> Browser : Va sur verification_uri
User -> AS : Sâ€™authentifie et saisit le user_code
AS -> User : Demande consentement
User -> AS : Autorise lâ€™accÃ¨s

== 3. Polling token ==
loop polling
Device -> AS : POST /token
note right of Device
ParamÃ¨tres :
- grant_type=device_code
- device_code
- client_id
end note

AS -> Device : pending / slow_down / access_token
end loop

== 4. AccÃ¨s API ==
Device -> API : Authorization: Bearer <access_token>
API -> Device : DonnÃ©es autorisÃ©es
@enduml
----

=== ğŸ§ª DÃ©tail des Ã©tapes

==== Ã‰tape 1 â€“ Lâ€™appareil demande un code

[source,http]
----
POST /device_authorization
Host: auth.example.com
Content-Type: application/x-www-form-urlencoded

client_id=client123&
scope=read:profile
----

RÃ©ponse :

[source,json]
----
{
  "device_code": "abc123xyz",
  "user_code": "XY12-ZZ45",
  "verification_uri": "https://auth.example.com/activate",
  "verification_uri_complete": "https://auth.example.com/activate?user_code=XY12-ZZ45",
  "expires_in": 1800,
  "interval": 5
}
----

==== Ã‰tape 2 â€“ Lâ€™utilisateur autorise lâ€™accÃ¨s

Lâ€™appareil affiche :
----
Pour continuer, rendez-vous sur : https://auth.example.com/activate
Code : XY12-ZZ45
----


Lâ€™utilisateur :

. Ouvre son navigateur sur un autre appareil
. Va sur la `verification_uri`
. Sâ€™authentifie (login/mot de passe)
. Saisit le `user_code`
. Accepte les scopes demandÃ©s

==== Ã‰tape 3 â€“ Le device interroge rÃ©guliÃ¨rement le serveur

[source,http]
----
POST /token
Host: auth.example.com
Content-Type: application/x-www-form-urlencoded

grant_type=urn:ietf:params:oauth:grant-type:device_code&
device_code=abc123xyz&
client_id=client123
----

RÃ©ponses possibles :

* `authorization_pending` â†’ lâ€™utilisateur nâ€™a pas encore validÃ©
* `slow_down` â†’ trop de requÃªtes
* `access_token` â†’ succÃ¨s

Exemple :

[source,json]
----
{
  "access_token": "eyJhbGciOi...",
  "token_type": "Bearer",
  "expires_in": 3600,
  "scope": "read:profile"
}
----

==== Ã‰tape 4 â€“ Utilisation du token

[source,http]
----
GET /me HTTP/1.1
Host: api.example.com
Authorization: Bearer eyJhbGciOi...
----

=== âœ… RÃ©sumÃ© des champs

[cols="1,3",options="header"]
|===
| Ã‰lÃ©ment | Description

| client_id | Identifiant de lâ€™appareil ou de lâ€™application
| device_code | Jeton secret cÃ´tÃ© appareil, utilisÃ© pour le polling
| user_code | Code affichÃ© Ã  lâ€™utilisateur
| verification_uri | URL Ã  visiter pour autoriser lâ€™accÃ¨s
| access_token | Jeton dâ€™accÃ¨s final une fois lâ€™autorisation donnÃ©e
| interval | Temps (en secondes) Ã  attendre entre deux requÃªtes de polling
|===

=== ğŸ” SÃ©curitÃ© et bonnes pratiques

* Aucun `client_secret` nâ€™est requis
* Le `device_code` expire rapidement (ex : 10-15 min)
* Le polling doit respecter lâ€™`interval` pour Ã©viter un rejet
* Lâ€™access_token ne doit pas Ãªtre stockÃ© durablement sur lâ€™appareil
* Lâ€™utilisateur peut annuler ou rÃ©voquer lâ€™autorisation



== Flux Refresh Token

Le flux *Refresh Token* permet Ã  un client dâ€™obtenir un nouveau `access_token` **sans interaction utilisateur**, une fois que le token dâ€™origine a expirÃ©.

Ce mÃ©canisme permet :

* dâ€™Ã©viter de redemander une authentification trop frÃ©quente,
* de maintenir des sessions utilisateur actives sur le long terme,
* de ne pas exposer directement les credentials Ã  chaque requÃªte.

Le `refresh_token` est obtenu Ã  lâ€™issue dâ€™un flux principal (gÃ©nÃ©ralement Authorization Code ou Device Code) si ce dernier lâ€™autorise.

=== ğŸ” Cas dâ€™usage typiques

* Une SPA ou application mobile qui souhaite maintenir une session utilisateur
* Un client confidentiel qui veut renouveler silencieusement ses accÃ¨s Ã  des API
* Une application web qui renouvelle le `access_token` en arriÃ¨re-plan

=== ğŸ§­ Vue dâ€™ensemble du flux

.refresh_token avec client sÃ»r
[plantuml]
----
@startuml
actor "Utilisateur" as User
participant "Client (App)" as Client
participant "Authorization Server (AS)" as AS
participant "Resource Server (API)" as API

== 1. Flux initial ==
User -> Client : Authentification initiale (ex: code)
Client -> AS : POST /token
AS -> Client : access_token + refresh_token

== 2. Appel API ==
Client -> API : Authorization: Bearer access_token
API -> Client : DonnÃ©es

== 3. Le token expire ==
note right of Client
access_token expirÃ© (ex: 3600s)
end note

== 4. RafraÃ®chissement ==
Client -> AS : POST /token
note right of Client
ParamÃ¨tres :
- grant_type=refresh_token
- refresh_token
- client_id (+ client_secret si confidentiel)
end note

AS -> Client : Nouveau access_token (+ refresh_token si rotation)
@enduml
----

.client publique non sÃ»r (pkce)

[plantuml]
----
@startuml
actor "Utilisateur" as User
participant "Client (SPA â€“ public)" as Client
participant "Authorization Server (AS)" as AS
participant "Resource Server (API)" as API

== 1. Flux initial ==
User -> Client : Authentification initiale (avec PKCE)
Client -> AS : POST /token (code + code_verifier)
AS -> Client : access_token + refresh_token

== 2. Appel API ==
Client -> API : Authorization: Bearer access_token
API -> Client : DonnÃ©es

== 3. Le token expire ==
note right of Client
access_token expirÃ© (ex: 3600s)
end note

== 4. RafraÃ®chissement ==
Client -> AS : POST /token

note right of Client
ParamÃ¨tres :
- grant_type=refresh_token
- refresh_token
- client_id
(N.B. : PAS de client_secret)
end note

AS -> Client : Nouveau access_token (+ refresh_token si rotation)
@enduml
----

=== ğŸ“¦ RequÃªte /token pour le rafraÃ®chissement

[source,http]
----
POST /token HTTP/1.1
Host: auth.example.com
Content-Type: application/x-www-form-urlencoded
Authorization: Basic base64(client_id:client_secret)

grant_type=refresh_token
&refresh_token=def456uvw
----

Ou dans le corps :

[source,x-www-form-urlencoded]
----
grant_type=refresh_token
&client_id=client123
&client_secret=s3cr3t # Si applicable
&refresh_token=def456uvw
----

=== ğŸ” RÃ©ponse typique

[source,json]
----
{
  "access_token": "eyJhbGciOi...",
  "token_type": "Bearer",
  "expires_in": 3600,
  "scope": "read:profile",
  "refresh_token": "ghi789rst" // optionnel, si rotation activÃ©e
}
----

=== ğŸ”„ Refresh Token Rotation

Certains serveurs OAuth (ex: Auth0, Keycloak, Google) activent par dÃ©faut une stratÃ©gie de **rotation de refresh_token** :

* Ã€ chaque appel rÃ©ussi de `/token`, un nouveau `refresh_token` est fourni
* Lâ€™ancien est invalidÃ©
* EmpÃªche le vol ou la rÃ©utilisation frauduleuse

Cette rotation permet une meilleure dÃ©tection dâ€™usage simultanÃ© ou de fuite du refresh token.

=== âš ï¸ Erreurs frÃ©quentes

[source,json]
----
{
  "error": "invalid_grant",
  "error_description": "Refresh token expired or revoked"
}
----

Autres erreurs possibles :

* `invalid_client` â†’ mauvais client_id/secret
* `invalid_scope` â†’ scope non autorisÃ©
* `unauthorized_client` â†’ ce client nâ€™est pas autorisÃ© Ã  rafraÃ®chir

=== âœ… Bonnes pratiques

* Ne jamais exposer un `refresh_token` dans un navigateur (localStorage, JS)
* Activer la rotation de refresh_token quand possible
* Coupler chaque refresh_token Ã  un seul appareil/session
* RÃ©voquer les refresh_token en cas de logout
* Ne pas donner de durÃ©e de vie infinie (ex: 30j max, puis re-auth obligatoire)
* ProtÃ©ger lâ€™endpoint `/token` contre les brute force

=== ğŸ” OÃ¹ sont stockÃ©s les refresh_token ?

[cols="1,3",options="header"]
|===
| Type de client | Recommandation

| Application mobile | Stockage sÃ©curisÃ© (Keychain, Android Keystore)
| WebApp SPA (JS)    | âš ï¸ Ã€ Ã©viter (ne pas exposer de refresh_token cÃ´tÃ© client)
| Client confidentiel (backend) | Base de donnÃ©es sÃ©curisÃ©e
|===

=== ğŸ” Ã€ noter

* Le `refresh_token` nâ€™est **jamais envoyÃ©** Ã  une API mÃ©tier.
* Il nâ€™est utilisÃ© **que** pour obtenir un nouveau `access_token` depuis lâ€™AS.
* Il peut Ãªtre accompagnÃ© ou non dâ€™un nouveau `refresh_token` (rotation ou non).

== â“ OÃ¹ est lâ€™IdP dans OAuth 2.0 ?

Il nâ€™y en a pas, car OAuth 2.0 est un protocole dâ€™autorisation, pas dâ€™authentification.

    Lâ€™Authorization Server peut faire office dâ€™IdP implicitement,
    Mais OAuth ne fournit pas de garantie sur lâ€™identitÃ© de lâ€™utilisateur.

Câ€™est pour cela quâ€™est nÃ© OpenID Connect (OIDC), une surcouche dâ€™authentification sur OAuth 2.0.

=== ğŸ”“ OpenID Connect (Voir fiche associÃ©e pour plus de dÃ©tail)

OpenID Connect introduit la notion dâ€™Identity Provider (IdP) en ajoutant :

    un id_token (JWT signÃ© contenant lâ€™identitÃ© de lâ€™utilisateur),

    des endpoints supplÃ©mentaires (/.well-known/openid-configuration, /userinfo),

    un scope openid obligatoire.

.OAuth vs OIDC
|===
| Protocole | Token principal | Concerne | Fournit l'identitÃ© ? | PrÃ©sence dâ€™un IdP

| OAuth 2.0 | access_token | AccÃ¨s Ã  des API | âŒ Non | âŒ Non
| OIDC | id_token + access_token | Authentification + autorisation | âœ… Oui | âœ… Oui
|===

Pour faire simple :

    OAuth â†’ "Puis-je accÃ©der Ã  cette ressource au nom de lâ€™utilisateur ?"

    OIDC â†’ "Qui est cet utilisateur, et puis-je lui faire confiance ?"

== ğŸ” Gestion de lâ€™URL cible et du state

Lorsque lâ€™utilisateur tente dâ€™accÃ©der Ã  une ressource protÃ©gÃ©e (ex : `/photos/1234`), il est redirigÃ© vers le serveur dâ€™autorisation pour authentification. Une fois le flux OAuth terminÃ©, lâ€™application doit rediriger lâ€™utilisateur vers **la ressource initialement demandÃ©e**.

Comme le protocole OAuth 2.0 ne fournit pas de mÃ©canisme standard pour transporter cette information (contrairement Ã  SAML avec `RelayState`), câ€™est au client dâ€™assurer ce lien.

=== ğŸ§­ MÃ©canismes possibles

1. **Stockage cÃ´tÃ© serveur** :
Le client gÃ©nÃ¨re un identifiant `state` (alÃ©atoire, sÃ©curisÃ©) et associe lâ€™URL initiale Ã  ce `state` dans une session cÃ´tÃ© serveur (ex : en mÃ©moire ou via Redis).

2. **Encodage direct dans le `state`** :
Lâ€™URL cible est encodÃ©e directement dans la valeur du `state`, souvent sÃ©parÃ©e par un dÃ©limiteur :

----
state=csrf123___/photos/1234
----

e format permet dâ€™associer protection CSRF et redirection.

=== ğŸ”„ Exemple en Ruby

[source,ruby]
----
state_id = SecureRandom.hex(16)
session[state_id] = {
original_url: "/photos/1234",
created_at: Time.now
}
redirect_to "https://auth.example.com/authorize?state=#{state_id}"
----

=== ğŸ“¥ RÃ©cupÃ©ration Ã  la fin du flux

Une fois lâ€™utilisateur redirigÃ© vers le client avec `?code=abc123&state=csrf123___/photos/1234`, le client :

. vÃ©rifie la partie anti-CSRF (`csrf123`)
. rÃ©cupÃ¨re ou dÃ©code lâ€™URL dâ€™origine (`/photos/1234`)
. effectue la redirection finale vers la ressource cible

=== âœ… Bonnes pratiques

* Toujours signer et vÃ©rifier le paramÃ¨tre `state` pour prÃ©venir les attaques CSRF.
* Limiter la durÃ©e de vie des entrÃ©es `state` en session.
* Ne jamais faire confiance Ã  une URL transmise directement par lâ€™utilisateur (ex : paramÃ¨tre `redirect=` non vÃ©rifiÃ©).
* Valider systÃ©matiquement que lâ€™URL de redirection est interne Ã  lâ€™application.


== ğŸš¨ VulnÃ©rabilitÃ©s connues (et contre-mesures)

[cols="2,4"]
|===
|ProblÃ¨me |Mitigation

|Interception du code | Toujours Ã©changer le code cÃ´tÃ© serveur
|CSRF / attaque de session | Utiliser un state robuste et signÃ©
|Redirection externe | Ne jamais autoriser dâ€™URI dynamique, uniquement des valeurs whitelistÃ©es
|Token volÃ© | Limiter la durÃ©e (expires_in) + rotation des tokens
|===

== Configurations avancÃ©es

=== ğŸ” JAR â€“ JWT Authorization Request

Le mÃ©canisme *JAR* (JWT Authorization Request) permet dâ€™envoyer une requÃªte `/authorize` encapsulÃ©e dans un JWT signÃ©, au lieu de passer tous les paramÃ¨tres dans lâ€™URL.

[source,http]
----
GET /authorize?request=eyJhbGciOiJSUzI1NiIsImtpZCI6ImtleS0xIn0... (JWT signÃ©)
----

Ce JWT contient tous les paramÃ¨tres OAuth habituels, comme :
- `client_id`
- `redirect_uri`
- `response_type`
- `scope`
- `state`
- `exp`, `aud`, `iss` (normes JWT)

La signature garantit :
- lâ€™**intÃ©gritÃ©** des paramÃ¨tres (aucune modification possible),
- lâ€™**authenticitÃ©** du client,
- la **protection contre les attaques par injection de paramÃ¨tres** (`redirect_uri`, `scope`, etc.).

==== ğŸ“ Pourquoi utiliser JAR ?

* Les URL `/authorize?...` sont visibles dans le navigateur, interceptables dans des logs, modifiables cÃ´tÃ© client.
* Avec JAR, toute la requÃªte est encapsulÃ©e et signÃ©e avec une **clÃ© privÃ©e**, que seul le client possÃ¨de.
* Le serveur dâ€™autorisation valide la signature et **rejette** toute requÃªte falsifiÃ©e.

==== ğŸ§¾ Exemple de JWT pour request=

Un JWT typique dans JAR pourrait contenir ceci :

.En-tÃªte (header)
[source,json]
----
{
  "alg": "RS256",
  "typ": "JWT",
  "kid": "client-key-1"
}
----

.Payload (claims)
[source,json]
----
{
  "response_type": "code",
  "client_id": "client123",
  "redirect_uri": "https://client.example.com/callback",
  "scope": "openid profile",
  "state": "abcXYZ123",
  "nonce": "n-0S6_WzA2Mj",
  "aud": "https://auth.example.com",
  "iss": "client123",
  "exp": 1710000000
}
----

.Signature
SignÃ©e avec la clÃ© privÃ©e du client, rÃ©fÃ©rencÃ©e par `kid`.

Ce JWT est ensuite passÃ© en paramÃ¨tre :
[source,http]
----
GET /authorize?request=eyJhbGciOi...
----

==== ğŸ”‘ Comment lâ€™Authorization Server vÃ©rifie la signature ?

Le client doit avoir **dÃ©clarÃ© sa clÃ© publique** au prÃ©alable. Deux options :

===== ğŸ“ 1. Via un `jwks_uri` (JSON Web Key Set URI)

Le client fournit une URL lors de son enregistrement (statique ou dynamique) :

[source,json]
----
{
  "client_id": "client123",
  "jwks_uri": "https://client.example.com/jwks.json"
}
----

Exemple de `jwks.json` publiÃ© par le client :

[source,json]
----
{
  "keys": [
    {
      "kty": "RSA",
      "kid": "client-key-1",
      "use": "sig",
      "alg": "RS256",
      "n": "MIIBIjANBgkqhk...",  // clÃ© publique modulaire (base64url)
      "e": "AQAB"
    }
  ]
}
----

===== ğŸ“ 2. Ou via `jwks` inline Ã  lâ€™enregistrement

[source,json]
----
{
  "client_id": "client123",
  "jwks": {
    "keys": [ ... ] // mÃªme format que ci-dessus
  }
}
----

==== âœ… Bonnes pratiques

* Toujours signer le JWT avec une clÃ© forte (RS256 ou ES256)
* Ne jamais exposer la clÃ© privÃ©e dans le navigateur ou mobile
* Lier lâ€™en-tÃªte `kid` Ã  un JWKS public bien exposÃ©
* Utiliser un `exp` court dans le JWT (ex: 5 min)
* Rejeter toute requÃªte `/authorize` non signÃ©e en contexte FAPI

==== ğŸ“ SpÃ©cifications associÃ©es

- RFC 9101 â€“ OAuth 2.0 JWT-Secured Authorization Request (JAR)
- https://openid.net/specs/openid-financial-api-part-2.html (FAPI Advanced Security Profile)

=== ğŸ“¦ JARM â€“ JWT Secured Authorization Response Mode

JARM (*JWT Secured Authorization Response Mode*) permet Ã  lâ€™Authorization Server de **renvoyer la rÃ©ponse `/authorize` encapsulÃ©e dans un JWT signÃ©**, au lieu de transmettre les paramÃ¨tres (`code`, `state`, etc.) directement dans lâ€™URL.

Cela renforce la sÃ©curitÃ© en assurant :
- lâ€™**intÃ©gritÃ©** des donnÃ©es renvoyÃ©es,
- lâ€™**authenticitÃ©** de lâ€™Authorization Server,
- la **non-altÃ©ration** du `code`, du `state`, etc.,
- une compatibilitÃ© avec la **non-rÃ©pudiation**.

==== ğŸ§­ Exemple de flux avec JARM

[source,http]
----
GET /authorize?response_mode=jwt
----

Au lieu dâ€™un retour classique :
[source,http]
----
302 Found
Location: https://client.com/callback?code=abc123&state=xyz456
----

Lâ€™AS renvoie :
[source,http]
----
302 Found
Location: https://client.com/callback?response=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...
----

Le client doit ensuite :
. dÃ©coder le JWT contenu dans `response=`
. valider la signature avec la **clÃ© publique de lâ€™AS**
. extraire les champs comme `code`, `state`, etc.

==== ğŸ” Exemple de JWT `response=...`

.En-tÃªte
[source,json]
----
{
  "alg": "RS256",
  "kid": "as-key-1",
  "typ": "JWT"
}
----

.Payload
[source,json]
----
{
  "iss": "https://auth.example.com",
  "aud": "client123",
  "exp": 1710000000,
  "iat": 1709999400,
  "code": "abc123",
  "state": "xyz456",
  "redirect_uri": "https://client.com/callback"
}
----

.Signature
SignÃ©e par lâ€™Authorization Server avec sa clÃ© privÃ©e.

==== ğŸ”‘ VÃ©rification cÃ´tÃ© client

Le client doit :
. VÃ©rifier la signature avec la clÃ© publique de lâ€™AS (`jwks_uri` de lâ€™AS)
. VÃ©rifier les claims `iss`, `aud`, `exp`
. Extraire le `code` et le `state` du payload

==== ğŸ“ OÃ¹ trouver la clÃ© publique de lâ€™AS ?

Comme pour tous les JWT OIDC, lâ€™AS expose sa clÃ© via son fichier de configuration OIDC :

[source,http]
----
GET /.well-known/openid-configuration
----

Extrait typique :
[source,json]
----
{
  "issuer": "https://auth.example.com",
  "jwks_uri": "https://auth.example.com/.well-known/jwks.json"
}
----

Le client rÃ©cupÃ¨re les clÃ©s :
[source,json]
----
{
  "keys": [
    {
      "kty": "RSA",
      "kid": "as-key-1",
      "alg": "RS256",
      "use": "sig",
      "n": "...",
      "e": "AQAB"
    }
  ]
}
----

==== ğŸ“Œ Comparaison classique vs JARM

| Ã‰lÃ©ment transmis | Mode classique | Avec JARM |
|------------------|----------------|-----------|
| `code`           | Dans lâ€™URL     | Dans le JWT |
| `state`          | Dans lâ€™URL     | Dans le JWT |
| Signature        | âŒ Non         | âœ… Oui |
| Protection       | âŒ Aucune      | âœ… Signature cryptographique |
| Rejeu ou injection | Possible     | Impossible si bien vÃ©rifiÃ© |

==== âœ… Bonnes pratiques

* Activer `response_mode=jwt` pour tous les flux sensibles (FAPI)
* Toujours vÃ©rifier la signature du JWT (`RS256` ou `ES256`)
* VÃ©rifier `aud`, `iss`, `exp`, `iat`
* Ne jamais traiter un JWT `response=` sans validation stricte

==== ğŸ“š SpÃ©cifications associÃ©es

* https://openid.net/specs/oauth-v2-jarm.html â€“ OAuth 2.0 JWT-Secured Authorization Response Mode (JARM)
* UtilisÃ© et requis dans le profil `FAPI Advanced Security Profile`

=== ğŸ” DPoP â€“ Demonstration of Proof-of-Possession

DPoP (*Demonstration of Proof-of-Possession*) est une extension OAuth 2.0 visant Ã  **protÃ©ger les access tokens contre le vol et le rejeu**.

Un token de type `Bearer` peut Ãªtre volÃ© et rÃ©utilisÃ© nâ€™importe oÃ¹. DPoP introduit une **preuve cryptographique de possession de la clÃ© privÃ©e liÃ©e au token**, Ã  chaque requÃªte.

Il sâ€™agit dâ€™une solution **lÃ©gÃ¨re**, sans certificat (contrairement Ã  MTLS), basÃ©e sur la signature dâ€™un JWT transmis dans lâ€™en-tÃªte `DPoP`.

==== Vulgarisation du fonctionnement

Dans chaque access_token on trouve une clÃ© publique, il s'agit tout simplement de celle fournie par le client, lors de la demande de token. Le client peut mettre la clÃ© publique de son choix. La seule condition est que si il utilise cet access_token il doit prouver qu'il dÃ©tient la clÃ© privÃ©e associÃ©e. Cela se fait via le champ DPoP, qui contient un jwt signÃ© par la clÃ© privÃ©e associÃ©e Ã  la clÃ© publique.

Autrement dit, l'utilisateur du token doit prouver qu'il dÃ©tient la clÃ© privÃ©e associÃ©e Ã  la clÃ© publique.

==== ğŸ” Objectif

EmpÃªcher quâ€™un `access_token` volÃ© soit utilisable ailleurs.

Avec DPoP :
- Le `access_token` est liÃ© Ã  une **clÃ© publique** (incluse dans `cnf.jwk`)
- Chaque requÃªte API doit inclure une **preuve de possession** : un JWT signÃ© avec la **clÃ© privÃ©e**
- Le serveur vÃ©rifie que la **clÃ© publique** utilisÃ©e pour signer correspond Ã  celle dÃ©clarÃ©e dans le token

==== ğŸ§­ Vue dâ€™ensemble du fonctionnement


. Le client gÃ©nÃ¨re localement une **paire de clÃ©s** asymÃ©triques (ex: EC P-256)
. Lors de lâ€™appel `/token`, il envoie un JWT signÃ© dans lâ€™en-tÃªte HTTP `DPoP`, qui contient :
- la **clÃ© publique** dans le champ `jwk` de lâ€™en-tÃªte du JWT
- la mÃ©thode HTTP (`htm`)
- lâ€™URL cible (`htu`)
- un `jti` unique
- un timestamp `iat`
- et est **signÃ© avec la clÃ© privÃ©e correspondant Ã  la clÃ© publique fournie**
. Lâ€™Authorization Server :
- extrait la **clÃ© publique (`jwk`) de lâ€™en-tÃªte du JWT**
- vÃ©rifie que la signature est correcte avec cette clÃ©
- **lâ€™inclut dans lâ€™`access_token`** via le champ `cnf.jwk`

. Lors des appels aux APIs, le client :
  - signe chaque requÃªte avec un nouveau JWT DPoP
  - fournit le mÃªme `access_token`, prÃ©cÃ©dÃ© du mot-clÃ© `DPoP`
. Le serveur de ressources :
  - vÃ©rifie que le JWT est signÃ© avec la mÃªme clÃ© publique que celle liÃ©e au token
  - rejette les appels dont la clÃ© ne correspond pas ou dont le `jti` a dÃ©jÃ  Ã©tÃ© vu (anti-rejeu)

==== ğŸ“¦ Appel `/token` avec DPoP

Exemple :

[source,http]
----
POST /token
Host: auth.example.com
Authorization: Basic base64(client_id:client_secret)
Content-Type: application/x-www-form-urlencoded
DPoP: eyJhbGciOiJFUzI1NiIsInR5cCI6ImRwb3Arand0Iiwian... (JWT signÃ©)

grant_type=authorization_code
&code=abc123
&redirect_uri=https://client.com/callback
----

Lâ€™en-tÃªte `DPoP` est un JWT signÃ© avec la **clÃ© privÃ©e** du client.

==== ğŸ“„ Contenu du JWT DPoP (appel `/token`)

.Header :
[source,json]
----
{
  "typ": "dpop+jwt",
  "alg": "ES256",
  "jwk": {
    "kty": "EC",
    "crv": "P-256",
    "x": "f83OJ3D2xF4U2hK2Y7KiGH2V",
    "y": "x_FEzRu9bktM6uZ7RzvJ2HiV"
  }
}
----

.Payload :
[source,json]
----
{
  "htu": "https://auth.example.com/token",
  "htm": "POST",
  "iat": 1723212345,
  "jti": "550e8400-e29b-41d4-a716-446655440000"
}
----

.Signature :
- Faite avec la **clÃ© privÃ©e associÃ©e au `jwk` ci-dessus**
- Le `jti` est un ID **unique gÃ©nÃ©rÃ© par le client**, utilisÃ© pour lâ€™anti-rejeu
- Le `iat` est un timestamp Unix (en secondes)
- Le `htm` (HTTP Method) et `htu` (Target URI) lient la preuve Ã  la requÃªte

==== ğŸŸï¸ RÃ©ponse `/token` avec `access_token` liÃ© Ã  la clÃ© publique

Lâ€™Authorization Server inclut la **clÃ© publique du client** dans le `access_token`, sous le champ `cnf.jwk`.

Exemple de payload JWT :

[source,json]
----
{
  "sub": "user123",
  "iss": "https://auth.example.com",
  "aud": "https://api.example.com",
  "scope": "read:profile",
  "exp": 1723216000,
  "cnf": {
    "jwk": {
      "kty": "EC",
      "crv": "P-256",
      "x": "f83OJ3D2xF4U2hK2Y7KiGH2V",
      "y": "x_FEzRu9bktM6uZ7RzvJ2HiV"
    }
  }
}
----

Ce champ `cnf.jwk` signifie :
â†’ *"Ce token nâ€™est valide que sâ€™il est prÃ©sentÃ© avec une preuve de possession de cette clÃ© publique."*

==== ğŸ“¡ Appel Ã  une API protÃ©gÃ©e avec DPoP

Exemple :

[source,http]
----
GET /me HTTP/1.1
Host: api.example.com
Authorization: DPoP eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
DPoP: eyJhbGciOiJFUzI1NiIsInR5cCI6ImRwb3Arand0Iiwian... (JWT signÃ©)
----

* Le champ `Authorization` contient le `access_token`, prÃ©cÃ©dÃ© du mot-clÃ© `DPoP` (et non `Bearer`)
* Le champ `DPoP` contient un **nouveau JWT signÃ©**, gÃ©nÃ©rÃ© pour cette requÃªte spÃ©cifique

==== ğŸ“„ Contenu du JWT DPoP (appel API)

.Header :
[source,json]
----
{
  "typ": "dpop+jwt",
  "alg": "ES256",
  "jwk": { ... mÃªme que prÃ©cÃ©demment ... }
}
----

.Payload :
[source,json]
----
{
  "htu": "https://api.example.com/me",
  "htm": "GET",
  "iat": 1723212450,
  "jti": "7ca3c4a1-b1f3-43a6-9f4f-f9ea38cfcd99"
}
----

==== âœ… VÃ©rification cÃ´tÃ© API

Lâ€™API doit vÃ©rifier :

* que le JWT DPoP est bien formÃ© et non expirÃ©
* que le `jwk` dans le header correspond au `cnf.jwk` du token
* que la signature est valide (avec la clÃ© publique)
* que le `htm` et `htu` correspondent Ã  la requÃªte rÃ©elle
* que le `jti` nâ€™a jamais Ã©tÃ© vu (anti-rejeu)

==== ğŸ”’ RÃ©sumÃ© vs Bearer / MTLS

|====
| Ã‰lÃ©ment                     | Bearer Token          | DPoP                          | MTLS (Mutual TLS)
| ClÃ© publique liÃ©e au token  | âŒ Non                | âœ… Oui (`cnf.jwk`)            | âœ… Oui (certificat TLS)
| Signature de la requÃªte     | âŒ Aucune             | âœ… JWT signÃ© (`DPoP`)         | âœ… Implicite via TLS
| Rejeu du token possible     | âœ… Oui                | âŒ Non (preuve requise)       | âŒ Non
| ComplexitÃ© dÃ©ploiement      | âœ… Simple             | âš ï¸ Moyenne (gestion clÃ©)      | âŒ Ã‰levÃ©e (certificats)
| Usage sur mobile/JS         | âœ… Facile             | âœ… Facile                     | âŒ Difficile
|====

==== âœ… Bonnes pratiques DPoP

* GÃ©nÃ©rer une paire de clÃ©s solide (EC P-256 ou RSA 2048)
* Ne jamais exposer la **clÃ© privÃ©e**
* GÃ©nÃ©rer un `jti` unique par requÃªte (UUID v4 recommandÃ©)
* DÃ©finir un `iat` raisonnablement court (0â€“5 min de tolÃ©rance)
* CÃ´tÃ© API, stocker en mÃ©moire les derniers `jti` pour Ã©viter les rejets
* Utiliser HTTPS systÃ©matiquement pour tous les Ã©changes
* Refuser les tokens `Bearer` sur les endpoints sensibles

==== ğŸ“š SpÃ©cifications associÃ©es

* https://datatracker.ietf.org/doc/html/draft-ietf-oauth-dpop
* https://oauth.net/2/dpop/

=== ğŸ” MTLS â€“ Mutual TLS (certificat client + access_token liÃ©)

Mutual TLS (*mTLS*) est un **protocole rÃ©seau standard**, utilisÃ© pour Ã©tablir une connexion HTTPS oÃ¹ **le client prÃ©sente Ã©galement un certificat X.509**, en plus de celui du serveur.

OAuth 2.0 **rÃ©utilise** ce mÃ©canisme TLS pour deux objectifs spÃ©cifiques :

. Authentifier le client OAuth via son certificat lors de lâ€™appel `/token`
. Lier lâ€™`access_token` au certificat, pour quâ€™il **ne puisse Ãªtre utilisÃ© que par le mÃªme client**

Ce mÃ©canisme est dÃ©fini dans la RFC officielle :
https://tools.ietf.org/html/rfc8705

==== ğŸ“ mTLS : protocole standard au niveau TLS

mTLS est une **fonctionnalitÃ© native de TLS**, utilisÃ©e dans de nombreux contextes (VPN, bases de donnÃ©es, SI industriels, etc.) :

. Le serveur envoie son certificat TLS
. Il demande un **certificat client** (`CertificateRequest`)
. Le client envoie un **certificat X.509**, signÃ© par une CA
. La session TLS est Ã©tablie uniquement si le certificat client est **valide et approuvÃ©**

Ce processus est purement rÃ©seau, et se produit **avant mÃªme lâ€™Ã©change de donnÃ©es HTTP**.

==== ğŸ§­ Dans OAuth 2.0 : une couche dâ€™authentification et de liaison

OAuth 2.0 **dÃ©tourne mTLS** pour deux usages bien prÃ©cis :

1. ğŸ” **Authentification du client OAuth**
- Le client **prÃ©sente son certificat** lors du handshake TLS vers `/token`
- Le serveur OAuth (AS) utilise ce certificat pour **identifier et authentifier le `client_id`**

- Deux modes sont possibles :

a. `tls_client_auth` : certificat signÃ© par une CA connue, c'est le full handshake qui valide le certificat
b. `self_signed_tls_client_auth` : certificat auto-signÃ©, mais dont la **clÃ© publique est prÃ©-enregistrÃ©e**, c'est l'Ã©tape /token qui valide le certificat en comparant la clÃ© publique fournie avec celles enregistrÃ©es

2. ğŸ”— **Liaison de lâ€™`access_token` Ã  ce certificat**
- Lâ€™AS extrait lâ€™empreinte SHA-256 du certificat prÃ©sentÃ©
- Il lâ€™intÃ¨gre dans le `access_token` (JWT) dans le champ `cnf.x5t#S256`
- Ainsi, **le token ne pourra Ãªtre utilisÃ© que via mTLS avec ce mÃªme certificat**

.tls_client_auth
[plantuml]
----
@startuml
actor "Client OAuth" as Client
participant "Auth Server" as AS
participant "TLS Layer" as TLS

== Connexion TLS mutualisÃ©e ==

Client -> TLS : ClientHello (propose mTLS)
TLS -> Client : CertificateRequest
Client -> TLS : Certificat X.509 signÃ© (par CA)
note right of Client
Le client signe un challenge TLS
avec sa clÃ© privÃ©e
end note
note right of TLS
VÃ©rifie :
* ValiditÃ© du CA
* Possession de la clÃ© privÃ©e via challenge
end note
TLS -> AS : TLS OK, connexion Ã©tablie

== Appel /token ==

Client -> AS : POST /token\n(client_id, grant_type, scope)
note right of AS
Compare le certificat reÃ§u avec
celui attendu pour client_id
end note
AS -> AS : Calcule x5t#S256 du certificat
AS -> Client : access_token JWT\n(avec cnf.x5t#S256)
@enduml
----

.self_signed_tls_client_auth
[plantuml]
----
@startuml
actor "Client OAuth" as Client
participant "Auth Server" as AS
participant "TLS Layer" as TLS

== Connexion TLS mutualisÃ©e ==

Client -> TLS : ClientHello (propose mTLS)
TLS -> Client : CertificateRequest
Client -> TLS : Certificat X.509 auto-signÃ©
note right of Client
Le client signe un challenge TLS
avec sa clÃ© privÃ©e
end note
note right of TLS
VÃ©rifie :
* Possession de la clÃ© privÃ©e via challenge
âš ï¸ Pas de vÃ©rification de lâ€™Ã©metteur (auto-signÃ©)
end note
TLS -> AS : TLS OK, connexion Ã©tablie

== Appel /token ==

Client -> AS : POST /token\n(client_id, grant_type, scope)
note right of AS
Compare la **clÃ© publique** du certificat TLS
avec celle enregistrÃ©e pour ce `client_id`
end note
AS -> AS : Calcule x5t#S256 du certificat
AS -> Client : access_token JWT\n(avec cnf.x5t#S256)
@enduml
----

.RÃ©cupÃ©ration du token (identique au deux flux)
[plantuml]
----
@startuml
actor "Client OAuth" as Client
participant "API Server" as API
participant "TLS Layer" as TLS

== Connexion mTLS ==

Client -> TLS : ClientHello (mTLS)
TLS -> Client : CertificateRequest
Client -> TLS : Certificat X.509 (mÃªme que /token)
note right of Client
Le client signe un challenge TLS
avec sa clÃ© privÃ©e
end note
note right of TLS
VÃ©rifie :
* ValiditÃ© du CA
* Possession de la clÃ© privÃ©e via challenge
end note
TLS -> API : TLS OK, session Ã©tablie

== Appel API ==

Client -> API : GET /data\nAuthorization: Bearer eyJ...
API -> API : Extrait le certificat de TLS
API -> API : Calcule x5t#S256
API -> API : Compare avec cnf.x5t du token

alt Correspondance OK
  API -> Client : âœ… Donne la ressource
else Mauvaise clÃ© ou token volÃ©
  API -> Client : âŒ 401 Unauthorized
end
@enduml
----


==== ğŸ”„ Flux `/token` avec mTLS

[source,http]
----
POST /token
Host: auth.example.com
Content-Type: application/x-www-form-urlencoded

grant_type=client_credentials
&client_id=backend-app
&scope=read:data
----

âœ”ï¸ Il nâ€™y a **pas de `client_secret`**
âœ”ï¸ Le client prÃ©sente son **certificat X.509** lors du **handshake TLS**
âœ”ï¸ Dans tous les cas le serveur vÃ©rifie Ã  l'aide du challenge la possession de la clÃ© privÃ©e
âœ”ï¸ Dans le cas tls_signed_auth, l'autoritÃ© de certification valide la lÃ©gitimitÃ© du certificat, ce qui suffit Ã  l'obtention du token
âœ”ï¸ Dans le self_signed_tls_client_auth, le handshake tls ne vÃ©rifie pas la lÃ©gitimitÃ© du certificat, la clÃ© privÃ©e suffit Ã  valider le handshake. L'AS extrait immÃ©diatement aprÃ¨s la clÃ© publique du certificat et la compare avec les clÃ©s publiques connues et autorisÃ©es, si il y a match, le certificat est considÃ©rÃ© comme lÃ©gitime.
âœ”ï¸ Lâ€™AS gÃ©nÃ¨re l'emprunte du certificat et dÃ©livre un token liÃ© (avec le bon champ cnt.x5t contenant le hash signÃ© du certificat)

==== ğŸ§¾ Exemple dâ€™`access_token` JWT Ã©mis

[source,json]
----
{
  "sub": "backend-app",
  "aud": "https://api.example.com",
  "exp": 1723216000,
  "scope": "read:data",
  "cnf": {
    "x5t#S256": "FhS7ey5eTxN0GqR5twF7K1v0Vya8lJcvZP9ZT2aPjSo"
  }
}
----

Le champ `cnf.x5t#S256` contient :
- lâ€™empreinte SHA-256 du certificat **prÃ©sentÃ© Ã  `/token`**
- encodÃ©e en base64url (format conforme Ã  JWK Thumbprint)
- calculÃ© comme ceci en accord avec la RFC 7638: thumbprint = base64url(SHA-256(canonicalized certificate))

> Ce token ne pourra Ãªtre utilisÃ© **quâ€™avec ce mÃªme certificat** dans les appels aux APIs.

==== ğŸ“¡ Appel API avec access_token liÃ© (via mTLS)

[source,http]
----
GET /me HTTP/1.1
Host: api.example.com
Authorization: Bearer eyJhbGciOiJSUzI1NiIs...
----

âœ”ï¸ La requÃªte est faite **en HTTPS avec mTLS**
âœ”ï¸ Le **mÃªme certificat client** est prÃ©sentÃ© que lors de `/token`
âœ”ï¸ Le serveur API :
- extrait ce certificat de la session TLS
- calcule son empreinte SHA-256
- la compare Ã  `cnf.x5t#S256` dans le JWT

âœ… RequÃªte acceptÃ©e **uniquement si lâ€™empreinte correspond**

==== ğŸ§© DÃ©tail : les deux modes de mTLS dans OAuth

[cols="1,3a",options="header"]
|===
|Mode |Description

|tls_client_auth
|Certificat client signÃ© par une autoritÃ© de certification (CA) connue de lâ€™AS.

    Le client_id est fourni dans la requÃªte /token

    Lâ€™AS retrouve la liste de CA autorisÃ©es pour ce client

    Le certificat prÃ©sentÃ© doit Ãªtre signÃ© par une de ces CA

    Le handshake TLS valide la chaÃ®ne de confiance

    Lâ€™AS vÃ©rifie que le certificat est autorisÃ© pour ce client_id

|self_signed_tls_client_auth
|Certificat auto-signÃ© (pas de CA).

    Le client_id est aussi fourni dans la requÃªte /token

    Lâ€™AS a prÃ©enregistrÃ© la clÃ© publique exacte attendue pour ce client_id

    Lors du handshake, la TLS Layer ne vÃ©rifie pas la chaÃ®ne de confiance (mode permissif)

    Lâ€™AS extrait la clÃ© publique du certificat prÃ©sentÃ©

    Lâ€™AS compare cette clÃ© publique Ã  celle enregistrÃ©e pour ce client_id
|===

==== ğŸ§  Remarques

- ğŸ§¾ Le champ `cnf.x5t#S256` est une **empreinte SHA-256** du certificat client
- ğŸ” Le certificat **sert Ã  la fois dâ€™identifiant et de preuve de possession**
- âœ… Cela garantit que **seul le client qui possÃ¨de la clÃ© privÃ©e** du certificat peut utiliser le token
- âŒ MÃªme avec le token, un autre client **ne pourra pas lâ€™utiliser** sans ce certificat

==== ğŸ§  Pourquoi ne pas se contenter de mTLS â€œclassiqueâ€ ?

Parce que la validation TLS par le serveur HTTP (ex: NGINX, Envoy) ne suffit pas pour :
- garantir que **lâ€™access_token a Ã©tÃ© Ã©mis pour ce certificat**
- **lier le token** Ã  cette identitÃ© cryptographique

OAuth a donc dÃ©fini lâ€™inclusion explicite du `x5t#S256` dans le token, dans la claim `cnf` :
â†’ cela rend le token inutilisable **sans le certificat**.

==== ğŸ“ Clarification : le mot "mTLS" est ambigu

[NOTE]
====
âš ï¸ Dans OAuth, le terme â€œmTLSâ€ est parfois trompeur.

Il ne dÃ©signe **pas seulement** lâ€™usage du protocole mTLS (qui est gÃ©nÃ©rique),
mais **un ensemble de mÃ©canismes** spÃ©cifiques Ã  OAuth :

- Authentification du client OAuth via certificat (au lieu dâ€™un secret)
- Liaison du `access_token` au certificat (via `cnf.x5t#S256`)

Un nom plus explicite aurait pu Ãªtre :
`mTLS + certificate-bound access tokens`
Mais par usage, on parle simplement de â€œOAuth mTLSâ€.
====

==== ğŸ”¬ Comparaison mTLS vs DPoP

| Ã‰lÃ©ment                    | DPoP                          | mTLS                               |
|----------------------------|-------------------------------|------------------------------------|
| Objectif principal         | Prouver possession            | Authentifier et lier un token      |
| Preuve envoyÃ©e             | JWT signÃ©                     | Certificat client TLS              |
| Lien token â†” preuve        | `cnf.jwk`                     | `cnf.x5t#S256`                      |
| Certificat requis          | âŒ Non                        | âœ… Oui                             |
| CA ou validation externe   | âŒ Aucune                     | âœ… ChaÃ®ne de confiance requise     |
| Token rÃ©utilisable ailleurs| âŒ Non                        | âŒ Non                             |
| DÃ©ploiement web/mobile     | âœ… Facile                     | âŒ Difficile (certs sur mobile)    |

==== âœ… Bonnes pratiques

* Utiliser une CA interne dÃ©diÃ©e Ã  lâ€™Ã©cosystÃ¨me OAuth
* Refuser toute connexion sans certificat client mTLS
* Activer le **token binding** avec `cnf.x5t#S256`
* Mettre en place un mÃ©canisme de **revocation** (CRL ou OCSP)
* Restreindre la validitÃ© des certificats (rotation)
* Configurer lâ€™API pour extraire correctement le certificat (via NGINX ou TLS lib)

==== ğŸ“š SpÃ©cifications associÃ©es

* https://tools.ietf.org/html/rfc8705 â€“ OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound Access Tokens
* https://datatracker.ietf.org/doc/html/rfc7523 â€“ JWT Bearer Token Profiles (pour lier lâ€™identitÃ©)
* https://datatracker.ietf.org/doc/html/rfc7517 â€“ JSON Web Key (pour `cnf` structure)

=== ğŸ” FAPI â€“ Financial-grade API (OAuth 2.0 durci)

FAPI est une *spÃ©cification de lâ€™OpenID Foundation* visant Ã  sÃ©curiser les APIs sensibles (finance, santÃ©, identitÃ©â€¦).

Elle repose entiÃ¨rement sur OAuth 2.0, mais impose une *combinaison stricte de mÃ©canismes existants* pour renforcer lâ€™authentification, lâ€™intÃ©gritÃ©, la confidentialitÃ© et la non-rÃ©pudiation.

.Exigences de FAPI
[cols="1,4a",options="header"]
|===
|Ã‰lÃ©ment |RÃ´le

|*PKCE* (RFC 7636)
|EmpÃªche le vol du code d'autorisation

|*JAR* â€“ JWT Authorization Request
|Signature de la requÃªte `/authorize` (intÃ©gritÃ© + non-rÃ©pudiation)

|*JARM* â€“ JWT Authorization Response
|Signature de la rÃ©ponse Ã  `/authorize` (intÃ©gritÃ© + vÃ©rifiabilitÃ©)

|*mTLS* ou *DPoP*
|Preuve de possession du client + liaison des tokens (`cnf`)

|*Access Token liÃ© au certificat ou JWK*
|Via `cnf.x5t#S256` (mTLS) ou `cnf.jwk` (DPoP)

|*HTTP Message Signing*
|Protection des appels API contre la falsification

|*Scopes strictement limitÃ©s*
|Principe du moindre privilÃ¨ge renforcÃ©

|*Rotation obligatoire des refresh_token*
|RÃ©duction de l'impact en cas de vol

|*Pas de token rÃ©utilisable hors preuve*
|Les tokens liÃ©s Ã  un certificat ou une clÃ© privÃ©e ne peuvent pas Ãªtre rÃ©utilisÃ©s ailleurs
|===

[NOTE]
====
FAPI *nâ€™est pas un nouveau protocole*, mais un *profil de sÃ©curitÃ© OAuth 2.0 renforcÃ©*, souvent requis en Open Banking (Royaume-Uni, UEâ€¦).
====

ğŸ“– https://openid.net/fapi/[SpÃ©cification officielle]
