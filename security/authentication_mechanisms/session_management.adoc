:author-url: https://github.com/rridane
:author: rridane
:source-highlighter: rouge
:hardbreaks:
:table-caption!:
:toc: left
:toclevels: 3
:numbered:

= Session Management – Fiche complète

== 🧩 Définition et principes fondamentaux

La gestion de session est un mécanisme classique d’authentification où le serveur établit une session persistante après login. Cette session est identifiée par un identifiant stocké dans un cookie (`session_id`) envoyé à chaque requête.

[cols="1,3",options="header"]
|===
|Caractéristique |Description

|session_id       |Identifiant opaque généré par le serveur
|Stockage client  |Via un cookie (avec les bons drapeaux de sécurité)
|Stockage serveur |Mémoire, Redis, base SQL...
|Durée de vie     |Définie par le serveur (inactivité ou absolue)
|===

== 🧭 Vue d’ensemble du fonctionnement

[plantuml]
----
@startuml
actor "Utilisateur" as User
participant "Navigateur"
participant "Serveur" as Server
participant "SessionStore" as Store

User -> Navigateur : Saisie identifiants
Navigateur -> Server : POST /login (credentials)
Server -> Store : Crée une session (id, user_id...)
Server -> Navigateur : Set-Cookie: session_id=abc123

Navigateur -> Server : GET /dashboard (avec cookie)
Server -> Store : Récupère session_id
Server -> Navigateur : Contenu personnalisé
@enduml
----

== ⚙️ Cookie de session

[source,http]
----
Set-Cookie: session_id=abc123; HttpOnly; Secure; SameSite=Strict
----

[cols="1,3",options="header"]
|===
|Attribut |Explication

|HttpOnly  |Interdit l’accès JS au cookie (anti-XSS)
|Secure    |Transmis uniquement via HTTPS
|SameSite  |Empêche les requêtes intersites (anti-CSRF)
|Max-Age   |Durée de vie explicite (en secondes)
|Path      |URL concernée par le cookie
|===

== 🧾 Contenu type d’une session (côté serveur)

[source,json]
----
{
  "session_id": "abc123",
  "user_id": 42,
  "roles": ["admin"],
  "created_at": "2025-07-30T08:00:00Z",
  "expires_at": "2025-07-30T10:00:00Z",
  "csrf_token": "xyz456"
}
----

== 🔐 Sécurité des sessions

[cols="2,3",options="header"]
|===
|Problème |Contremesure

|Session Fixation  |Regénérer le session_id après login
|Session Hijacking |HttpOnly, Secure, rotation, scope IP
|CSRF              |SameSite + CSRF token
|===

== 🔁 Expiration & Logout

- *Idle Timeout* : expiration après inactivité
- *Expiration absolue* : durée maximale stricte (ex: 2h)
- *Logout* :
- Supprimer la session côté serveur
- Invalider le cookie côté client

[source,http]
----
Set-Cookie: session_id=; Max-Age=0; Path=/; HttpOnly
----

== 🔐 Protection CSRF

[source,html]
----
<form method="POST" action="/update">
  <input type="hidden" name="csrf_token" value="xyz456"/>
</form>
----

== Session Management en PHP – Exemples Complet

=== 📁 Structure

[source,plaintext]
----
/sessions/                  # stockage des sessions (si fichiers)
/login.php
/dashboard.php
/logout.php
/common.php
/login-session.php         # version avec session_start()
/dashboard-session.php
/logout-session.php
----

=== 🛠️ Version sans `session_start()` (gestion manuelle)

==== 📄 `login.php`

[source,php]
----
<?php
require_once 'common.php';

$users = [
  'bob' => 'secret123',
  'alice' => 'password',
];

$username = $_POST['username'] ?? '';
$password = $_POST['password'] ?? '';

if (!isset($users[$username]) || $users[$username] !== $password) {
    http_response_code(401);
    echo "Invalid credentials";
    exit;
}

// Génère un ID de session
$sessionId = bin2hex(random_bytes(32));
$csrfToken = bin2hex(random_bytes(32));

$sessionData = [
    'username' => $username,
    'csrf_token' => $csrfToken,
    'created_at' => time(),
];

file_put_contents(__DIR__ . "/sessions/$sessionId.json", json_encode($sessionData));

setcookie('session_id', $sessionId, [
    'expires' => time() + 3600,
    'path' => '/',
    'secure' => true,
    'httponly' => true,
    'samesite' => 'Strict',
]);

echo "Bienvenue $username – CSRF token : $csrfToken";
----
==== 📄 `dashboard.php`

[source,php]
----
<?php
require_once 'common.php';

$session = loadSession();
if (!$session) {
    http_response_code(401);
    echo "Non authentifié";
    exit;
}

echo "Bonjour " . htmlspecialchars($session['username']) . "<br>";
echo "Token CSRF attendu pour requêtes POST : " . $session['csrf_token'];
----

==== 📄 `logout.php`

[source,php]
----
<?php
require_once 'common.php';

$sessionId = $_COOKIE['session_id'] ?? null;
if ($sessionId) {
    @unlink(__DIR__ . "/sessions/$sessionId.json");
}

setcookie('session_id', '', [
    'expires' => time() - 3600,
    'path' => '/',
    'secure' => true,
    'httponly' => true,
    'samesite' => 'Strict',
]);

echo "Déconnecté";
----

==== 📄 `common.php`

[source,php]
----
<?php
function loadSession(): ?array {
    $sessionId = $_COOKIE['session_id'] ?? null;
    $file = __DIR__ . "/sessions/$sessionId.json";

    if (!$sessionId || !file_exists($file)) return null;

    $json = file_get_contents($file);
    return json_decode($json, true);
}

function validateCsrfToken(string $expected): bool {
    return ($_POST['csrf_token'] ?? '') === $expected;
}
----

=== 🔁 Formulaire sécurisé avec CSRF

[source,html]
----
<form action="/update-profile.php" method="POST">
  <input type="hidden" name="csrf_token" value="<!-- token dynamique ici -->" />
  <input type="text" name="email" />
  <button type="submit">Mettre à jour</button>
</form>
----

=== 🚀 Version équivalente avec `session_start()`

==== 📄 `login-session.php`

[source,php]
----
<?php
session_start();

$users = [
  'bob' => 'secret123',
  'alice' => 'password',
];

$username = $_POST['username'] ?? '';
$password = $_POST['password'] ?? '';

if (!isset($users[$username]) || $users[$username] !== $password) {
    http_response_code(401);
    echo "Identifiants invalides";
    exit;
}

session_regenerate_id(true);
$_SESSION['username'] = $username;
$_SESSION['csrf_token'] = bin2hex(random_bytes(32));
$_SESSION['created_at'] = time();

echo "Bienvenue $username – CSRF : " . $_SESSION['csrf_token'];
----

==== 📄 `dashboard-session.php`

[source,php]
----
<?php
session_start();

if (!isset($_SESSION['username'])) {
    http_response_code(401);
    echo "Non authentifié";
    exit;
}

echo "Bonjour " . htmlspecialchars($_SESSION['username']) . "<br>";
echo "CSRF attendu : " . $_SESSION['csrf_token'];
----

==== 📄 `logout-session.php`

[source,php]
----
<?php
session_start();
$_SESSION = [];
session_destroy();

setcookie('PHPSESSID', '', [
    'expires' => time() - 3600,
    'path' => '/',
    'secure' => true,
    'httponly' => true,
    'samesite' => 'Strict',
]);

echo "Déconnecté";
----

=== 🧪 Tests avec `curl`

[source,bash]
----
# Authentification (création session manuelle)
curl -c cookies.txt -X POST -d "username=bob&password=secret123" http://localhost/login.php

# Requête GET authentifiée
curl -b cookies.txt http://localhost/dashboard.php

# Déconnexion
curl -b cookies.txt http://localhost/logout.php
----

=== 🧠 Bonnes pratiques

- Toujours regénérer l’ID de session après login (`session_regenerate_id`)
- Supprimer la session côté serveur + cookie côté client au logout
- Protéger toutes les requêtes POST/PUT avec un `csrf_token`
- Utiliser `Secure`, `HttpOnly`, `SameSite=Strict` sur tous les cookies

=== 🔄 Stockage Redis (optionnel)

Remplace :

[source,php]
----
file_put_contents("sessions/$id.json", json_encode($data));
----

Par :

[source,php]
----
$redis->setex("session:$id", 3600, json_encode($data));
----

Lecture :

[source,php]
----
$data = $redis->get("session:$id");
----

=== 📚 Références

- https://www.php.net/manual/fr/function.session-start.php
- https://owasp.org/www-community/attacks/Session_fixation
- https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html


== 🧠 Backend stateful vs scalable

[cols="1,3",options="header"]
|===
|Type |Avantages / Limites

|En mémoire locale
|Simple mais non résilient, pas scalable

|Redis / PostgreSQL
|Partagé entre instances, TTL, scalable
|===

== ⚖️ Comparaison JWT vs Session

[cols="1,2,2",options="header"]
|===
|Critère |Session |JWT

|Stateless |❌ Non |✅ Oui
|Stockage serveur |✅ Oui |❌ Non
|Lisible côté client |❌ Non |✅ Oui (claims)
|Révocable facilement |✅ Oui |❌ Difficile
|Risques |Hijacking |Vol de token
|===

== ✅ Bonnes pratiques

- Toujours activer `HttpOnly`, `Secure`, `SameSite`
- Regénérer le session_id après login
- Utiliser CSRF tokens sur les requêtes sensibles
- Stocker les sessions dans Redis avec TTL
- Limiter durée de vie et inactivité

== 🔍 Tests manuels via curl

[source,bash]
----
# Login
curl -c cookies.txt -X POST -d "login=bob&password=secret" https://example.com/login

# Requête authentifiée
curl -b cookies.txt https://example.com/dashboard

# Logout
curl -b cookies.txt https://example.com/logout
----

== 📚 Références

- RFC 6265 – HTTP State Management
- https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html[OWASP – Session Management Cheat Sheet]
