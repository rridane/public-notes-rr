:author-url: https://github.com/rridane
:author: rridane
:source-highlighter: rouge
:hardbreaks:
:table-caption!:
:toc: left
:toclevels: 3
:numbered:

= Session Management â€“ Fiche complÃ¨te

== ğŸ§© DÃ©finition et principes fondamentaux

La gestion de session est un mÃ©canisme classique dâ€™authentification oÃ¹ le serveur Ã©tablit une session persistante aprÃ¨s login. Cette session est identifiÃ©e par un identifiant stockÃ© dans un cookie (`session_id`) envoyÃ© Ã  chaque requÃªte.

[cols="1,3",options="header"]
|===
|CaractÃ©ristique |Description

|session_id       |Identifiant opaque gÃ©nÃ©rÃ© par le serveur
|Stockage client  |Via un cookie (avec les bons drapeaux de sÃ©curitÃ©)
|Stockage serveur |MÃ©moire, Redis, base SQL...
|DurÃ©e de vie     |DÃ©finie par le serveur (inactivitÃ© ou absolue)
|===

== ğŸ§­ Vue dâ€™ensemble du fonctionnement

[plantuml]
----
@startuml
actor "Utilisateur" as User
participant "Navigateur"
participant "Serveur" as Server
participant "SessionStore" as Store

User -> Navigateur : Saisie identifiants
Navigateur -> Server : POST /login (credentials)
Server -> Store : CrÃ©e une session (id, user_id...)
Server -> Navigateur : Set-Cookie: session_id=abc123

Navigateur -> Server : GET /dashboard (avec cookie)
Server -> Store : RÃ©cupÃ¨re session_id
Server -> Navigateur : Contenu personnalisÃ©
@enduml
----

== âš™ï¸ Cookie de session

[source,http]
----
Set-Cookie: session_id=abc123; HttpOnly; Secure; SameSite=Strict
----

[cols="1,3",options="header"]
|===
|Attribut |Explication

|HttpOnly  |Interdit lâ€™accÃ¨s JS au cookie (anti-XSS)
|Secure    |Transmis uniquement via HTTPS
|SameSite  |EmpÃªche les requÃªtes intersites (anti-CSRF)
|Max-Age   |DurÃ©e de vie explicite (en secondes)
|Path      |URL concernÃ©e par le cookie
|===

== ğŸ§¾ Contenu type dâ€™une session (cÃ´tÃ© serveur)

[source,json]
----
{
  "session_id": "abc123",
  "user_id": 42,
  "roles": ["admin"],
  "created_at": "2025-07-30T08:00:00Z",
  "expires_at": "2025-07-30T10:00:00Z",
  "csrf_token": "xyz456"
}
----

== ğŸ” SÃ©curitÃ© des sessions

[cols="2,3",options="header"]
|===
|ProblÃ¨me |Contremesure

|Session Fixation  |RegÃ©nÃ©rer le session_id aprÃ¨s login
|Session Hijacking |HttpOnly, Secure, rotation, scope IP
|CSRF              |SameSite + CSRF token
|===

== ğŸ” Expiration & Logout

- *Idle Timeout* : expiration aprÃ¨s inactivitÃ©
- *Expiration absolue* : durÃ©e maximale stricte (ex: 2h)
- *Logout* :
- Supprimer la session cÃ´tÃ© serveur
- Invalider le cookie cÃ´tÃ© client

[source,http]
----
Set-Cookie: session_id=; Max-Age=0; Path=/; HttpOnly
----

== ğŸ” Protection CSRF

[source,html]
----
<form method="POST" action="/update">
  <input type="hidden" name="csrf_token" value="xyz456"/>
</form>
----

== Session Management en PHP â€“ Exemples Complet

=== ğŸ“ Structure

[source,plaintext]
----
/sessions/                  # stockage des sessions (si fichiers)
/login.php
/dashboard.php
/logout.php
/common.php
/login-session.php         # version avec session_start()
/dashboard-session.php
/logout-session.php
----

=== ğŸ› ï¸ Version sans `session_start()` (gestion manuelle)

==== ğŸ“„ `login.php`

[source,php]
----
<?php
require_once 'common.php';

$users = [
  'bob' => 'secret123',
  'alice' => 'password',
];

$username = $_POST['username'] ?? '';
$password = $_POST['password'] ?? '';

if (!isset($users[$username]) || $users[$username] !== $password) {
    http_response_code(401);
    echo "Invalid credentials";
    exit;
}

// GÃ©nÃ¨re un ID de session
$sessionId = bin2hex(random_bytes(32));
$csrfToken = bin2hex(random_bytes(32));

$sessionData = [
    'username' => $username,
    'csrf_token' => $csrfToken,
    'created_at' => time(),
];

file_put_contents(__DIR__ . "/sessions/$sessionId.json", json_encode($sessionData));

setcookie('session_id', $sessionId, [
    'expires' => time() + 3600,
    'path' => '/',
    'secure' => true,
    'httponly' => true,
    'samesite' => 'Strict',
]);

echo "Bienvenue $username â€“ CSRF token : $csrfToken";
----
==== ğŸ“„ `dashboard.php`

[source,php]
----
<?php
require_once 'common.php';

$session = loadSession();
if (!$session) {
    http_response_code(401);
    echo "Non authentifiÃ©";
    exit;
}

echo "Bonjour " . htmlspecialchars($session['username']) . "<br>";
echo "Token CSRF attendu pour requÃªtes POST : " . $session['csrf_token'];
----

==== ğŸ“„ `logout.php`

[source,php]
----
<?php
require_once 'common.php';

$sessionId = $_COOKIE['session_id'] ?? null;
if ($sessionId) {
    @unlink(__DIR__ . "/sessions/$sessionId.json");
}

setcookie('session_id', '', [
    'expires' => time() - 3600,
    'path' => '/',
    'secure' => true,
    'httponly' => true,
    'samesite' => 'Strict',
]);

echo "DÃ©connectÃ©";
----

==== ğŸ“„ `common.php`

[source,php]
----
<?php
function loadSession(): ?array {
    $sessionId = $_COOKIE['session_id'] ?? null;
    $file = __DIR__ . "/sessions/$sessionId.json";

    if (!$sessionId || !file_exists($file)) return null;

    $json = file_get_contents($file);
    return json_decode($json, true);
}

function validateCsrfToken(string $expected): bool {
    return ($_POST['csrf_token'] ?? '') === $expected;
}
----

=== ğŸ” Formulaire sÃ©curisÃ© avec CSRF

[source,html]
----
<form action="/update-profile.php" method="POST">
  <input type="hidden" name="csrf_token" value="<!-- token dynamique ici -->" />
  <input type="text" name="email" />
  <button type="submit">Mettre Ã  jour</button>
</form>
----

=== ğŸš€ Version Ã©quivalente avec `session_start()`

==== ğŸ“„ `login-session.php`

[source,php]
----
<?php
session_start();

$users = [
  'bob' => 'secret123',
  'alice' => 'password',
];

$username = $_POST['username'] ?? '';
$password = $_POST['password'] ?? '';

if (!isset($users[$username]) || $users[$username] !== $password) {
    http_response_code(401);
    echo "Identifiants invalides";
    exit;
}

session_regenerate_id(true);
$_SESSION['username'] = $username;
$_SESSION['csrf_token'] = bin2hex(random_bytes(32));
$_SESSION['created_at'] = time();

echo "Bienvenue $username â€“ CSRF : " . $_SESSION['csrf_token'];
----

==== ğŸ“„ `dashboard-session.php`

[source,php]
----
<?php
session_start();

if (!isset($_SESSION['username'])) {
    http_response_code(401);
    echo "Non authentifiÃ©";
    exit;
}

echo "Bonjour " . htmlspecialchars($_SESSION['username']) . "<br>";
echo "CSRF attendu : " . $_SESSION['csrf_token'];
----

==== ğŸ“„ `logout-session.php`

[source,php]
----
<?php
session_start();
$_SESSION = [];
session_destroy();

setcookie('PHPSESSID', '', [
    'expires' => time() - 3600,
    'path' => '/',
    'secure' => true,
    'httponly' => true,
    'samesite' => 'Strict',
]);

echo "DÃ©connectÃ©";
----

=== ğŸ§ª Tests avec `curl`

[source,bash]
----
# Authentification (crÃ©ation session manuelle)
curl -c cookies.txt -X POST -d "username=bob&password=secret123" http://localhost/login.php

# RequÃªte GET authentifiÃ©e
curl -b cookies.txt http://localhost/dashboard.php

# DÃ©connexion
curl -b cookies.txt http://localhost/logout.php
----

=== ğŸ§  Bonnes pratiques

- Toujours regÃ©nÃ©rer lâ€™ID de session aprÃ¨s login (`session_regenerate_id`)
- Supprimer la session cÃ´tÃ© serveur + cookie cÃ´tÃ© client au logout
- ProtÃ©ger toutes les requÃªtes POST/PUT avec un `csrf_token`
- Utiliser `Secure`, `HttpOnly`, `SameSite=Strict` sur tous les cookies

=== ğŸ”„ Stockage Redis (optionnel)

Remplace :

[source,php]
----
file_put_contents("sessions/$id.json", json_encode($data));
----

Par :

[source,php]
----
$redis->setex("session:$id", 3600, json_encode($data));
----

Lecture :

[source,php]
----
$data = $redis->get("session:$id");
----

=== ğŸ“š RÃ©fÃ©rences

- https://www.php.net/manual/fr/function.session-start.php
- https://owasp.org/www-community/attacks/Session_fixation
- https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html


== ğŸ§  Backend stateful vs scalable

[cols="1,3",options="header"]
|===
|Type |Avantages / Limites

|En mÃ©moire locale
|Simple mais non rÃ©silient, pas scalable

|Redis / PostgreSQL
|PartagÃ© entre instances, TTL, scalable
|===

== âš–ï¸ Comparaison JWT vs Session

[cols="1,2,2",options="header"]
|===
|CritÃ¨re |Session |JWT

|Stateless |âŒ Non |âœ… Oui
|Stockage serveur |âœ… Oui |âŒ Non
|Lisible cÃ´tÃ© client |âŒ Non |âœ… Oui (claims)
|RÃ©vocable facilement |âœ… Oui |âŒ Difficile
|Risques |Hijacking |Vol de token
|===

== âœ… Bonnes pratiques

- Toujours activer `HttpOnly`, `Secure`, `SameSite`
- RegÃ©nÃ©rer le session_id aprÃ¨s login
- Utiliser CSRF tokens sur les requÃªtes sensibles
- Stocker les sessions dans Redis avec TTL
- Limiter durÃ©e de vie et inactivitÃ©

== ğŸ” Tests manuels via curl

[source,bash]
----
# Login
curl -c cookies.txt -X POST -d "login=bob&password=secret" https://example.com/login

# RequÃªte authentifiÃ©e
curl -b cookies.txt https://example.com/dashboard

# Logout
curl -b cookies.txt https://example.com/logout
----

== ğŸ“š RÃ©fÃ©rences

- RFC 6265 â€“ HTTP State Management
- https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html[OWASP â€“ Session Management Cheat Sheet]
