:author-url: https://github.com/rridane
:author: rridane
:source-highlighter: rouge
:hardbreaks:
:table-caption!:
:toc: left
:toclevels: 3
:numbered:

= OpenID Connect – Fiche complète

== 🔑 Qu’est-ce qu’OpenID Connect ?

OpenID Connect (OIDC) est une surcouche d’authentification construite sur OAuth 2.0.
Il permet à un client de :
- vérifier l’identité d’un utilisateur,
- obtenir ses informations de profil,
- tout en bénéficiant des protections et flux OAuth 2.0.

[source,text]
OAuth = délégation d’accès
OIDC  = + identité de l’utilisateur

== 📦 Apports clés d’OIDC

OpenID Connect n’ajoute pas de nouveau champ à OAuth 2.0,
mais en étend certains usages, en particulier `scope`.

=== ✅ En synthèse, OIDC apporte :

* 🎯 Une **valeur de scope** standardisée : `openid`
→ indispensable pour activer les fonctionnalités d’authentification OIDC
* 🎟️ Un **nouveau type de token** : `id_token` (JWT signé contenant l’identité de l’utilisateur)
* 🌐 Des **endpoints supplémentaires** :
- `/.well-known/openid-configuration` (discovery dynamique)
- `/userinfo` (profil utilisateur à jour)

=== 🔎 Détail : le champ `scope` n’est pas nouveau

Le champ `scope` existait déjà dans OAuth 2.0 :
il permettait au client de demander des autorisations spécifiques pour accéder à l’API.

OIDC **étend ce champ** avec des valeurs standardisées qui activent des fonctionnalités OIDC.

[cols="1,3",options="header"]
|===
| Scope             | Description
| `openid`          | 🔐 Active le mode OpenID Connect → déclenche la délivrance d’un `id_token`
| `profile`         | 📄 Demande les claims de profil utilisateur (nom, prénom, etc.)
| `email`           | ️Demande l’adresse email (`email`, `email_verified`)
| `address`         | Demande l'adresse postale
| `phone`           | Demande le numéro de téléphone + statut de vérification
| `offline_access`  | Demande un `refresh_token` pour renouveler les tokens sans interaction
|===

[IMPORTANT]
====
Si `openid` est **absent**, la requête est traitée comme du **pur OAuth 2.0**
→ Aucune fonction OIDC ne sera déclenchée (pas de `id_token`, pas de `/userinfo`).

Si `profile` est **absent**, les claims de profil **ne seront pas retournés**.
====

=== 📦 Champs retournés selon les `scope` demandés

Le serveur d'autorisation retourne différents éléments selon les scopes demandés.
Certains champs sont toujours présents (`access_token`, `expires_in`), d'autres sont conditionnels (`id_token`, `refresh_token`, claims...).

[cols="1,2,2",options="header"]
|===
| Champ            | Déclenché par         | Description

| `access_token`   | Tous les flux OAuth   | Jeton d’accès à l’API (Bearer token)
| `expires_in`     | Tous les flux OAuth   | Durée de vie de l’`access_token` (en secondes)
| `scope`          | Tous les flux OAuth   | Scopes réellement accordés par l’AS

| `id_token`       | `scope=openid`        | JWT signé contenant l’identité de l’utilisateur
| `refresh_token`  | `scope=offline_access` + flux autorisé | Jeton longue durée permettant d’obtenir un nouvel `access_token`
|===

[TIP]
====
- Le `refresh_token` est généralement délivré si le `response_type` est `code` (pas `implicit`),
et si le client est configuré pour l’autoriser côté serveur.
====

=== 🧬 Claims retournés selon les `scope` OIDC

Les scopes `profile`, `email`, `address`, `phone` permettent de demander des informations spécifiques sur l’utilisateur.
Ces claims peuvent apparaître dans le `id_token` (Voir ci dessous) ou être disponibles via le endpoint `/userinfo` selon la configuration du serveur.

[cols="1,2,3",options="header"]
|===
| Scope         | Claims possibles                 | Description

| `openid`      | `sub`                            | Identifiant unique de l’utilisateur (obligatoire)
|               | *(+ autres claims selon config)* | Certains serveurs ajoutent `email`, `name`, etc. par défaut dans `id_token`

| `profile`     | `name`                           | Nom complet
|               | `given_name`                     | Prénom
|               | `family_name`                    | Nom de famille
|               | `middle_name`                    | Deuxième prénom
|               | `nickname`                       | Surnom
|               | `preferred_username`             | Identifiant court ou pseudo
|               | `profile`                        | URL du profil (ex : réseaux sociaux)
|               | `picture`                        | URL de la photo de profil
|               | `website`                        | URL personnelle
|               | `gender`                         | Sexe
|               | `birthdate`                      | Date de naissance (ISO 8601)
|               | `zoneinfo`                       | Fuseau horaire (ex : "Europe/Paris")
|               | `locale`                         | Langue préférée (ex : "fr-FR")
|               | `updated_at`                     | Date de dernière mise à jour du profil (timestamp)

| `email`       | `email`                          | Adresse email
|               | `email_verified`                 | Booléen indiquant si l’email a été vérifié

| `address`     | `address`                        | Objet JSON avec :
- `formatted`
- `street_address`
- `locality`
- `region`
- `postal_code`
- `country`

| `phone`       | `phone_number`                   | Numéro de téléphone
|               | `phone_number_verified`          | Booléen indiquant si le numéro a été vérifié
|===

[NOTE]
====
👉 Le contenu exact dépend des scopes demandés, de la configuration du serveur et du consentement de l’utilisateur.
Tous les claims ne sont pas systématiquement présents, même si le scope est demandé.
====

=== 🔐 Claims liés à l’authentification (`acr`, `amr`, `auth_time`)

Certains claims renseignent **le contexte de l’authentification** de l’utilisateur. Ils sont utiles pour tracer la sécurité du login, vérifier qu’une authentification forte a été utilisée, ou satisfaire à des contraintes réglementaires (ex : authentification MFA, durée de session…).

[source,json]
----
{
  "acr": "urn:mace:incommon:iap:silver",
  "amr": ["pwd", "mfa"],
  "auth_time": 1709999400
}
----

[cols="1,3",options="header"]
|===
| Claim        | Description

| `acr`        | *Authentication Context Class Reference* – Niveau d’authentification atteint (ex : `urn:mace:...:silver`)
| `amr`        | *Authentication Methods References* – Liste des méthodes utilisées (`pwd`, `otp`, `mfa`, etc.)
| `auth_time`  | *Authentication Time* – Timestamp (epoch) de l’heure d’authentification initiale
|===

=== 📥 Comment obtenir ces claims ?

Ces claims **ne dépendent pas d’un scope** comme `profile` ou `email`.

- Ils sont disponibles uniquement si `scope=openid` est présent.
- Ils peuvent être inclus **automatiquement** dans le `id_token` selon la configuration du serveur.
- Pour forcer leur présence, on peut utiliser le paramètre `claims` dans la requête `/authorize` :

[source,http]
----
GET /authorize?
client_id=client123&
response_type=code&
scope=openid&
claims={"id_token":{"acr":{"essential":true},"auth_time":{"essential":true}}}
----

=== 📌 Support selon le fournisseur

[cols="1,3",options="header"]
|===
| Fournisseur OIDC | Support des claims `acr`, `amr`, `auth_time`

| Keycloak         | ✅ Oui, configurable (flows, policies)
| Auth0            | ✅ Oui, `amr`, `auth_time` par défaut ; `acr` sur demande
| Azure AD         | ✅ Oui, surtout `amr` ; `acr` selon contexte
| Okta             | ✅ Oui, avec configuration
| Google Identity  | ❌ Généralement non présents (sauf cas spécifiques)
|===

[TIP]
====
Ces claims sont précieux pour :
- les audits de sécurité,
- la vérification de MFA (`amr` contient `mfa`),
- la contrainte d’expiration (`max_age`) à partir de `auth_time`.
====

=== 💡 Exemple de requête `/authorize` avec tous les scopes

[source,http]
----
GET /authorize?
client_id=client123&
response_type=code&
redirect_uri=https://app.com/callback&
scope=openid profile email offline_access&
state=abc123&
nonce=xyz456
----

* `scope=openid` → Active OIDC, nécessaire pour avoir un `id_token`
* `profile`, `email` → Demande des infos utilisateur
* `offline_access` → Demande un `refresh_token`

== 📥 Exemple de réponse `/token` incluant tous les éléments

Après avoir reçu le `code`, le client fait un `POST /token` :

[source,http]
----
POST /token
Content-Type: application/x-www-form-urlencoded

grant_type=authorization_code&
code=SplxlOBeZQQYbYS6WxSbIA&
redirect_uri=https://app.com/callback&
client_id=client123&
code_verifier=dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk
----

Réponse typique :

[source,json]
----
{
  "access_token": "eyJhbGciOiJSUzI1NiIsInR...",
  "id_token": "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...",
  "refresh_token": "def456uvw",
  "expires_in": 3600,
  "token_type": "Bearer",
  "scope": "openid profile email offline_access"
}
----

== 🧾 Détail du `id_token` – Token d'identité

L’`id_token` est un **JWT signé** qui contient des informations d’identité sur l’utilisateur.
Il ne donne pas accès à une API, mais permet au client de **savoir qui est connecté**, de manière **vérifiable localement**.

=== 🎯 Différences fondamentales

[cols="1,2,2",options="header"]
|===
| Élément       | `id_token` (OIDC)                     | `access_token` (OAuth)

| Objectif      | Authentifier l’utilisateur             | Autoriser un accès à une ressource
| Utilisé par   | Le client (SPA, backend, mobile…)      | L’API (backend de ressource)
| Format        | JWT signé (toujours)                   | JWT ou opaque
| Transport     | Jamais dans `Authorization`            | Oui → `Authorization: Bearer ...`
| Vérification  | Par le client                          | Par l’API destinataire
| Issu si ?     | `scope=openid`                         | Tout flux OAuth (client_credentials, etc.)
|===

=== 🧬 Exemple de `id_token` décodé

==== En-tête
[source,json]
----
{
  "alg": "RS256",
  "typ": "JWT",
  "kid": "auth-key-1"
}
----

==== Payload
[source,json]
----
{
  "iss": "https://auth.example.com",
  "sub": "user_123",
  "aud": "client123",
  "exp": 1710000000,
  "iat": 1709999400,
  "nonce": "xyz456",
  "email": "user@example.com",
  "email_verified": true,
  "name": "Jean Dupont"
}
----

[cols="1,3",options="header"]
|===
| Claim | Description

| `iss` | Issuer : URL du serveur d'autorisation
| `sub` | Subject : identifiant unique de l’utilisateur
| `aud` | Audience : le `client_id` à qui est destiné ce token
| `exp` / `iat` | Dates d’expiration / d’émission
| `nonce` | Jeton anti-rejeu généré par le client (doit être vérifié)
| `email`, `name` | Claims issus des scopes demandés (`email`, `profile`, etc.)
|===

[TIP]
====
Le client doit :
- vérifier la **signature du JWT** (`jwks_uri`)
- vérifier les valeurs de `aud`, `iss`, `exp`
- valider que `nonce` correspond à celui envoyé à `/authorize`
====

[NOTE]
====
👉 L’`id_token` est le cœur du mécanisme d’authentification de l’utilisateur en OIDC.
Il permet de **vérifier une session sans faire d’appel au serveur**, contrairement à `/userinfo`.

ℹ️ Le endpoint `/userinfo` retourne des informations **plus fraîches**, utiles si le `id_token` est partiel ou ancien.
====

=== 🔐 Validation du id_token

1. Récupérer la clé publique via `jwks_uri`
2. Vérifier la **signature** du JWT
3. Valider les claims suivants :
- `iss` == issuer attendu
- `aud` == client_id
- `exp` non expiré
- `nonce` correspond à celui fourni

[NOTE]
====
Certains serveurs mettent toutes les informations dans id_token, rendant /userinfo inutile (si ce n'est pour s'assurer que les informations sont à jour)
====


== 🔁 Comparaison OAuth 2.0 / OIDC

[cols="1,1,1",options="header"]
|===
| Élément             | OAuth 2.0        | OIDC

| Objectif            | Autoriser l’accès à une ressource | Authentifier l’utilisateur
| Token principal     | access_token     | id_token (+ access_token)
| Fournit l’identité ?| ❌ Non            | ✅ Oui
| SSO                 | ❌ Non            | ✅ Oui
|===

== 🔐 Sécurité – Le `nonce`

Permet de se prémunir contre les attaques de rejeu :
- Le client génère un `nonce` à l’étape `/authorize`
- Le serveur le renvoie dans le `id_token`
- Le client **doit vérifier** que la valeur correspond

== 🧭 Flux complet OIDC (Authorization Code + PKCE)

[plantuml]
----
@startuml
actor "Utilisateur" as User
participant "App (SPA / mobile)" as App
participant "Authorization Server / IdP" as AS

== Étape 1 – /authorize ==
App -> AS : GET /authorize?client_id=...&scope=openid profile&nonce=abc...

AS -> User : Formulaire de login

User -> AS : Login
AS -> App : Redirection /callback?code=xyz&state=...

== Étape 2 – /token ==
App -> AS : POST /token + code + code_verifier
AS -> App : access_token + id_token + refresh_token

== Étape 3 – /userinfo ==
App -> AS : GET /userinfo (avec access_token)
AS -> App : JSON : nom, email, etc.
@enduml
----

== 🔁 Fonctionnement du `refresh_token`

Le `refresh_token` :
- permet de **prolonger une session** sans que l’utilisateur ne se reconnecte,
- est obtenu **uniquement si le scope `offline_access` a été demandé**,
- peut être **refusé** par le serveur (ex: clients publics JS, configuration IdP...),
- est **rotatif** sur certains serveurs : chaque utilisation en invalide l’ancien.

=== 🧭 Flux d’échange du refresh_token

[source,http]
----
POST /token
Content-Type: application/x-www-form-urlencoded

grant_type=refresh_token&
client_id=client123&
refresh_token=def456uvw
----

Réponse typique (rotation activée) :

[source,json]
----
{
  "access_token": "eyJhbGciOiJIUzI1NiIs...",
  "id_token": "eyJhbGciOiJSUzI1NiIs...",
  "refresh_token": "ghi789rst", // nouveau
  "expires_in": 3600,
  "token_type": "Bearer"
}
----

[NOTE]
====
* Certains serveurs n’émettent un nouveau `id_token` que si demandé via un paramètre (`scope`, `openid`, etc.)
* Si la **rotation est activée**, l’ancien `refresh_token` est invalidé après usage
* Si elle ne l’est pas, le même `refresh_token` peut être réutilisé plusieurs fois (⚠️ risqué)
====

=== ✅ Bonnes pratiques avec les refresh_token

* Toujours chiffrer le stockage local (Keychain, Keystore, DB chiffrée)
* Ne jamais exposer un refresh_token dans un navigateur JS ou localStorage
* Préférer des `refresh_token` liés à une session ou un appareil unique
* Révoquer les refresh_token au logout
* Utiliser la rotation si disponible

== 🔐 Sécurité par type de client

[cols="1,2",options="header"]
|===
| Type de client           | Stockage recommandé pour `refresh_token`

| SPA (JavaScript)         | ⚠️ Déconseillé – utiliser plutôt cookie HttpOnly sécurisé
| Application mobile       | ✅ Keystore (Android) / Keychain (iOS)
| Client backend confidentiel | ✅ Base de données sécurisée, chiffrée
|===


== 🔍 Discovery – /.well-known/openid-configuration

[source,http]
----
GET /.well-known/openid-configuration
----

[source,json]
----
{
  "issuer": "https://auth.example.com",
  "authorization_endpoint": ".../authorize",
  "token_endpoint": ".../token",
  "userinfo_endpoint": ".../userinfo",
  "jwks_uri": ".../.well-known/jwks.json",
  "response_types_supported": ["code", "id_token"],
  "id_token_signing_alg_values_supported": ["RS256"]
}
----

== 📥 /userinfo – Profil utilisateur

[source,http]
----
GET /userinfo
Authorization: Bearer <access_token>
----

[source,json]
----
{
  "sub": "user_123",
  "email": "user@example.com",
  "name": "Jean Dupont"
}
----

=== 📋 Liste des claims retournés par `/userinfo`

Les claims retournés par `/userinfo` dépendent :
- des `scopes` demandés (`profile`, `email`, etc.)
- des claims disponibles et autorisés pour le client

Exemple de réponse :
[source,json]
----
{
  "sub": "user_123",
  "name": "Jean Dupont",
  "email": "jean.dupont@example.com",
  "email_verified": true,
  "locale": "fr-FR",
  "updated_at": 1712345678
}
----

[NOTE]
====
Le contenu du `id_token` et du `/userinfo` peut être personnalisé côté serveur :
- via des **mappers** (ex : Keycloak)
- via des **règles ou hooks** (ex : Auth0 Rules)
====

== 💡 Autres endpoints OIDC (optionnels)

[cols="1,3",options="header"]
|===
| Endpoint | Description

| `/logout` ou `/end_session` | Permet de déclencher une déconnexion centralisée (SSO) du serveur IdP
| `/check_session` | Permet de vérifier via iframe que la session IdP est toujours active (rarement utilisé)
| `/introspect` | Endpoint OAuth utilisé pour vérifier un token opaque (non JWT)
| `/revocation` | Pour invalider un access_token ou refresh_token manuellement
| `/jwks.json` | Contient les clés publiques utilisées pour vérifier la signature des `id_token`
|===

[TIP]
====
Les endpoints `/logout`, `/check_session`, etc., sont surtout utilisés dans des architectures SSO complexes (ex: avec Keycloak, Azure AD, etc.).
====

== 🔐 SSO & OIDC

OIDC permet le **Single Sign-On** :
- L’utilisateur s’authentifie une seule fois
- Plusieurs apps clientes configurées sur le même IdP peuvent en bénéficier
- Via les cookies de session gérés côté IdP

== ⚠️ Vulnérabilités connues

[cols="1,2",options="header"]
|===
| Problème | Contremesure

| Vol du id_token dans l’URL | Éviter `response_type=id_token`
| Rejeu du token | Vérifier `nonce`
| Mauvaise audience ou émetteur | Vérifier `aud`, `iss`
|===

== ✅ Bonnes pratiques

* Toujours vérifier la signature du `id_token`
* Utiliser Authorization Code + PKCE
* Ne jamais exposer le `id_token` dans un navigateur sans vérification
* Stocker les tokens de manière sécurisée (WebCrypto / secure storage)
* Rafraîchir les tokens avec `offline_access`, pas avec les identifiants

== 📚 Spécifications

* https://openid.net/specs/openid-connect-core-1_0.html
* https://openid.net/specs/openid-connect-discovery-1_0.html
* https://openid.net/specs/openid-connect-session-1_0.html
* https://openid.net/specs/openid-connect-frontchannel-1_0.html
* https://openid.net/specs/openid-connect-backchannel-1_0.html
