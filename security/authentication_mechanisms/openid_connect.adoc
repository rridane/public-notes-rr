:author-url: https://github.com/rridane
:author: rridane
:source-highlighter: rouge
:hardbreaks:
:table-caption!:
:toc: left
:toclevels: 3
:numbered:

= OpenID Connect â€“ Fiche complÃ¨te

== ğŸ”‘ Quâ€™est-ce quâ€™OpenID Connect ?

OpenID Connect (OIDC) est une surcouche dâ€™authentification construite sur OAuth 2.0.
Il permet Ã  un client de :
- vÃ©rifier lâ€™identitÃ© dâ€™un utilisateur,
- obtenir ses informations de profil,
- tout en bÃ©nÃ©ficiant des protections et flux OAuth 2.0.

[source,text]
OAuth = dÃ©lÃ©gation dâ€™accÃ¨s
OIDC  = + identitÃ© de lâ€™utilisateur

== ğŸ“¦ Apports clÃ©s dâ€™OIDC

OpenID Connect nâ€™ajoute pas de nouveau champ Ã  OAuth 2.0,
mais en Ã©tend certains usages, en particulier `scope`.

=== âœ… En synthÃ¨se, OIDC apporte :

* ğŸ¯ Une **valeur de scope** standardisÃ©e : `openid`
â†’ indispensable pour activer les fonctionnalitÃ©s dâ€™authentification OIDC
* ğŸŸï¸ Un **nouveau type de token** : `id_token` (JWT signÃ© contenant lâ€™identitÃ© de lâ€™utilisateur)
* ğŸŒ Des **endpoints supplÃ©mentaires** :
- `/.well-known/openid-configuration` (discovery dynamique)
- `/userinfo` (profil utilisateur Ã  jour)

=== ğŸ” DÃ©tail : le champ `scope` nâ€™est pas nouveau

Le champ `scope` existait dÃ©jÃ  dans OAuth 2.0 :
il permettait au client de demander des autorisations spÃ©cifiques pour accÃ©der Ã  lâ€™API.

OIDC **Ã©tend ce champ** avec des valeurs standardisÃ©es qui activent des fonctionnalitÃ©s OIDC.

[cols="1,3",options="header"]
|===
| Scope             | Description
| `openid`          | ğŸ” Active le mode OpenID Connect â†’ dÃ©clenche la dÃ©livrance dâ€™un `id_token`
| `profile`         | ğŸ“„ Demande les claims de profil utilisateur (nom, prÃ©nom, etc.)
| `email`           | ï¸Demande lâ€™adresse email (`email`, `email_verified`)
| `address`         | Demande l'adresse postale
| `phone`           | Demande le numÃ©ro de tÃ©lÃ©phone + statut de vÃ©rification
| `offline_access`  | Demande un `refresh_token` pour renouveler les tokens sans interaction
|===

[IMPORTANT]
====
Si `openid` est **absent**, la requÃªte est traitÃ©e comme du **pur OAuth 2.0**
â†’ Aucune fonction OIDC ne sera dÃ©clenchÃ©e (pas de `id_token`, pas de `/userinfo`).

Si `profile` est **absent**, les claims de profil **ne seront pas retournÃ©s**.
====

=== ğŸ“¦ Champs retournÃ©s selon les `scope` demandÃ©s

Le serveur d'autorisation retourne diffÃ©rents Ã©lÃ©ments selon les scopes demandÃ©s.
Certains champs sont toujours prÃ©sents (`access_token`, `expires_in`), d'autres sont conditionnels (`id_token`, `refresh_token`, claims...).

[cols="1,2,2",options="header"]
|===
| Champ            | DÃ©clenchÃ© par         | Description

| `access_token`   | Tous les flux OAuth   | Jeton dâ€™accÃ¨s Ã  lâ€™API (Bearer token)
| `expires_in`     | Tous les flux OAuth   | DurÃ©e de vie de lâ€™`access_token` (en secondes)
| `scope`          | Tous les flux OAuth   | Scopes rÃ©ellement accordÃ©s par lâ€™AS

| `id_token`       | `scope=openid`        | JWT signÃ© contenant lâ€™identitÃ© de lâ€™utilisateur
| `refresh_token`  | `scope=offline_access` + flux autorisÃ© | Jeton longue durÃ©e permettant dâ€™obtenir un nouvel `access_token`
|===

[TIP]
====
- Le `refresh_token` est gÃ©nÃ©ralement dÃ©livrÃ© si le `response_type` est `code` (pas `implicit`),
et si le client est configurÃ© pour lâ€™autoriser cÃ´tÃ© serveur.
====

=== ğŸ§¬ Claims retournÃ©s selon les `scope` OIDC

Les scopes `profile`, `email`, `address`, `phone` permettent de demander des informations spÃ©cifiques sur lâ€™utilisateur.
Ces claims peuvent apparaÃ®tre dans le `id_token` (Voir ci dessous) ou Ãªtre disponibles via le endpoint `/userinfo` selon la configuration du serveur.

[cols="1,2,3",options="header"]
|===
| Scope         | Claims possibles                 | Description

| `openid`      | `sub`                            | Identifiant unique de lâ€™utilisateur (obligatoire)
|               | *(+ autres claims selon config)* | Certains serveurs ajoutent `email`, `name`, etc. par dÃ©faut dans `id_token`

| `profile`     | `name`                           | Nom complet
|               | `given_name`                     | PrÃ©nom
|               | `family_name`                    | Nom de famille
|               | `middle_name`                    | DeuxiÃ¨me prÃ©nom
|               | `nickname`                       | Surnom
|               | `preferred_username`             | Identifiant court ou pseudo
|               | `profile`                        | URL du profil (ex : rÃ©seaux sociaux)
|               | `picture`                        | URL de la photo de profil
|               | `website`                        | URL personnelle
|               | `gender`                         | Sexe
|               | `birthdate`                      | Date de naissance (ISO 8601)
|               | `zoneinfo`                       | Fuseau horaire (ex : "Europe/Paris")
|               | `locale`                         | Langue prÃ©fÃ©rÃ©e (ex : "fr-FR")
|               | `updated_at`                     | Date de derniÃ¨re mise Ã  jour du profil (timestamp)

| `email`       | `email`                          | Adresse email
|               | `email_verified`                 | BoolÃ©en indiquant si lâ€™email a Ã©tÃ© vÃ©rifiÃ©

| `address`     | `address`                        | Objet JSON avec :
- `formatted`
- `street_address`
- `locality`
- `region`
- `postal_code`
- `country`

| `phone`       | `phone_number`                   | NumÃ©ro de tÃ©lÃ©phone
|               | `phone_number_verified`          | BoolÃ©en indiquant si le numÃ©ro a Ã©tÃ© vÃ©rifiÃ©
|===

[NOTE]
====
ğŸ‘‰ Le contenu exact dÃ©pend des scopes demandÃ©s, de la configuration du serveur et du consentement de lâ€™utilisateur.
Tous les claims ne sont pas systÃ©matiquement prÃ©sents, mÃªme si le scope est demandÃ©.
====

=== ğŸ” Claims liÃ©s Ã  lâ€™authentification (`acr`, `amr`, `auth_time`)

Certains claims renseignent **le contexte de lâ€™authentification** de lâ€™utilisateur. Ils sont utiles pour tracer la sÃ©curitÃ© du login, vÃ©rifier quâ€™une authentification forte a Ã©tÃ© utilisÃ©e, ou satisfaire Ã  des contraintes rÃ©glementaires (ex : authentification MFA, durÃ©e de sessionâ€¦).

[source,json]
----
{
  "acr": "urn:mace:incommon:iap:silver",
  "amr": ["pwd", "mfa"],
  "auth_time": 1709999400
}
----

[cols="1,3",options="header"]
|===
| Claim        | Description

| `acr`        | *Authentication Context Class Reference* â€“ Niveau dâ€™authentification atteint (ex : `urn:mace:...:silver`)
| `amr`        | *Authentication Methods References* â€“ Liste des mÃ©thodes utilisÃ©es (`pwd`, `otp`, `mfa`, etc.)
| `auth_time`  | *Authentication Time* â€“ Timestamp (epoch) de lâ€™heure dâ€™authentification initiale
|===

=== ğŸ“¥ Comment obtenir ces claims ?

Ces claims **ne dÃ©pendent pas dâ€™un scope** comme `profile` ou `email`.

- Ils sont disponibles uniquement si `scope=openid` est prÃ©sent.
- Ils peuvent Ãªtre inclus **automatiquement** dans le `id_token` selon la configuration du serveur.
- Pour forcer leur prÃ©sence, on peut utiliser le paramÃ¨tre `claims` dans la requÃªte `/authorize` :

[source,http]
----
GET /authorize?
client_id=client123&
response_type=code&
scope=openid&
claims={"id_token":{"acr":{"essential":true},"auth_time":{"essential":true}}}
----

=== ğŸ“Œ Support selon le fournisseur

[cols="1,3",options="header"]
|===
| Fournisseur OIDC | Support des claims `acr`, `amr`, `auth_time`

| Keycloak         | âœ… Oui, configurable (flows, policies)
| Auth0            | âœ… Oui, `amr`, `auth_time` par dÃ©faut ; `acr` sur demande
| Azure AD         | âœ… Oui, surtout `amr` ; `acr` selon contexte
| Okta             | âœ… Oui, avec configuration
| Google Identity  | âŒ GÃ©nÃ©ralement non prÃ©sents (sauf cas spÃ©cifiques)
|===

[TIP]
====
Ces claims sont prÃ©cieux pour :
- les audits de sÃ©curitÃ©,
- la vÃ©rification de MFA (`amr` contient `mfa`),
- la contrainte dâ€™expiration (`max_age`) Ã  partir de `auth_time`.
====

=== ğŸ’¡ Exemple de requÃªte `/authorize` avec tous les scopes

[source,http]
----
GET /authorize?
client_id=client123&
response_type=code&
redirect_uri=https://app.com/callback&
scope=openid profile email offline_access&
state=abc123&
nonce=xyz456
----

* `scope=openid` â†’ Active OIDC, nÃ©cessaire pour avoir un `id_token`
* `profile`, `email` â†’ Demande des infos utilisateur
* `offline_access` â†’ Demande un `refresh_token`

== ğŸ“¥ Exemple de rÃ©ponse `/token` incluant tous les Ã©lÃ©ments

AprÃ¨s avoir reÃ§u le `code`, le client fait un `POST /token` :

[source,http]
----
POST /token
Content-Type: application/x-www-form-urlencoded

grant_type=authorization_code&
code=SplxlOBeZQQYbYS6WxSbIA&
redirect_uri=https://app.com/callback&
client_id=client123&
code_verifier=dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk
----

RÃ©ponse typique :

[source,json]
----
{
  "access_token": "eyJhbGciOiJSUzI1NiIsInR...",
  "id_token": "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...",
  "refresh_token": "def456uvw",
  "expires_in": 3600,
  "token_type": "Bearer",
  "scope": "openid profile email offline_access"
}
----

== ğŸ§¾ DÃ©tail du `id_token` â€“ Token d'identitÃ©

Lâ€™`id_token` est un **JWT signÃ©** qui contient des informations dâ€™identitÃ© sur lâ€™utilisateur.
Il ne donne pas accÃ¨s Ã  une API, mais permet au client de **savoir qui est connectÃ©**, de maniÃ¨re **vÃ©rifiable localement**.

=== ğŸ¯ DiffÃ©rences fondamentales

[cols="1,2,2",options="header"]
|===
| Ã‰lÃ©ment       | `id_token` (OIDC)                     | `access_token` (OAuth)

| Objectif      | Authentifier lâ€™utilisateur             | Autoriser un accÃ¨s Ã  une ressource
| UtilisÃ© par   | Le client (SPA, backend, mobileâ€¦)      | Lâ€™API (backend de ressource)
| Format        | JWT signÃ© (toujours)                   | JWT ou opaque
| Transport     | Jamais dans `Authorization`            | Oui â†’ `Authorization: Bearer ...`
| VÃ©rification  | Par le client                          | Par lâ€™API destinataire
| Issu si ?     | `scope=openid`                         | Tout flux OAuth (client_credentials, etc.)
|===

=== ğŸ§¬ Exemple de `id_token` dÃ©codÃ©

==== En-tÃªte
[source,json]
----
{
  "alg": "RS256",
  "typ": "JWT",
  "kid": "auth-key-1"
}
----

==== Payload
[source,json]
----
{
  "iss": "https://auth.example.com",
  "sub": "user_123",
  "aud": "client123",
  "exp": 1710000000,
  "iat": 1709999400,
  "nonce": "xyz456",
  "email": "user@example.com",
  "email_verified": true,
  "name": "Jean Dupont"
}
----

[cols="1,3",options="header"]
|===
| Claim | Description

| `iss` | Issuer : URL du serveur d'autorisation
| `sub` | Subject : identifiant unique de lâ€™utilisateur
| `aud` | Audience : le `client_id` Ã  qui est destinÃ© ce token
| `exp` / `iat` | Dates dâ€™expiration / dâ€™Ã©mission
| `nonce` | Jeton anti-rejeu gÃ©nÃ©rÃ© par le client (doit Ãªtre vÃ©rifiÃ©)
| `email`, `name` | Claims issus des scopes demandÃ©s (`email`, `profile`, etc.)
|===

[TIP]
====
Le client doit :
- vÃ©rifier la **signature du JWT** (`jwks_uri`)
- vÃ©rifier les valeurs de `aud`, `iss`, `exp`
- valider que `nonce` correspond Ã  celui envoyÃ© Ã  `/authorize`
====

[NOTE]
====
ğŸ‘‰ Lâ€™`id_token` est le cÅ“ur du mÃ©canisme dâ€™authentification de lâ€™utilisateur en OIDC.
Il permet de **vÃ©rifier une session sans faire dâ€™appel au serveur**, contrairement Ã  `/userinfo`.

â„¹ï¸ Le endpoint `/userinfo` retourne des informations **plus fraÃ®ches**, utiles si le `id_token` est partiel ou ancien.
====

=== ğŸ” Validation du id_token

1. RÃ©cupÃ©rer la clÃ© publique via `jwks_uri`
2. VÃ©rifier la **signature** du JWT
3. Valider les claims suivants :
- `iss` == issuer attendu
- `aud` == client_id
- `exp` non expirÃ©
- `nonce` correspond Ã  celui fourni

[NOTE]
====
Certains serveurs mettent toutes les informations dans id_token, rendant /userinfo inutile (si ce n'est pour s'assurer que les informations sont Ã  jour)
====


== ğŸ” Comparaison OAuth 2.0 / OIDC

[cols="1,1,1",options="header"]
|===
| Ã‰lÃ©ment             | OAuth 2.0        | OIDC

| Objectif            | Autoriser lâ€™accÃ¨s Ã  une ressource | Authentifier lâ€™utilisateur
| Token principal     | access_token     | id_token (+ access_token)
| Fournit lâ€™identitÃ© ?| âŒ Non            | âœ… Oui
| SSO                 | âŒ Non            | âœ… Oui
|===

== ğŸ” SÃ©curitÃ© â€“ Le `nonce`

Permet de se prÃ©munir contre les attaques de rejeu :
- Le client gÃ©nÃ¨re un `nonce` Ã  lâ€™Ã©tape `/authorize`
- Le serveur le renvoie dans le `id_token`
- Le client **doit vÃ©rifier** que la valeur correspond

== ğŸ§­ Flux complet OIDC (Authorization Code + PKCE)

[plantuml]
----
@startuml
actor "Utilisateur" as User
participant "App (SPA / mobile)" as App
participant "Authorization Server / IdP" as AS

== Ã‰tape 1 â€“ /authorize ==
App -> AS : GET /authorize?client_id=...&scope=openid profile&nonce=abc...

AS -> User : Formulaire de login

User -> AS : Login
AS -> App : Redirection /callback?code=xyz&state=...

== Ã‰tape 2 â€“ /token ==
App -> AS : POST /token + code + code_verifier
AS -> App : access_token + id_token + refresh_token

== Ã‰tape 3 â€“ /userinfo ==
App -> AS : GET /userinfo (avec access_token)
AS -> App : JSON : nom, email, etc.
@enduml
----

== ğŸ” Fonctionnement du `refresh_token`

Le `refresh_token` :
- permet de **prolonger une session** sans que lâ€™utilisateur ne se reconnecte,
- est obtenu **uniquement si le scope `offline_access` a Ã©tÃ© demandÃ©**,
- peut Ãªtre **refusÃ©** par le serveur (ex: clients publics JS, configuration IdP...),
- est **rotatif** sur certains serveurs : chaque utilisation en invalide lâ€™ancien.

=== ğŸ§­ Flux dâ€™Ã©change du refresh_token

[source,http]
----
POST /token
Content-Type: application/x-www-form-urlencoded

grant_type=refresh_token&
client_id=client123&
refresh_token=def456uvw
----

RÃ©ponse typique (rotation activÃ©e) :

[source,json]
----
{
  "access_token": "eyJhbGciOiJIUzI1NiIs...",
  "id_token": "eyJhbGciOiJSUzI1NiIs...",
  "refresh_token": "ghi789rst", // nouveau
  "expires_in": 3600,
  "token_type": "Bearer"
}
----

[NOTE]
====
* Certains serveurs nâ€™Ã©mettent un nouveau `id_token` que si demandÃ© via un paramÃ¨tre (`scope`, `openid`, etc.)
* Si la **rotation est activÃ©e**, lâ€™ancien `refresh_token` est invalidÃ© aprÃ¨s usage
* Si elle ne lâ€™est pas, le mÃªme `refresh_token` peut Ãªtre rÃ©utilisÃ© plusieurs fois (âš ï¸ risquÃ©)
====

=== âœ… Bonnes pratiques avec les refresh_token

* Toujours chiffrer le stockage local (Keychain, Keystore, DB chiffrÃ©e)
* Ne jamais exposer un refresh_token dans un navigateur JS ou localStorage
* PrÃ©fÃ©rer des `refresh_token` liÃ©s Ã  une session ou un appareil unique
* RÃ©voquer les refresh_token au logout
* Utiliser la rotation si disponible

== ğŸ” SÃ©curitÃ© par type de client

[cols="1,2",options="header"]
|===
| Type de client           | Stockage recommandÃ© pour `refresh_token`

| SPA (JavaScript)         | âš ï¸ DÃ©conseillÃ© â€“ utiliser plutÃ´t cookie HttpOnly sÃ©curisÃ©
| Application mobile       | âœ… Keystore (Android) / Keychain (iOS)
| Client backend confidentiel | âœ… Base de donnÃ©es sÃ©curisÃ©e, chiffrÃ©e
|===


== ğŸ” Discovery â€“ /.well-known/openid-configuration

[source,http]
----
GET /.well-known/openid-configuration
----

[source,json]
----
{
  "issuer": "https://auth.example.com",
  "authorization_endpoint": ".../authorize",
  "token_endpoint": ".../token",
  "userinfo_endpoint": ".../userinfo",
  "jwks_uri": ".../.well-known/jwks.json",
  "response_types_supported": ["code", "id_token"],
  "id_token_signing_alg_values_supported": ["RS256"]
}
----

== ğŸ“¥ /userinfo â€“ Profil utilisateur

[source,http]
----
GET /userinfo
Authorization: Bearer <access_token>
----

[source,json]
----
{
  "sub": "user_123",
  "email": "user@example.com",
  "name": "Jean Dupont"
}
----

=== ğŸ“‹ Liste des claims retournÃ©s par `/userinfo`

Les claims retournÃ©s par `/userinfo` dÃ©pendent :
- des `scopes` demandÃ©s (`profile`, `email`, etc.)
- des claims disponibles et autorisÃ©s pour le client

Exemple de rÃ©ponse :
[source,json]
----
{
  "sub": "user_123",
  "name": "Jean Dupont",
  "email": "jean.dupont@example.com",
  "email_verified": true,
  "locale": "fr-FR",
  "updated_at": 1712345678
}
----

[NOTE]
====
Le contenu du `id_token` et du `/userinfo` peut Ãªtre personnalisÃ© cÃ´tÃ© serveur :
- via des **mappers** (ex : Keycloak)
- via des **rÃ¨gles ou hooks** (ex : Auth0 Rules)
====

== ğŸ’¡ Autres endpoints OIDC (optionnels)

[cols="1,3",options="header"]
|===
| Endpoint | Description

| `/logout` ou `/end_session` | Permet de dÃ©clencher une dÃ©connexion centralisÃ©e (SSO) du serveur IdP
| `/check_session` | Permet de vÃ©rifier via iframe que la session IdP est toujours active (rarement utilisÃ©)
| `/introspect` | Endpoint OAuth utilisÃ© pour vÃ©rifier un token opaque (non JWT)
| `/revocation` | Pour invalider un access_token ou refresh_token manuellement
| `/jwks.json` | Contient les clÃ©s publiques utilisÃ©es pour vÃ©rifier la signature des `id_token`
|===

[TIP]
====
Les endpoints `/logout`, `/check_session`, etc., sont surtout utilisÃ©s dans des architectures SSO complexes (ex: avec Keycloak, Azure AD, etc.).
====

== ğŸ” SSO & OIDC

OIDC permet le **Single Sign-On** :
- Lâ€™utilisateur sâ€™authentifie une seule fois
- Plusieurs apps clientes configurÃ©es sur le mÃªme IdP peuvent en bÃ©nÃ©ficier
- Via les cookies de session gÃ©rÃ©s cÃ´tÃ© IdP

== âš ï¸ VulnÃ©rabilitÃ©s connues

[cols="1,2",options="header"]
|===
| ProblÃ¨me | Contremesure

| Vol du id_token dans lâ€™URL | Ã‰viter `response_type=id_token`
| Rejeu du token | VÃ©rifier `nonce`
| Mauvaise audience ou Ã©metteur | VÃ©rifier `aud`, `iss`
|===

== âœ… Bonnes pratiques

* Toujours vÃ©rifier la signature du `id_token`
* Utiliser Authorization Code + PKCE
* Ne jamais exposer le `id_token` dans un navigateur sans vÃ©rification
* Stocker les tokens de maniÃ¨re sÃ©curisÃ©e (WebCrypto / secure storage)
* RafraÃ®chir les tokens avec `offline_access`, pas avec les identifiants

== ğŸ“š SpÃ©cifications

* https://openid.net/specs/openid-connect-core-1_0.html
* https://openid.net/specs/openid-connect-discovery-1_0.html
* https://openid.net/specs/openid-connect-session-1_0.html
* https://openid.net/specs/openid-connect-frontchannel-1_0.html
* https://openid.net/specs/openid-connect-backchannel-1_0.html
