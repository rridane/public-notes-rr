:author-url: https://github.com/rridane
:author: rridane
:source-highlighter: rouge
:hardbreaks:
:table-caption!:
:toc: left
:toclevels: 3
:numbered:

= JWT (JSON Web Tokens) ‚Äì Fiche ultra-compl√®te

== D√©finition

Un **JWT** est un jeton **sign√©** (JWS) ‚Äì ou, si besoin, **chiffr√©** (JWE) ‚Äì permettant de transmettre des informations (*claims*) entre deux parties de mani√®re compacte et s√©curis√©e, tout en restant stateless c√¥t√© serveur.

**JWS** signifie **Json Web Signature** et **JWE** signifie **Json Web Encryption**

.Structure
----
<HEADER>.<PAYLOAD>.<SIGNATURE>   (JWS)
<HEADER>.<ENCRYPTED_KEY>.<IV>.<CIPHERTEXT>.<TAG>   (JWE)
----

Chaque partie est encod√©e en **Base64URL** pour √©viter les caract√®res non URL-safe, autrement dit, dans la structure, il faut comprendre <PAYLOAD> par base64Url(JsonPayload).

=== üéØ Pourquoi Base64URL ?

- Facilite la transmission du JWT dans des URLs, headers HTTP, cookies, etc.
- Supprime les caract√®res `+`, `/`, `=` du Base64 standard
- Ne compresse ni ne chiffre : tout reste visible

== Structure d√©taill√©e

=== Header

Le header est le m√™me (en structure), que l'on soit en JWS ou en JWE.

[source,json]
----
{
  "alg": "RS256",
  "typ": "JWT",
  "kid": "abc123"
}
----

* `alg` : algorithme de signature (`HS256`, `RS256`, `ES256`, ‚Ä¶) ou de chiffrement (`RSA-OAEP`, ‚Ä¶)
* `typ` : type du jeton ‚Äì g√©n√©ralement `"JWT"`
* `kid` : **Key ID** (Identifiant de la cl√© publique) optionnel, indispensable pour la rotation de cl√©s

=== Payload (claims)

==== Structure de base

C'est le "body" du JWT, il est pr√©sent tel quel en base64 dans le JWS, et inclue dans le CypherText en JWE.

.Exemple exhaustif
[source,json]
----
{
  "iss": "https://auth.example.com",
  "sub": "user_123456",
  "aud": "api.example.com",
  "exp": 1710000000,
  "nbf": 1709990000,
  "iat": 1709980000,
  "jti": "abcd-1234-efgh-5678",
  "scope": "read:users write:users",
  "roles": ["admin", "user"],
  "email": "john.doe@example.com",
  "username": "johndoe",
  "tenant_id": "tenant_abc",
  "custom_claim": "custom_value"
}
----

==== Claims standards

.Tableau des *registered claims*
[cols="1,1,2",options="header"]
|===
|Claim |Type |Description
|`iss` |string |Issuer : √©metteur du token
|`sub` |string |Subject : identifiant du sujet
|`aud` |string / array |Audience : destinataire pr√©vu
|`exp` |timestamp |Expiration : date d‚Äôexpiration (obligatoire en prod)
|`nbf` |timestamp |Not Before : valide √† partir de
|`iat` |timestamp |Issued At : date de cr√©ation
|`jti` |string |JWT ID : identifiant unique
|===

Autres claims fr√©quents : `scope`, `roles`, `email`, `tenant_id`, `custom_*`.

Un jwt contient donc avant tout un header et un body (payload). Ce header et ce payload peuvent √™tre transmis en clair, mais avec une garantie d'authenticit√© (JWS) ou en chiffr√© (JWE).

== JWS vs JWE

Les JWT peuvent √™tre **sign√©s (JWS)** ou **chiffr√©s (JWE)**, avec des objectifs, structures et algorithmes tr√®s diff√©rents.

=== üîè JWS ‚Äì Authenticit√©

Objectif : **int√©grit√© + authenticit√©** (mais pas de confidentialit√©)

|===
|               |Signature |Chiffrement |Payload lisible
|**JWS**        |‚úÖ Oui    |‚ùå Non      |‚úÖ Oui
|===

* Ne prot√®ge **pas la confidentialit√©** ‚Üí ne jamais y stocker de donn√©es sensibles en clair

==== ‚úçÔ∏è Comprendre la Signature

La signature d‚Äôun JWT avec JWS ne chiffre **aucune donn√©e** : elle vise uniquement √† **garantir l'int√©grit√© et l‚Äôauthenticit√©** du message.
Le contenu reste **enti√®rement lisible**, mais infalsifiable.

==== Algorithmes de signature JWS

[cols="1,1,2",options="header"]
|===
|Algorithme |Type |Usage
|`HS256`, `HS384`, `HS512` |Sym√©trique (HMAC) |Cl√© partag√©e entre parties (simple mais risqu√© √† grande √©chelle)
|`RS256`, `RS384`, `RS512` |Asym√©trique (RSA + SHA) |Cl√© priv√©e pour signer, cl√© publique (JWKS) pour v√©rifier
|`ES256`, `ES384`, `ES512` |Asym√©trique (ECDSA) |Compact, rapide, s√©curis√© (bas√© sur courbes elliptiques)
|`none` |‚ö†Ô∏è Aucun |‚ö†Ô∏è √Ä proscrire : vuln√©rabilit√© historique
|===

*Recommand√© :* `RS256` ou `ES256` avec rotation (`kid` + JWKS)

==== üîÅ √âtapes de la signature JWS (`RS256`)

[source,text]
----
1. Encodage Base64URL :
   encoded_header  = base64url(header JSON)
   encoded_payload = base64url(payload JSON)

2. Construction du message √† signer :
   message = encoded_header + "." + encoded_payload

3. Hash du message :
   hash = SHA-256(message)

4. Signature RSA :
   signature = RSA_sign(private_key, hash)

5. Encodage final :
   encoded_signature = base64url(signature)

6. JWT final :
   JWT = encoded_header + "." + encoded_payload + "." + encoded_signature
----

.Bonnes pratiques JWS
* V√©rifier **toujours** : signature, `exp`, `aud`, `iss`
* Ne jamais accepter `alg: none`
* Ajouter `jti` pour la r√©vocation ponctuelle

=== ‚úÖ V√©rification de la signature JWS pas √† pas (RS256)

[source,text]
----
# D√©coder le JWT :
JWT = <header_b64>.<payload_b64>.<signature_b64>

D√©coder Base64URL :
header = base64url_decode(header_b64)
payload = base64url_decode(payload_b64)
signature = base64url_decode(signature_b64)

Reconstituer le message sign√© :
message = header_b64 + "." + payload_b64

Calculer le hash :
hash = SHA-256(message)

V√©rifier la signature RSA :
is_valid = RSA_verify(public_key, hash, signature)
----

[source,code]
----
# Supposons que $JWS contienne le JWT complet
# Note : la commande read utilise nativement IFS, raison pour laquelle elle d√©compose le jws

IFS='.' read -r header_b64 payload_b64 signature_b64 <<< "$JWS"

# Reconstituer le message sign√©
message="${header_b64}.${payload_b64}"

# D√©coder la signature
printf '%s' "$signature_b64" | base64 -d -A > sig.bin

# V√©rifier la signature avec la cl√© publique
printf '%s' "$message" | openssl dgst -sha256 -verify public.pem -signature sig.bin
----

==== üß† R√©sum√©

- ‚úÖ La signature porte sur le **hash du message encod√© en Base64URL**
- ‚ùå Le contenu n‚Äôest pas chiffr√©
- ‚úÖ Le destinataire peut v√©rifier la signature avec la **cl√© publique** ( √† l'aide du **kid** si plusieurs cl√©s publiques sont utilis√©es)
- ‚ùå Ne prot√®ge pas la **confidentialit√©**, uniquement l‚Äô**int√©grit√©**

=== üîê JWE ‚Äì Confidentialit√©

.Structure
----
<HEADER>.<ENCRYPTED_KEY>.<IV>.<CIPHERTEXT>.<TAG>   (JWE)

# En r√©alit√© tout est en base64
Base64URL(HEADER).Base64URL(ENCRYPTED_KEY).Base64URL(IV).Base64URL(CIPHERTEXT).Base64URL(TAG)
----

Objectif : rendre le **payload illisible** √† tout tiers non autoris√©.
R√©alis√© via **chiffrement sym√©trique** (ex : AES-256-GCM) avec une **cl√© CEK** unique par message.

==== üì¶ Structure macro d‚Äôun JWE compact

[cols="1,3",options="header"]
|===
|Segment |Contenu

|`HEADER` |Instructions sur les algorithmes utilis√©s (`alg`, `enc`, `kid`, etc.)
|`ENCRYPTED_KEY` |Cl√© de chiffrement de contenu (CEK) **chiffr√©e** avec la **cl√© publique** du destinataire
|`IV` |Vecteur d‚Äôinitialisation al√©atoire pour AES-GCM
|`CIPHERTEXT` |Payload JSON chiffr√©e avec CEK et IV
|`TAG` |Tag d‚Äôauthentification assurant l‚Äôint√©grit√© du message
|===

===== üî£ AAD ‚Äì Additional Authenticated Data

L‚Äô**AAD** est une **donn√©e d‚Äôen-t√™te** (g√©n√©ralement le `header`) incluse dans le calcul du **tag d‚Äôauthentification** (Voir section suivante) lors du chiffrement JWE. Cela prot√®ge aussi l‚Äôen-t√™te contre toute modification. Tr√®s concr√®tement l'en-t√™te est ajout√©e aux donn√©es de calcul du tag. Ainsi, m√™me si le header est en clair, il est prot√©g√© contre une modification d'un attaquant. Si le header change, le tag n'est plus valide. Le tag a √©galement pour vocation de prot√©ger contre toute modification des autres parties du JWE.

===== Comprendre l'AAD par un exemple

[source,text]
----
AAD = base64url(HEADER)

TAG = Auth( IV, CIPHERTEXT, AAD, CEK )
----

Le `TAG` est donc un **r√©sum√© s√©curis√©** de :
- l‚ÄôIV (vecteur d‚Äôinitialisation)
- la payload chiffr√©e
- l‚Äôent√™te (AAD)
- la CEK (cl√© de chiffrement)

==== ‚öôÔ∏è √âtapes d√©taill√©es du processus de chiffrement JWE

===== G√©n√©ration

. G√©n√©rer une CEK (**Content Encryption Key**) al√©atoire (ex: 256 bits pour AES)
. G√©n√©rer un IV (ex: 96 bits pour AES-GCM)
. Chiffrer la **payload JSON** avec CEK + IV ‚Üí produit `CIPHERTEXT` + `TAG`
. Chiffrer la **CEK** avec la **cl√© publique du destinataire** (`alg`) ‚Üí `ENCRYPTED_KEY`
. Construire le `HEADER` avec les m√©tadonn√©es (`alg`, `enc`, `kid`)
. Encoder tous les √©l√©ments en Base64URL et concat√©ner

===== üîê √âtapes de chiffrement JWE (compact, AES-GCM)

[source,text]
----
1. G√©n√©ration al√©atoire :
   - CEK = cl√© sym√©trique (ex : 256 bits pour A256GCM)
   - IV  = vecteur d‚Äôinitialisation (ex : 96 bits al√©atoires)

2. Construction du Header :
   header = {
     "alg": "RSA-OAEP",
     "enc": "A256GCM",
     "kid": "abc123"
   }

3. Encodage Base64URL du header :
   encoded_header = base64url( JSON(header) )

4. AAD (Additional Authenticated Data) :
   AAD = encoded_header   (non chiffr√©, mais authentifi√©)

5. Chiffrement AES-GCM :
   - Entr√©e : payload JSON
   - AES-GCM(key=CEK, iv=IV, aad=AAD) ‚ûú CIPHERTEXT + TAG

6. Chiffrement de la CEK (cl√© de session) :
   - encrypted_key = RSA_encrypt(public_key, CEK)

7. Encodages Base64URL :
   - encrypted_key_b64  = base64url(encrypted_key)
   - iv_b64             = base64url(IV)
   - ciphertext_b64     = base64url(CIPHERTEXT)
   - tag_b64            = base64url(TAG)

8. Construction finale du JWE compact :
   JWE = encoded_header + "." +
         encrypted_key_b64 + "." +
         iv_b64 + "." +
         ciphertext_b64 + "." +
         tag_b64
----

==== Transmission

Le message chiffr√© contient :

[source,text]
----
Base64URL(HEADER).Base64URL(ENCRYPTED_KEY).Base64URL(IV).Base64URL(CIPHERTEXT).Base64URL(TAG)
----

==== D√©chiffrement

. Lire le `HEADER` pour conna√Ætre les algos utilis√©s
. D√©chiffrer `ENCRYPTED_KEY` avec sa **cl√© priv√©e** ‚Üí retrouve la CEK
. Utiliser CEK + IV pour d√©chiffrer `CIPHERTEXT`
. V√©rifier `TAG` : si invalide ‚Üí message rejet√©

=== ‚úÖ V√©rification du TAG JWE (AES-GCM)

[source,bash]
----
# Suppose que $JWE contient le token compact : HEADER.ENCRYPTED_KEY.IV.CIPHERTEXT.TAG

IFS="." read -r header_b64 encrypted_key_b64 iv_b64 ciphertext_b64 tag_b64 <<< "$JWE"

# 1. D√©codage des segments en base64url (sans padding)
b64url_decode() {
  local input="$1"
  local rem=$(( ${#input} % 4 ))
  [[ $rem -eq 2 ]] && input="${input}=="
  [[ $rem -eq 3 ]] && input="${input}="
  echo "$input" | tr '_-' '/+' | openssl base64 -d -A
}

header=$(b64url_decode "$header_b64")
encrypted_key=$(b64url_decode "$encrypted_key_b64")
iv=$(b64url_decode "$iv_b64")
ciphertext=$(b64url_decode "$ciphertext_b64")
tag=$(b64url_decode "$tag_b64")

# 2. D√©chiffrer la CEK avec la cl√© priv√©e
# Cela suppose que tu as la cl√© priv√©e dans private.pem
CEK=$(echo -n "$encrypted_key" | openssl rsautl -decrypt -inkey private.pem -oaep -raw | xxd -p -c256)

# 3. Rejouer le d√©chiffrement AES-GCM avec AAD = header_b64
# Pr√©parer les fichiers
echo -n "$ciphertext" > ciphertext.bin
echo -n "$tag" > tag.bin
echo -n "$iv" > iv.bin
echo -n "$header_b64" > aad.txt

# Reconstituer payload.json (si le tag est valide)
openssl enc -d -aes-256-gcm \
  -K "$CEK" \
  -iv "$(< iv.bin | xxd -p)" \
  -in ciphertext.bin \
  -out payload.json \
  -nosalt \
  -p \
  -aad "$(< aad.txt)" \
  -tag "$(< tag.bin | xxd -p)"

# Si le TAG est incorrect, openssl retournera une erreur :
# > bad decrypt
----

==== Algorithmes JWE (structure hybride)

[cols="1,1,2",options="header"]
|===
|Champ |Algorithmes |Usage

|`alg` |RSA-OAEP, ECDH-ES, A256KW, etc. |Chiffre la CEK (asym√©trique)
|`enc` |A128GCM, A256GCM, A128CBC-HS256, etc. |Chiffre la payload avec la CEK (sym√©trique)
|===

=== üõ†Ô∏è Atelier pratique : g√©n√©rer & v√©rifier un JWS puis un JWE en *Bash*

.Pr√©requis (install en 1 min)
----
# Linux / macOS
brew install jq openssl            # ou apt install jq openssl
npm install -g jose-util           # outil CLI pour JWE (Node ‚â• 18)
----

[source,bash]
----
#!/usr/bin/env bash
set -euo pipefail

# 1) G√©n√©rer une paire RSA
openssl genrsa -out private.pem 2048
openssl rsa -in private.pem -pubout -out public.pem

# 2) Pr√©parer une payload JSON (claims)
cat > payload.json <<'JSON'
{
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true,
  "iat": 1709980000
}
JSON

# 3) ---------- JWS (RS256) ----------
HEADER='{"alg":"RS256","typ":"JWT","kid":"demo1"}'

# Helper pour base64url sans padding
b64url() { openssl base64 -e -A | tr '+/' '-_' | tr -d '='; }

header_b64=$(printf '%s' "$HEADER" | b64url)
payload_b64=$(jq -c . < payload.json | b64url)
unsigned="${header_b64}.${payload_b64}"

signature=$(printf '%s' "$unsigned" \
           | openssl dgst -sha256 -sign private.pem | b64url)

JWS="${unsigned}.${signature}"
echo -e "\nüîë JWS (RS256 sign√©) :\n${JWS}"

# 4) ---------- JWE (RSA-OAEP / AES-256-GCM) ----------
#   Chiffre TOUTE la payload ‚Äì r√©sultat = 5 segments
jose-util encrypt \
  --alg RSA-OAEP \
  --enc A256GCM \
  --key public.pem \
  --input payload.json > token.jwe

echo -e "\nüõ°Ô∏è  JWE (chiffr√©) :\n$(cat token.jwe)"

# 5) D√©chiffrer le JWE pour v√©rif
echo -e "\nüîé D√©chiffrement JWE ‚ûú payload :"
jose-util decrypt --key private.pem --input token.jwe
----

=== ‚öôÔ∏è Atelier Bash : focus ‚Äúpayload ‚Üí ciphertext‚Äù

*payload ‚Üí ciphertext*

[code, bash]
----
# (suite du script pr√©c√©dent, juste apr√®s g√©n√©ration de payload.json)

echo -e "\n--- STAGE: Payload en clair ---"
cat payload.json | jq

#  ‚ûú Chiffrement AES-256-GCM (offline) pour visualiser les √©l√©ments
CEK=$(openssl rand -hex 32)                      # 32 bytes = 256 bits
IV=$(openssl rand -hex 12)                       # 12 bytes = 96 bits (GCM)
AAD=$(printf '%s' '{"alg":"dir","enc":"A256GCM"}' | openssl base64 -A | tr '+/' '-_' | tr -d '=')

CIPHERTEXT_TAG=$( \
  openssl enc -aes-256-gcm -K "$CEK" -iv "$IV" \
    -in payload.json -out /dev/stdout -a -A \
    -p -aad "$AAD" )

echo -e "\n--- STAGE: Ciphertext + Tag (local demo) ---"
echo "$CIPHERTEXT_TAG"

----

.Lecture des r√©sultats
* **JWS** ‚Üí 3 segments : `HEADER.PAYLOAD.SIGNATURE`
*Lisible* via :
`echo "$JWS" | cut -d'.' -f1-2 | tr '.' '\n' | while read p; do echo "$p" | openssl base64 -d -A | jq; done`
* **JWE** ‚Üí 5 segments : `HEADER.ENCRYPTED_KEY.IV.CIPHERTEXT.TAG`
*Illisible* sans la cl√© priv√©e. La commande `jose-util decrypt ‚Ä¶` affiche la payload initiale.

== Pourquoi ne pas chiffrer la payload directement avec la cl√© publique ?

=== Limitation des algorithmes asym√©triques

- RSA est limit√© √† de **petits messages** (ex: 190 octets max avec RSA-2048)
- Trop lent pour des payloads volumineuses
- Pas s√©curis√© pour du *raw encryption* de donn√©es utilisateur

‚û°Ô∏è On pr√©f√®re **chiffrer une CEK**, puis utiliser cette CEK pour chiffrer la payload.

=== Performance

- AES (sym√©trique) est :
* rapide
* s√©curis√©
* acc√©l√©r√© mat√©riellement
- RSA/ECDH sont **parfaits pour prot√©ger une petite cl√©** (CEK)

=== Standardisation

- Mod√®le dit **chiffrement hybride** adopt√© partout (TLS, Signal, JWE)
- S√©paration claire :
* asym√©trie = protection de la CEK
* sym√©trie = protection de la donn√©e

== S√©curit√©

=== Dur√©e de vie & renouvellement

* `exp` court : 5 ‚Äì 30 min
* **Refresh token** (OAuth2 / OIDC) pour renouveler sans re-login
* Autoriser la **rotation d‚Äôaccess token** (gr√¢ce au `kid` et au JWKS)

=== Vuln√©rabilit√©s classiques
* `alg: none`
* Confusion `RS256` ‚Üí `HS256`
* Jeton tr√®s long (`exp` √©loign√©)
* Stockage dans `localStorage` (XSS)

=== Bonnes pratiques
* Cookies **HttpOnly + SameSite** pour navigateurs
* `X-Auth-Token` ou header *Authorization* ¬´ Bearer ¬ª c√¥t√© API
* Activer **CORS** correctement
* Journaliser `jti`, `sub`, erreurs de validation

== üîÅ Rotation des cl√©s (`kid`, JWKS)

=== Concepts

[cols="1,3"]
|===
|`kid` |Identifie la cl√© de signature dans l‚Äôen-t√™te
|JWKS  |Endpoint JSON exposant les **cl√©s publiques**
|Rotation |Remplacement r√©gulier de la cl√© priv√©e + publication cl√© publique
|===

=== Exemple : JWT sign√©

[source,json]
----
{
  "alg": "RS256",
  "typ": "JWT",
  "kid": "abc123"
}
----

=== Exemple : JWKS

[source,json]
----
{
  "keys": [
    { "kid": "abc123", "kty": "RSA", "alg": "RS256", "n": "...", "e": "AQAB" },
    { "kid": "def456", "kty": "RSA", "alg": "RS256", "n": "...", "e": "AQAB" }
  ]
}
----

=== Flux de v√©rification

1. Le client lit `kid = abc123` dans le JWT.
2. Il r√©cup√®re (ou met √† jour) le **JWKS**.
3. Il extrait la cl√© publique `abc123`.
4. Il v√©rifie la signature.

=== Impl√©menter un JWKS

* **Cl√©-en-main** : Keycloak, Auth0, Cognito, Dex
* **Custom** : exposer `/jwks.json` et signer via libs :
- Go : `golang-jwt/jwt`, `MicahParks/keyfunc`
- Node : `jose`, `jsonwebtoken`
- Java : `Nimbus JOSE + JWT`, Spring Security

=== Gestion des cl√©s priv√©es

* Stockage : Vault, AWS KMS, Azure Key Vault, fichier chiffr√©
* Rotation :
1. G√©n√©rer nouvelle paire
2. Publier cl√© publique (`kid` unique)
3. Signer les nouveaux tokens
4. Retirer l‚Äôancienne cl√© apr√®s p√©riode de gr√¢ce

== Cas d‚Äôusage

[cols="2,1,2",options="header"]
|===
|Contexte |JWT adapt√© ? |Notes

|Auth front ‚Üí API REST |‚úÖ Oui |Stateless, scalable
|Micro-services internes |‚úÖ Oui* |`RS256` / mTLS / mTLS+JWT
|Sessions navigateur |‚ö†Ô∏è √Ä nuancer |Pr√©f√©rer cookies HttpOnly
|gRPC |‚úÖ Oui |Via m√©tadonn√©es
|Donn√©es sensibles |‚ùå (JWS) / ‚úÖ (JWE) |Utiliser JWE ou token opaque
|===

== Alternatives

[cols="1,2",options="header"]
|===
|Alternative |Points cl√©s

|Session ID |√âtat serveur, r√©vocation facile
|Opaque token |Jeton sans info ‚Üí appel introspection
|PASETO |JWT like, design ¬´ v3 local / v3 public ¬ª
|Macaroon |Jeton d√©l√©gu√©, caveats cha√Ænables
|===

== Impl√©mentations rapides

* **Java / Spring Boot** : `spring-boot-starter-oauth2-resource-server`, `issuer-uri` ‚áí JWKS auto.
* **Node.js** : `express-jwt` + `jose`, v√©rification `alg`, `aud`, `iss`.
* **Go** : `github.com/golang-jwt/jwt/v5`, middleware Gin / Chi / Echo.

== Audit & Observabilit√©

* Tracer `sub`, `jti`, `iss`, `aud` dans les logs/metrics
* Propager le JWT dans les spans OpenTelemetry (balis√©)
* Mettre en place alertes sur : √©checs de validation, tentatives `alg: none`, expiration syst√©mique.

== √Ä retenir

* **JWS** ‚á¢ signature pour l‚Äôint√©grit√©.
* **JWE** ‚á¢ chiffre pour la confidentialit√©.
* Toujours choisir un algo **asym√©trique** (`RS256`/`ES256`) + **rotation de cl√©s** (`kid`, JWKS).
* Ne stocke **jamais** de donn√©es sensibles en clair dans un JWS.
* Utilise un **refresh token** (OAuth2/OIDC) pour prolonger la session sans exposer `exp` long.
* Un JWT mal g√©r√© devient vite une **faille de s√©curit√©** : valider, journaliser, faire tourner les cl√©s !

=== ‚úÖ Points p√©dagogiques illustr√©s

* **Signature (JWS)** : int√©grit√© & authenticit√© ‚Äì la payload reste *en clair*.
* **Chiffrement (JWE)** : confidentialit√© ‚Äì personne ne lit la payload sans la cl√© priv√©e.
* **`kid` + JWKS** : ajoute facilement une nouvelle cl√© ‚Üí signe ‚Üí publie ‚Üí clients v√©rifient sans downtime.
