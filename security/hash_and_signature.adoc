= üîê Hashs cryptographiques & signatures num√©riques ‚Äì Fiche ultra compl√®te

:toc: left
:toclevels: 3
:numbered:
:source-highlighter: rouge

== üß© Introduction

Les fonctions de hachage cryptographiques et les signatures num√©riques sont des briques fondamentales de la s√©curit√© informatique. Elles assurent l‚Äôint√©grit√©, l‚Äôauthenticit√© et la non-r√©pudiation des donn√©es.

[NOTE]
====
üîê **Non-r√©pudiation**

La non-r√©pudiation garantit qu‚Äôun exp√©diteur **ne peut pas nier** avoir sign√© un message.

Puisque seule la **cl√© priv√©e** permet de g√©n√©rer une signature valide, et qu‚Äôelle est suppos√©e √™tre **secr√®te et d√©tenue exclusivement par l‚Äôexp√©diteur**, alors la signature constitue une preuve irr√©futable de l‚Äôorigine du message.

‚Üí C‚Äôest fondamental dans les contrats num√©riques, les transactions s√©curis√©es, la blockchain, etc.

En compl√©ment pour la non r√©pudiation, il faut mettre en place :

* Horodatage s√©curis√©
* Logs append-only (ex : journaux chiffr√©s, blockchain)
* Audit trails (piste d‚Äôaudit)

====

== 1Ô∏è‚É£ Hash cryptographique : d√©finition et propri√©t√©s

Une fonction de hachage cryptographique transforme un message de taille arbitraire en une sortie de taille fixe.

=== Exemple (SHA-256)

[source,shell]
----
echo -n "hello" | sha256sum
# R√©sultat : 2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824
----

=== Propri√©t√©s attendues

* D√©terministe
* Rapide √† calculer
* R√©sistance √† la pr√©-image
* R√©sistance √† la seconde pr√©-image
* R√©sistance aux collisions

=== Usages typiques

* Int√©grit√© des fichiers
* Stockage de mots de passe
* Commit Git
* Preuve de travail (ex : Bitcoin)

== 2Ô∏è‚É£ Stockage de mots de passe

=== Mauvaise pratique

[source,text]
----
hash("password123") == hash("password123")
‚Üí vuln√©rable aux rainbow tables
----

=== Bonne pratique : salage + KDF

[source,text]
----
hash("password123" + salt)
‚Üí rend les attaques pr√©-calcul√©es inutiles
----

Utiliser des KDF comme :

* bcrypt
* scrypt
* argon2id (recommand√©)

== 3Ô∏è‚É£ Signatures num√©riques ‚úçÔ∏è

Permettent de garantir :

* Authenticit√©
* Int√©grit√©
* Non-r√©pudiation

=== Fonctionnement g√©n√©ral

1. Le signataire calcule le hash du message.
2. Il chiffre ce hash avec sa cl√© priv√©e ‚Üí signature.
3. Le destinataire d√©chiffre avec la cl√© publique.
4. Il calcule lui-m√™me le hash.
5. Il compare les deux valeurs.

=== Algorithmes classiques

[cols="1,2",options="header"]
|===
| Algorithme | D√©tails
| RSA        | Repose sur la factorisation
| ECDSA      | Plus l√©ger, bas√© sur les courbes elliptiques
| EdDSA      | Moderne et s√©curis√© (Ed25519)
|===

== 4Ô∏è‚É£ Exemple complet avec OpenSSL

=== √âtape 1 : G√©n√©rer une paire de cl√©s

[source,shell]
----
# Cl√© priv√©e RSA 2048 bits
openssl genpkey -algorithm RSA -out private.pem -pkeyopt rsa_keygen_bits:2048

# Cl√© publique extraite
openssl rsa -pubout -in private.pem -out public.pem
----

.Fichier `private.pem` (extrait)
[source, text]
----
-----BEGIN PRIVATE KEY-----
MIIEvAIBADANBgkqhkiG9w0BAQEFAASC...
...
-----END PRIVATE KEY-----
----

.Fichier `public.pem` (extrait)
[source, text]
----
-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8A...
...
-----END PUBLIC KEY-----
----

=== √âtape 2 : Cr√©er un fichier √† signer

[source,shell]
----
echo "message √† signer" > message.txt
----

.Contenu de `message.txt`
[source, text]
----
message √† signer
----

=== √âtape 3 : Calculer le hash (optionnel)

[source,shell]
----
openssl dgst -sha256 message.txt
----

.Sortie
[source,text]
----
SHA256(message.txt)= 7da95fb20b36743ab6bd3be5cc49f71ee350aaf62e78f04b650cf3a9de7cc11e
----

‚Üí Il s‚Äôagit du **hash SHA-256** du contenu `message √† signer`.

=== √âtape 4 : Signer le fichier (signature binaire)

[source,shell]
----
openssl dgst -sha256 -sign private.pem -out message.sig message.txt
----

‚Üí Le fichier `message.sig` contient une **signature binaire RSA** du hash pr√©c√©dent.

Pour le rendre lisible :

[source,shell]
----
base64 message.sig
----

.Exemple (r√©sultat base64 de la signature)
[source,text]
----
GRe4eIfRQQcsKMm8c+1GIdLr2c2q6L4qFzA3YH2w0LGphDj/oxYMoK8DJf+EZV3RGZQg...
----

=== √âtape 5 : V√©rifier la signature

[source,shell]
----
openssl dgst -sha256 -verify public.pem -signature message.sig message.txt
----

.Sortie attendue
[source,text]
----
Verified OK
----

‚Üí Cela prouve que le message a √©t√© sign√© avec la cl√© priv√©e **correspondante** √† `public.pem`, **sans modification du message**.

== 5Ô∏è‚É£ Comparaison : hash vs signature

[cols="1,2,2",options="header"]
|===
| Fonction              | Hash         | Signature
| Int√©grit√©             | ‚úÖ           | ‚úÖ
| Authenticit√©          | ‚ùå           | ‚úÖ
| Non-r√©pudiation       | ‚ùå           | ‚úÖ
| Algorithme            | Sym√©trique   | Asym√©trique
| Recalculable          | Oui          | Non
|===

== 6Ô∏è‚É£ Attaques classiques

=== Sur les hash

* Collision (MD5, SHA-1)
* Rainbow tables
* Length extension
* Birthday attack

=== Sur les signatures

* Mauvais encodages ASN.1/DER
* R√©utilisation de nonce (ex : DSA)
* Cl√©s faibles ou g√©n√©r√©es de fa√ßon non al√©atoire

== 7Ô∏è‚É£ Bonnes pratiques

=== Pour les hash

* Ne jamais utiliser MD5 ou SHA-1
* Pr√©f√©rer SHA-256, SHA-3 ou BLAKE3
* Toujours salter les mots de passe
* Utiliser un KDF moderne (argon2id)

=== Pour les signatures

* Privil√©gier EdDSA (Ed25519)
* Ne jamais r√©utiliser de nonce
* Signer uniquement des contenus bien d√©limit√©s
* Toujours valider le format des messages et cl√©s

== 8Ô∏è‚É£ Cas concrets

=== Git

* Utilise SHA-1 ou SHA-256 pour le contenu
* Commits signables via GPG (`git commit -S`)
* Authentification partielle seulement (pas automatique)

=== JWT

* Utilise la signature dans les jetons (ex: RS256, HS256)
* Le header contient l‚Äôalgorithme
* Attention aux impl√©mentations acceptant `alg: none`

=== TLS / HTTPS

* Le certificat est sign√© par une autorit√©
* La cha√Æne de confiance est assur√©e par signature
* Les √©changes utilisent des hachages (SHA-256 ou mieux)

== 9Ô∏è‚É£ Aller plus loin

=== Librairies recommand√©es

[cols="1,2",options="header"]
|===
| Langage | Librairies
| Python  | hashlib, cryptography
| Go      | crypto/ed25519, golang.org/x/crypto
| PHP     | password_hash(), openssl_sign()
| Rust    | ring, ed25519-dalek
| Node.js | crypto, sodium-native
|===

=== Outils utiles

* `openssl dgst`
* `sha256sum`, `blake3sum`
* `gpg --sign`, `gpg --verify`
