:author-url: https://github.com/rridane
:author: rridane
:source-highlighter: rouge
:hardbreaks:
:table-caption!:
:toc: left

= Hashicorp Vault

Initialiser vault.
Cette commande initialse 5 cl√©s et le root token.

[source,bash]
----
kubectl exec -it -n vault vault-0 -- vault operator init
----

[source,bash]
----
Unseal Key 1: m...
Unseal Key 2: T...
Unseal Key 3: U...
Unseal Key 4: e...
Unseal Key 5: e...
----

On fait un unseal de hashicorp en fournissant 3 des 5 cl√©s :

[source,bash]
----
kubectl exec -it -n vault vault-0 -- vault operator unseal
----

On puet alors se connecter avec le root token

[source,bash]
----
kubectl exec -it -n vault vault-0 -- vault login <root-token>
----

[source,bash]
----
h_rridane@rc-tvbpce-kcp1:~/vault$ kubectl exec -it -n vault vault-0 -- vault login hv...
Success! You are now authenticated. The token information displayed below
is already stored in the token helper. You do NOT need to run "vault login"
again. Future Vault requests will automatically use this token.

Key                  Value
---                  -----
token                hvs.w...
token_accessor       UlmB...
token_duration       ‚àû
token_renewable      false
token_policies       ["root"]
identity_policies    []
policies             ["root"]
----

On ne sp√©cifie plus les kubect exec -it -n vault vault-0. On active le module key-value qui permets de stocker des secrets sous forme de key-value

[source,bash]
----
/ $ vault secrets enable -path=kv kv-v2
Success! Enabled the kv-v2 secrets engine at: kv/
----

== Vault KV (Key-Value) ‚Äî Commande `vault kv put`

=== Introduction

La commande `vault kv put` permet d‚Äô**√©crire un secret** dans un moteur KV (Key-Value).
Un *secret* est stock√© sous forme de paires **cl√©=valeur** dans un *chemin logique* appel√© *secret path*.
Avec KV v2, chaque √©criture cr√©e une **nouvelle version** du secret.

Exemple simple :

[source,bash]
----
vault kv put kv/app/config API_KEY=super-secret feature_flag=true
----

* `kv/` ‚Üí le moteur KV (mont√© au chemin `kv`)
* `app/` ‚Üí dossier logique (hi√©rarchie que vous d√©finissez)
* `config` ‚Üí nom du secret
* `API_KEY` et `feature_flag` ‚Üí cl√©s m√©tiers d√©finies librement par l‚Äôapplication

Autrement dit, le secret config dans le dossier logique app stocke deux valeurs, API_KEY et feature_flag.

==== Variantes de base

√âcrire plusieurs cl√©s :

[source,bash]
----
vault kv put kv/app/config API_KEY=aaa feature_flag=false db_user=demo db_pass=demo123
----

√âcrire depuis un fichier JSON :

[source,json]
.payload.json
----
{
  "API_KEY": "super-secret",
  "feature_flag": true
}
----

[source,bash]
----
vault kv put kv/app/config @payload.json
----

Lire un secret :

[source,bash]
----
vault kv get kv/app/config
vault kv get -format=json kv/app/config | jq
----

Lister les secrets :

[source,bash]
----
vault kv list kv/
vault kv list kv/app/
----

Supprimer un secret (soft delete) :

[source,bash]
----
vault kv delete kv/app/config
----

D√©truire d√©finitivement une version donn√©e :

[source,bash]
----
vault kv destroy -versions=2 kv/app/config
----

Relire une version ant√©rieure :

[source,bash]
----
vault kv get -version=1 kv/app/config
----

=== 6Ô∏è‚É£ Options utiles de `vault kv put`

==== `-mount=otherkv`

Permet de sp√©cifier un autre moteur KV que celui par d√©faut.

Exemple : vous avez activ√© un second moteur KV nomm√© `secrets` :

[source,bash]
----
vault secrets enable -path=secrets kv-v2
vault kv put -mount=secrets app/config API_KEY=secret2
vault kv get secrets/app/config
----

Ici, le secret est stock√© dans le moteur `secrets/` et non `kv/`.

==== `-cas=<version>`

*CAS* = *Check-And-Set*.
Cette option assure que l‚Äô√©criture n‚Äô√©crase pas une version diff√©rente de celle attendue.
Elle est utile en cas d‚Äô√©critures concurrentes (concurrency control).

Exemple :

[source,bash]
----
# Le secret est actuellement en version 3
vault kv put -cas=3 kv/app/config API_KEY=newvalue
# => succ√®s

vault kv put -cas=2 kv/app/config API_KEY=oldvalue
# => erreur, car la version attendue (2) n‚Äôest pas la version actuelle (3)
----

==== `-force`

Permet une √©criture forc√©e, m√™me sans donn√©es.
Pratique pour r√©initialiser un secret ou cr√©er une version vide.

Exemple :

[source,bash]
----
# Force l'√©criture d'une nouvelle version sans contenu
vault kv put -force kv/app/config
----

R√©sultat : une nouvelle version du secret est cr√©√©e, mais sans cl√©s/valeurs.

=== Organisation des dossiers

Une structure simple mais scalable est la suivante:

[source,bash]
----
kv/data/<env>/<app>/<category>/<secret>
----

[source,bash]
----
kv/data/prod/rr-dev-service/db/credentials
kv/data/prod/rr-dev-service/api/payment-provider
kv/data/staging/rr-dev-service/config/feature_flags
----

=== R√©sum√©

* `vault kv put` ‚Üí √©criture d‚Äôun secret cl√©/valeur dans Vault
* Le chemin est un *secret path* hi√©rarchique (ex : `kv/app/config`)
* KV v2 conserve l‚Äôhistorique des versions
* Options avanc√©es :
** `-mount` ‚Üí choisir le moteur KV
** `-cas` ‚Üí √©criture conditionnelle (check-and-set)
** `-force` ‚Üí √©criture vide forc√©e

== Vault ‚Äî Consommation des secrets (√âtat de l‚Äôart)

=== Introduction

Apr√®s avoir organis√© et stock√© vos secrets dans Vault, la question est :
*Comment les applications, les pipelines CI/CD, et les workloads consomment ces secrets ?*

L‚Äô√©tat de l‚Äôart repose sur trois principes :
1. **Pas de tokens statiques** ‚Üí utiliser une *auth method* automatique.
2. **Pas de secrets en clair** ‚Üí injection via sidecar, CSI ou variables d‚Äôenvironnement √©ph√©m√®res.
3. **Rotation automatique** ‚Üí privil√©gier les secrets dynamiques (DB, cloud, PKI).

=== Consommation par CLI / API

M√©thode la plus simple mais rarement utilis√©e en production.
Pratique pour les tests ou le d√©bogage.

[source,bash]
----
# Lire un secret depuis le CLI
vault kv get kv/prod/app/db

# Lire uniquement une cl√© sp√©cifique
vault kv get -field=password kv/prod/app/db

# Via API HTTP
curl -s \
  -H "X-Vault-Token: $VAULT_TOKEN" \
  $VAULT_ADDR/v1/kv/data/prod/app/db | jq
----

== Kubernetes Auth + Vault Agent Injector (sidecar)

M√©thode recommand√©e dans Kubernetes.
Un *mutating webhook* ajoute un sidecar `vault-agent` qui s‚Äôauthentifie (via le ServiceAccount du Pod), lit les secrets depuis Vault et les √©crit dans des **fichiers** dans le conteneur applicatif.

=== Rappels importants (comportement par d√©faut)

* Montage par d√©faut des secrets rendus : */vault/secrets* (r√©pertoire dans le Pod/app).
* Pour chaque secret inject√©, on utilise une annotation de la forme :
- `vault.hashicorp.com/agent-inject-secret-<NAME>: "<VAULT_PATH>"`
* **Nom de fichier par d√©faut** : si tu n‚Äôindiques rien d‚Äôautre, le contenu du secret sera √©crit dans un fichier nomm√© **`<NAME>`** sous */vault/secrets/*.
- Exemple : `agent-inject-secret-db-creds: "kv/data/prod/app/db"` ‚áí fichier cr√©√© par d√©faut : */vault/secrets/db-creds*
* **Contenu par d√©faut** :
- Sans template, l‚ÄôAgent √©crit la **r√©ponse brute** du secret (pour KV v2, typiquement en **JSON** contenant `.data.data`).
- En pratique, on pr√©f√®re **d√©finir un template** pour g√©n√©rer exactement le format voulu (JSON √©pur√©, `.env`, cl√© unique, etc.).

=== Comment ma√Ætriser le NOM du fichier

Utilise l‚Äôannotation **`vault.hashicorp.com/agent-inject-file-<NAME>`** pour fixer le nom (et √©ventuellement un sous-r√©pertoire) du fichier rendu :

[source,yaml]
----
metadata:
  annotations:
    vault.hashicorp.com/agent-inject: "true"
    vault.hashicorp.com/role: "app-reader"

    # D√©clare le secret √† r√©cup√©rer
    vault.hashicorp.com/agent-inject-secret-db-creds: "kv/data/prod/app/db"

    # (Optionnel) Force le nom du fichier au lieu du d√©faut "/vault/secrets/db-creds"
    vault.hashicorp.com/agent-inject-file-db-creds: "config/db/credentials.json"
----
R√©sultat : le secret est √©crit dans *`/vault/secrets/config/db/credentials.json`*.

> Tu peux mettre un chemin relatif sous `/vault/secrets` (des sous-dossiers seront cr√©√©s).

=== Comment changer le DOSSIER cible

Le dossier racine par d√©faut est */vault/secrets*.
Pour le modifier globalement pour ce Pod, ajoute :

[source,yaml]
----
metadata:
  annotations:
    vault.hashicorp.com/secret-volume-path: "/work/secrets"
----
Tous les fichiers inject√©s seront alors sous */work/secrets/*.

=== Comment ma√Ætriser le CONTENU (template)

Utilise **`vault.hashicorp.com/agent-inject-template-<NAME>`** pour rendre exactement ce que tu veux.

*Exemple 1 ‚Äî JSON minimal avec toutes les cl√©s du secret KV v2 :*
[source,yaml]
----
metadata:
  annotations:
    vault.hashicorp.com/agent-inject-secret-app-config: "kv/data/prod/app/config"
    vault.hashicorp.com/agent-inject-file-app-config: "config/app.json"
    vault.hashicorp.com/agent-inject-template-app-config: |
      {{- with secret "kv/data/prod/app/config" -}}
      {{ toJSON .Data.data }}
      {{- end -}}
----
R√©sultat : */vault/secrets/config/app.json* contient uniquement les **donn√©es** (`.Data.data`) du KV (sans le wrapping).

*Exemple 2 ‚Äî ne rendre qu‚Äôune **cl√© sp√©cifique** (ex: `password`) :*
[source,yaml]
----
metadata:
  annotations:
    vault.hashicorp.com/agent-inject-secret-db-pass: "kv/data/prod/app/db"
    vault.hashicorp.com/agent-inject-file-db-pass: "db/password.txt"
    vault.hashicorp.com/agent-inject-template-db-pass: |
      {{- with secret "kv/data/prod/app/db" -}}
      {{ .Data.data.password }}
      {{- end -}}
----
R√©sultat : */vault/secrets/db/password.txt* ne contient **que** la valeur du mot de passe.

*Exemple 3 ‚Äî format `.env` :*
[source,yaml]
----
metadata:
  annotations:
    vault.hashicorp.com/agent-inject-secret-env: "kv/data/prod/app/config"
    vault.hashicorp.com/agent-inject-file-env: ".env"
    vault.hashicorp.com/agent-inject-template-env: |
      {{- with secret "kv/data/prod/app/config" -}}
      {{- range $k, $v := .Data.data -}}
      {{ $k }}={{ $v }}
      {{ end -}}
      {{- end -}}
----

=== Pattern exact des annotations

* **Activer l‚Äôinjection** :
`vault.hashicorp.com/agent-inject: "true"`
* **R√¥le Vault (policy)** :
`vault.hashicorp.com/role: "<vault-role-name>"`
* **D√©clarer un secret** :
`vault.hashicorp.com/agent-inject-secret-<NAME>: "<VAULT_PATH>"`
- `<NAME>` : suffixe libre, **sert de nom de fichier par d√©faut** si `agent-inject-file-<NAME>` n‚Äôest pas fourni.
- `<VAULT_PATH>` : chemin API du secret (ex: `kv/data/prod/app/db` pour KV v2).
* **Nom du fichier rendu (optionnel)** :
`vault.hashicorp.com/agent-inject-file-<NAME>: "<relative/path.ext>"`
- Chemin **relatif** au volume des secrets (par d√©faut `/vault/secrets` ou ce que tu as mis dans `secret-volume-path`).
* **Template du contenu (optionnel)** :
`vault.hashicorp.com/agent-inject-template-<NAME>: |` *(puis le template)*

> Si tu ne fournis **ni** `agent-inject-file-<NAME>` **ni** `agent-inject-template-<NAME>`, alors :
> * le fichier s‚Äôappellera `/<volume>/<NAME>`
> * son **contenu** sera la **r√©ponse brute** du secret (souvent JSON pour KV v2).

=== Exemple complet (multi-secrets, noms & contenus ma√Ætris√©s)

[source,yaml]
----
apiVersion: v1
kind: Pod
metadata:
  name: injector-demo
  annotations:
    vault.hashicorp.com/agent-inject: "true"
    vault.hashicorp.com/role: "app-reader"
    vault.hashicorp.com/secret-volume-path: "/work/secrets"

    # 1) Secret DB (fichier JSON minimal)
    vault.hashicorp.com/agent-inject-secret-db-creds: "kv/data/prod/app/db"
    vault.hashicorp.com/agent-inject-file-db-creds: "db/credentials.json"
    vault.hashicorp.com/agent-inject-template-db-creds: |
      {{- with secret "kv/data/prod/app/db" -}}
      {{ toJSON .Data.data }}
      {{- end -}}

    # 2) Secret CONFIG (.env)
    vault.hashicorp.com/agent-inject-secret-config-env: "kv/data/prod/app/config"
    vault.hashicorp.com/agent-inject-file-config-env: "config/.env"
    vault.hashicorp.com/agent-inject-template-config-env: |
      {{- with secret "kv/data/prod/app/config" -}}
      {{- range $k, $v := .Data.data -}}
      {{ $k }}={{ $v }}
      {{ end -}}
      {{- end -}}
spec:
  serviceAccountName: sa-app-reader
  containers:
  - name: app
    image: busybox
    command: ["sh","-lc","find /work/secrets -type f -maxdepth 3 -print -exec echo '----' \\; -exec cat {} \\; ; sleep 3600"]
----

=== Que se passe-t-il quand un secret CHANGE ?

* Le sidecar `vault-agent` **surveille** et **renouvelle** les secrets (TTL/leases).
* Si la valeur change, le **fichier est r√©√©crit** (m√™me chemin), ce qui permet √† l‚Äôapp de recharger sans red√©ployer.
* Pour signaler √† l‚Äôapp de recharger, tu peux d√©clencher une commande :
- Globalement : `vault.hashicorp.com/agent-inject-command: "<cmd>"`
- Ou par fichier : `vault.hashicorp.com/agent-inject-command-<NAME>: "<cmd>"`

*Exemple (recharger Nginx) :*
[source,yaml]
----
metadata:
  annotations:
    vault.hashicorp.com/agent-inject-command-db-creds: '["/bin/sh","-c","kill -HUP 1"]'
----

=== S√©curit√© & connexions

* Le sidecar s‚Äôauthentifie via le **ServiceAccount** du Pod (Kubernetes Auth).
* Tu peux pr√©ciser une config TLS client (annotation `vault.hashicorp.com/tls-secret`) pour s√©curiser la connexion √† Vault.
* Tout acc√®s est **journalis√©** si l‚Äôaudit est activ√© c√¥t√© Vault.

=== R√©sum√© pr√©cis

* **`/agent-inject-secret-<NAME>`** ‚áí d√©clare un secret Vault ; cr√©e un **fichier par d√©faut** nomm√© `<NAME>`.
* **`/agent-inject-file-<NAME>`** ‚áí **change le nom (et sous-chemin)** du fichier rendu.
* **`/agent-inject-template-<NAME>`** ‚áí **contr√¥le le contenu** (JSON, cl√© unique, `.env`, etc.).
* **`/secret-volume-path`** ‚áí change le **r√©pertoire racine** (par d√©faut `/vault/secrets`).
* Sans template, le contenu est la **r√©ponse brute** (souvent JSON KV v2).
* Sans `-file`, le nom = **`<NAME>`** (suffixe de l‚Äôannotation `agent-inject-secret-<NAME>`).
* Le sidecar **met √† jour** les fichiers si les secrets changent (et peut lancer une commande de reload).

== Kubernetes CSI Driver

Alternative moderne : le *CSI Secrets Store Driver*.
Il monte les secrets directement comme un volume, sans sidecar.

Exemple :

[source,yaml]
----
apiVersion: secrets-store.csi.x-k8s.io/v1
kind: SecretProviderClass
metadata:
  name: spc-db
spec:
  provider: vault
  parameters:
    vaultAddress: "http://vault.vault.svc.cluster.local:8200"
    roleName: "app-reader"
    objects: |
      - objectName: "kv/data/prod/app/db"
        secretPath: "kv/data/prod/app/db"
        secretKey: "password"
---
apiVersion: v1
kind: Pod
metadata:
  name: csi-demo
spec:
  serviceAccountName: sa-app-reader
  volumes:
  - name: secrets-store-inline
    csi:
      driver: secrets-store.csi.k8s.io
      readOnly: true
      volumeAttributes:
        secretProviderClass: "spc-db"
  containers:
  - name: app
    image: busybox
    command: ["sh","-c","ls /mnt/secrets-store && cat /mnt/secrets-store/*; sleep 3600"]
    volumeMounts:
    - name: secrets-store-inline
      mountPath: "/mnt/secrets-store"
      readOnly: true
----

R√©sultat attendu :
le mot de passe DB est mont√© dans `/mnt/secrets-store/password`.

== CI/CD (GitLab, GitHub Actions, Jenkins)

√âtat de l‚Äôart : utiliser **OIDC** ou **AppRole** pour que le pipeline s‚Äôauthentifie automatiquement.
Les secrets sont inject√©s dans des variables d‚Äôenvironnement, valides uniquement pendant le job.

Exemple GitLab CI (OIDC ‚Üí Vault) :

[source,yaml]
----
stages:
  - deploy

deploy:
  image: hashicorp/vault:1.17
  script:
    # login via OIDC (GitLab ‚Üí Vault)
    - export VAULT_TOKEN=$(vault write -field=token auth/jwt/login role=gitlab-ci jwt=$CI_JOB_JWT)
    # r√©cup√©rer un mot de passe DB
    - DB_PASS=$(vault kv get -field=password kv/prod/app/db)
    - echo "Mot de passe r√©cup√©r√©: $DB_PASS"
----

== AppRole (VM, batch, legacy)

M√©thode utilis√©e pour des environnements hors Kubernetes ou sans OIDC.
L‚Äôapplication poss√®de un `role_id` et un `secret_id`, et les √©change contre un token Vault.

[source,bash]
----
# L'app r√©cup√®re son role_id et secret_id (provisionn√©s avant)
ROLE_ID="1111-aaaa-xxxx"
SECRET_ID="2222-bbbb-yyyy"

# Login √† Vault
TOKEN=$(vault write -field=token auth/approle/login \
  role_id=$ROLE_ID \
  secret_id=$SECRET_ID)

# Utiliser le token pour lire le secret
VAULT_TOKEN=$TOKEN vault kv get kv/prod/app/db
----

== Applications via SDK / API

Les applications modernes peuvent int√©grer directement les SDK Vault (Go, Java, Python).
Elles obtiennent un token via l‚Äôauth method adapt√©e, puis appellent l‚ÄôAPI Vault.

Exemple Python :

[source,python]
----
import hvac

client = hvac.Client(url="http://127.0.0.1:8200", token="...")

# Lire un secret
secret = client.secrets.kv.read_secret_version(path="prod/app/db")
print(secret["data"]["data"]["password"])
----

== Vault ‚Äî Paths, Plugins & Extensions (vue d‚Äôensemble + plugins + custom)

=== Vue d‚Äôensemble
* Les **paths** sont le c≈ìur de Vault : chaque path correspond √† une **API** expos√©e par un *engine* (ex: `kv/data/...`, `database/creds/...`, `transit/encrypt/...`).
* Il existe des *engines* **noyau** (ex: KV v2, Transit, PKI) et des *engines* fournis via des **plugins**.
* L‚Äôacc√®s √† ces API est **prot√©g√© par des policies** (ACL).
Un **auth role** (Kubernetes/OIDC/AppRole/‚Ä¶) **agr√®ge** des policies et les **attache** √† un **token** lors de l‚Äôauthentification (RBAC). Nous verrons dans le chapitre suivant le fonctionnement pr√©cis des policies.
* Certains engines (Database, PKI, AWS, ‚Ä¶) exposent aussi la notion de **secrets engine roles** (recettes de g√©n√©ration), sans rapport avec les *auth roles*.

[NOTE]
====
Terminologie ‚Äúrole‚Äù :
- **Auth role** ‚Üí agr√©gation de policies donn√©e √† une identit√© (Pod, groupe OIDC‚Ä¶), c√¥t√© m√©thode d‚Äôauth.
- **Secrets engine role** ‚Üí recette interne d‚Äôun engine (ex: SQL + TTL pour Database).
====

=== 2) Principaux *Secrets Engines* (built-in)

Les *secrets engines* stockent, g√©n√®rent ou chiffrent des donn√©es. Liste synth√©tique (les docs officielles listent l‚Äôensemble et les variantes) :

* **KV (v1/v2)** ‚Äî stockage cl√©/valeur (v2 = versions/metadata).
* **Cubbyhole** ‚Äî stockage priv√© par token.
* **Transit** ‚Äî chiffrement/d√©chiffrement ‚Äúas a service‚Äù (stateless).
* **PKI** ‚Äî CA interne, √©mission/rotation de certificats.
* **Database** ‚Äî identifiants DB dynamiques (Postgres, MySQL/MariaDB, MSSQL, Cassandra, MongoDB, etc. via plugins DB). :contentReference[oaicite:1]{index=1}
* **Cloud** ‚Äî AWS (IAM STS), Azure, GCP (SA keys/STS), etc.
* **SSH** ‚Äî OTP/signed keys.
* **TOTP** ‚Äî codes one-time.
* **RabbitMQ, Consul, Active Directory** ‚Äî acc√®s/rotations sp√©cifiques (selon versions/√©ditions).
* **Identity/Token** ‚Äî gestion interne d‚Äôidentit√© et de tokens.

[NOTE]
====
Pour voir ce qui est **activ√©** sur votre serveur :
`vault secrets list` (liste des engines mont√©s et leurs paths). :contentReference[oaicite:2]{index=2}
====

=== 3) Principales **Auth Methods** (built-in)
Les auth methods r√©alisent l‚Äô**authentification** et attribuent des **policies**. La page officielle maintient la liste √† jour :

* **Kubernetes** (JWT de ServiceAccount) ‚Äî standard pour pods K8s.
* **OIDC/JWT** (Keycloak, GitHub, GitLab, Okta, ‚Ä¶).
* **AppRole** (VM/batch/legacy).
* **Cloud IAM** : AWS, Azure, GCP.
* **LDAP**, **GitHub**, **Username/Password**, **Token** (int√©gr√©), etc.

[NOTE]
====
Pour voir les **auth methods** activ√©es :
`vault auth list` (affiche aussi le statut de d√©pr√©ciation depuis Vault 1.12+).
====

=== 4) ‚ÄúExhaustif‚Äù vs ‚Äúexemples‚Äù
Le catalogue exact √©volue (versions & Enterprise). R√©f√©rez-vous aux pages ‚ÄúSecrets engines‚Äù et ‚ÄúAuth methods‚Äù de la doc HashiCorp pour la liste *√† jour* des moteurs/plugins pris en charge. :contentReference[oaicite:5]{index=5}

=== 5) Architecture Plugins (comment √ßa marche)
Vault charge les plugins comme **binaires s√©par√©s**, communiquant via RPC ; un crash de plugin ne fait pas tomber Vault (isolation). La **Plugin Catalog** enregistre les plugins avec une **empreinte SHA256** avant de pouvoir les activer.

Types de plugins pris en charge :
* **secret** (nouvel engine de secrets),
* **auth** (nouvelle m√©thode d‚Äôauth),
* **database** (nouveau provider DB au sein de l‚Äôengine Database).

=== 6) Cr√©er un **custom plugin** (secrets engine ou auth)

R√©sum√© des √©tapes officielles (voir tutoriels HashiCorp pour le pas-√†-pas et le code Go) :

. **Coder** en Go avec le **Vault SDK** (backend `framework.Backend`), d√©finir les **paths** (CRUD, config) et la logique (ex: appeler une API tierce pour g√©n√©rer un token).
. **Compiler** le binaire (GOOS/GOARCH de la cible Vault).
. **D√©ployer** le binaire dans le **plugin_directory** du serveur Vault (config serveur).
. **Calculer la SHA256** du binaire.
. **Enregistrer** dans la **Plugin Catalog** :
`vault plugin register -sha256=<SHA> secret <plugin-name>`
(ou `auth` / `database` selon le type). :contentReference[oaicite:9]{index=9}
. **Activer** le plugin :
* Secrets engine :
`vault secrets enable -path=<mount> -plugin-name=<plugin-name> plugin`
* Auth method :
`vault auth enable -plugin-name=<plugin-name> plugin`
* Database provider : enregistrer le plugin puis l‚Äôutiliser dans `database/config/...` via `plugin_name=<your-db-plugin>`. :contentReference[oaicite:10]{index=10}
. **Configurer** votre engine (paths de config/roles‚Ä¶) et tester.

[NOTE]
====
En dev, on peut utiliser un **r√©pertoire de plugins de test** et/ou l‚Äôoption `-dev-plugin-dir` avec le serveur.
Les guides ‚ÄúCustom secrets engines‚Äù et ‚ÄúPlugin backends‚Äù contiennent un pas-√†-pas complet et du code d‚Äôexemple. :contentReference[oaicite:11]{index=11}
====

=== Wrappers CLI vs API brute

Vault expose uniquement des **endpoints API** (`/v1/kv/data/...`, `/v1/database/creds/...`, etc.).
Toutes les op√©rations se font en r√©alit√© via les commandes g√©n√©riques :

* `vault write <path>` ‚Üí cr√©er ou modifier (POST/PUT API)
* `vault read <path>` ‚Üí lire (GET API)
* `vault delete <path>` ‚Üí supprimer (DELETE API)
* `vault list <path>` ‚Üí lister (LIST API)

Pour plus de confort, le binaire CLI de Vault inclut des **wrappers sp√©cialis√©s**.
Exemple avec KV v2 :

* `vault kv put kv/app/config password=123`
est un alias pratique pour :
`vault write kv/data/app/config data='{"password":"123"}'`

* `vault kv get kv/app/config`
est un alias pour :
`vault read kv/data/app/config`

Ces wrappers n‚Äôexistent que pour certains engines (KV, auth enable/disable, etc.).
On **ne peut pas cr√©er ses propres sous-commandes `vault ...`** c√¥t√© Vault :
- Soit on utilise les commandes g√©n√©riques (`read/write/list/delete`).
- Soit on cr√©e des **alias shell** (bash/zsh) pour son usage.
- Pour Vault lui-m√™me, la seule fa√ßon d‚Äôavoir un nouveau wrapper est de **modifier le CLI en Go** (ou d‚Äôattendre une commande officielle ajout√©e par HashiCorp).

[NOTE]
====
üëâ Donc : *les paths sont la v√©rit√© fondamentale*, les wrappers CLI ne sont que du *sucre syntaxique* pour simplifier l‚Äôusage courant (notamment avec KV v2).
====

=== Bonnes pratiques plugins
* **Versionner** vos plugins (impl√©menter l‚Äôinterface de versioning du SDK) pour simplifier mises √† jour/compatibilit√©. :contentReference[oaicite:12]{index=12}
* **Signer/v√©rifier** (SHA256) et restreindre l‚Äôacc√®s au `plugin_directory`.
* **Limiter** les capabilities via des **policies** d√©di√©es aux paths du plugin.
* **Tests** d‚Äôint√©gration (start Vault, register, enable, hit endpoints).
* **Observabilit√©** : logs c√¥t√© plugin + **audit** c√¥t√© Vault.

=== 8) Exemples & ressources officielles pour d√©marrer
* **Tutoriel ‚ÄúCustom secrets engine‚Äù** (s√©rie compl√®te avec code/paths, build & run). :contentReference[oaicite:13]{index=13}
* **Architecture & Dev plugins** (SDK, interfaces, versioning). :contentReference[oaicite:14]{index=14}
* **Register external plugins** (catalog, r√©pertoires, formats). :contentReference[oaicite:15]{index=15}
* **Exemples GitHub** : *hello-world* / *hashicups* secrets engine. :contentReference[oaicite:16]{index=16}

== Vault ‚Äî Policies (ACL), Capabilities & Patterns

=== Pourquoi des policies ?

Une *policy* d√©finit **qui peut faire quoi, o√π** dans l‚ÄôAPI Vault.
Elle associe un **chemin d‚ÄôAPI** (ex: `kv/data/prod/app/*`, `database/roles/app-db-read`) √† des **capabilities** (droits).

*Les policies ne ‚Äúcr√©ent‚Äù pas d‚Äôidentit√©s.*

Elles sont **attach√©es √† un token** (obtenu via une *auth method* : Kubernetes, OIDC, AppRole‚Ä¶), et Vault √©value alors les droits du token sur chaque requ√™te.

=== Vue d‚Äôensemble : Policies et Roles

* **Policy** = brique √©l√©mentaire.
Elle d√©finit un jeu de droits (capabilities) sur un ou plusieurs chemins de l‚ÄôAPI Vault.

* **Role (c√¥t√© Auth)** = une **agr√©gation de policies** attach√©e √† une identit√© externe.
Exemple : un ServiceAccount Kubernetes, un groupe OIDC, un AppRole.
Quand cette identit√© s‚Äôauthentifie, Vault lui attribue les policies list√©es dans ce r√¥le.
‚Üí C‚Äôest l‚Äô√©quivalent d‚Äôun r√¥le RBAC classique.

* **Token Vault** = contient un ensemble de policies.
Ces policies proviennent soit directement de la cr√©ation du token (`vault token create -policy=...`), soit d‚Äôun *auth role* (Kubernetes, OIDC, AppRole‚Ä¶).

[NOTE]
====
‚ö†Ô∏è Ambigu√Øt√© : le mot *role* est utilis√© aussi c√¥t√© *secrets engines* (Database, PKI, AWS, etc.).
- **Auth Role** ‚Üí fait le lien entre une identit√© (Pod, user OIDC, VM‚Ä¶) et des policies.
- **Secrets Engine Role** ‚Üí d√©crit une *recette de g√©n√©ration de secrets dynamiques* (SQL pour Database, profil de certificat pour PKI, etc.).

Il faut bien distinguer les deux contextes, m√™me si HashiCorp a r√©utilis√© le m√™me terme.
====

=== Les capabilities (droits)
[cols="20,80"]
|===
| Capability | Effet typique

| `read`     | Lire une ressource (ex: `vault kv get`, `GET` API).
| `list`     | Lister les √©l√©ments d‚Äôun pr√©fixe (ex: `vault kv list`, `LIST` API).
| `create`   | Cr√©er une ressource (ex: premi√®re √©criture sur un chemin).
| `update`   | Modifier/√©crire (`vault write`, `POST/PUT` API). *Le CLI `write` mappe vers `create`/`update` selon le cas.*
| `delete`   | Supprimer (ex: `vault kv delete`, `DELETE` API).
| `sudo`     | Actions sensibles (montages `sys/*`, activer/disable engines/auth, etc.). √Ä √©viter pour des tokens applicatifs.
|===

[NOTE]
====
*Par d√©faut tout est refus√©.*
Les permissions s‚Äôadditionnent entre policies attach√©es au token.
La r√®gle la plus **sp√©cifique** l‚Äôemporte. Si un ‚Äúdeny‚Äù explicite existe (rare en OSS), il pr√©vaut.
====

=== Chemins (paths) : bien viser la bonne API
Chaque *secrets engine* expose ses **propres endpoints**.
Exemples usuels :

* **KV v2** : `kv/data/...` (donn√©es), `kv/metadata/...` (liste/versions), `kv/destroy/...`, `kv/undelete/...`
* **Database** : `database/config/...`, `database/roles/...` (config), `database/creds/...` (consommation)
* **Transit** : `transit/encrypt/<key>`, `transit/decrypt/<key>`
* **PKI** : `pki/roles/<role>`, `pki/issue/<role>`

[IMPORTANT]
====
*KV v2* :
- **Lire/√©crire** un secret ‚Üí ciblez **`kv/data/<path>`** (capabilities `read`, `update`).
- **Lister** les cl√©s ‚Üí ciblez **`kv/metadata/<prefix>`** (capability `list`).
- **Supprimer (soft delete)** une *version* ‚Üí `kv/delete/<path>` (capability `update`).
- **D√©truire (destroy)** une *version* ‚Üí `kv/destroy/<path>` (capability `update`).
- **Supprimer tout le secret (metadata)** ‚Üí `kv/metadata/<path>` (capability `delete`).
====

=== Exemples concrets (KV v2)

Lecture simple d‚Äôun secret (et *list* sur le dossier) :

[source,hcl]
----
# Lire les donn√©es (toutes versions via v2)
path "kv/data/prod/app/db" {
  capabilities = ["read"]
}

# Lister les cl√©s sous prod/app/
path "kv/metadata/prod/app/" {
  capabilities = ["list"]
}
----

√âcriture (create/update) et suppression :
[source,hcl]
----
# √âcrire (create/update) le secret
path "kv/data/prod/app/db" {
  capabilities = ["create", "update"]
}

# Supprimer totalement (metadata + toutes versions)
path "kv/metadata/prod/app/db" {
  capabilities = ["delete"]
}
----

Gestion fine des versions :
[source,hcl]
----
# Soft-delete de versions (les donn√©es deviennent "deleted")
path "kv/delete/prod/app/db" {
  capabilities = ["update"]
}

# D√©truire d√©finitivement des versions (irr√©versible)
path "kv/destroy/prod/app/db" {
  capabilities = ["update"]
}

# Restaurer des versions soft-deleted
path "kv/undelete/prod/app/db" {
  capabilities = ["update"]
}
----

=== Exemples concrets (Database engine)

Consommer des identifiants **√©ph√©m√®res** (lecture sur `/creds/‚Ä¶`) :

[source,hcl]
----
# Autoriser l'app √† g√©n√©rer des creds temporaires:
path "database/creds/app-db-read" {
  capabilities = ["read"]
}
----

*Ne pas confondre* avec la **configuration** du r√¥le :
[source,hcl]
----
# VOIR la config du r√¥le (optionnel)
path "database/roles/app-db-read" {
  capabilities = ["read", "list"]
}

# MODIFIER la config du r√¥le (SQL/TTL) - √† r√©server aux ops :
path "database/roles/app-db-read" {
  capabilities = ["update"]  # voire create/delete si besoin
}
----

=== Wildcards & sp√©cificit√©

Vault supporte les jokers :
- `*` : un segment (ou plus) selon le chemin
- `+` : (sur certains endpoints) un segment simple
- `...` : (peut appara√Ætre dans docs historiques, pr√©f√©rez des pr√©fixes clairs)

Privil√©giez des *pr√©fixes explicites* pour √©viter les surprises :
[source,hcl]
----
# Bon: scope pr√©cis par environnement et app
path "kv/data/prod/rr-dev-service/*" { capabilities = ["read"] }

# √Ä √©viter: trop large
path "kv/data/*" { capabilities = ["read"] }
----

[NOTE]
====
La *r√®gle la plus sp√©cifique* l‚Äôemporte si plusieurs chemins matchent.
Organisez vos secrets par `env/app/category/secret` pour √©crire des policies simples et s√ªres.
====

=== Lister (list) : souvent oubli√©
Pour **`vault kv list`** (ou liste des secrets c√¥t√© UI/CLI), il faut une policy d√©di√©e :
[source,hcl]
----
# Lister le dossier => utilisez "metadata"
path "kv/metadata/prod/rr-dev-service/" {
  capabilities = ["list"]
}
----

=== Policy files : HCL vs JSON

Deux formats √©quivalents :
- **HCL** (humain) ‚Üí `vault policy write app-read app-read.hcl`
- **JSON** (machines) ‚Üí `vault policy write app-read @app-read.json`

Format HCL minimal :
[source,hcl]
----
# app-read.hcl
path "kv/data/prod/rr-dev-service/*" {
  capabilities = ["read"]
}

path "kv/metadata/prod/rr-dev-service/" {
  capabilities = ["list"]
}

----

=== Attacher des policies √† un token (via Auth)

Les policies s‚Äôattachent √† l‚Äô**identit√©** au moment du login :

* **Kubernetes Auth** : un *role* associe SA/namespace ‚Üí policies
[source,bash]
----
vault write auth/kubernetes/role/rr-dev-app \
  bound_service_account_names=sa-rr-dev \
  bound_service_account_namespaces=apps \
  policies="rr-dev-read,db-creds" \
  ttl="1h"
----

* **OIDC/JWT (GitLab/GitHub/Keycloak)** : mapping de claims ‚Üí policies
* **AppRole** : r√¥le nomm√© ‚Üí policies (pour VM/batch)

[NOTE]
====
Tous les tokens re√ßoivent la policy `default`.
√âvitez d‚Äôutiliser `root` (acc√®s illimit√©) ailleurs qu‚Äôau bootstrap.
====

=== Restreindre ce qui peut √™tre √©crit (allowed/denied parameters)

Vous pouvez limiter **les champs et valeurs** qu‚Äôun appelant est autoris√© √† √©crire sur un endpoint (utile pour `auth/token/create`, certains engines, etc.).

Exemple (limiter la cr√©ation de tokens c√¥t√© CI) :
[source,hcl]
----
# Autoriser seulement certaines politiques et TTLs √† la cr√©ation de tokens
path "auth/token/create" {
  capabilities = ["update"]
  allowed_parameters = {
    "policies" = ["^app-.*$"]     # doivent commencer par "app-"
    "ttl"      = ["15m", "30m"]   # valeurs autoris√©es
  }
  denied_parameters = {
    "no_default_policy" = ["true"]  # interdit de retirer la policy 'default'
  }
}
----

=== Wrapping (contrainte de TTL du wrapping)

Vous pouvez contraindre les *response-wrapping tokens* (jetons one-shot) :
[source,hcl]
----
path "kv/data/prod/rr-dev-service/*" {
  capabilities = ["read"]
  min_wrapping_ttl = "10s"
  max_wrapping_ttl = "5m"
}
----

=== Bonnes pratiques (√©tat de l‚Äôart)
* **Structure claire** des paths secrets : `kv/<env>/<app>/<category>/<secret>`
* **Policies par app** et par **environnement** (√©vitez les globaux)
* **Toujours s√©parer** *consommation* et *configuration* (ex: `database/creds/*` ‚â† `database/roles/*`)
* **N‚Äôaccordez pas `sudo`** aux workloads applicatifs
* **Pensez √† `list`** (KV v2 ‚Üí sur `metadata/`) pour la d√©couvrabilit√©
* **GitOps** : versionnez policies & roles (Terraform / Helm / repo ‚Äúiam-vault‚Äù)
* **Principe du moindre privil√®ge** : r√©duisez le scope au strict n√©cessaire
* **Audit activ√©** c√¥t√© Vault (traces des acc√®s)

=== Anti-patterns courants
* Donner `update` sur `database/roles/*` √† une app ‚Üí elle pourrait **modifier le SQL** de g√©n√©ration des comptes.
* Oublier `list` sur `kv/metadata/...` ‚Üí impossible de lister les cl√©s c√¥t√© CLI/UI.
* Utiliser des politiques trop larges (`kv/data/*`) ‚Üí risque d‚Äôexfiltration.
* Confondre **KV v1 vs v2** (chemins diff√©rents). En v2, c‚Äôest `data/` pour lire/√©crire,

== Vault ‚Äî Secrets dynamiques Database (PostgreSQL)

=== KV vs ‚ÄúDatabase engine‚Äù (la diff√©rence fondamentale)

*KV v2* = stockage **statique** de paires cl√©/valeur (vous √©crivez et relisez).
*Database engine* = secrets **dynamiques** g√©n√©r√©s **√† la demande** par un **plugin** (ici PostgreSQL).
Quand vous lisez `database/creds/<role>`, Vault :
1. se connecte √† votre base avec un **compte administrateur** configur√©,
2. ex√©cute des **instructions SQL** (d√©finies dans le *role Vault*) pour **cr√©er un user temporaire**,
3. renvoie `username/password` **avec TTL** + un **lease_id** (renouvelable/r√©vocable).

=> L‚Äô√©ph√©m√©rit√© vient de la **d√©finition du r√¥le** (TTL, SQL), pas de la commande `read` en soi.

=== Pr√©-requis (exemple)

* Un PostgreSQL accessible (ici un Service K8s `pg.apps.svc:5432`, base `demo`)
* Un **compte admin** Postgres qui peut `CREATE ROLE`, `GRANT`, etc. (ici `demo/supersecret`)
* Vault d√©ploy√© et joignable (ex: `http://vault.vault.svc:8200`)

=== Activer et configurer le moteur Database

[source,bash]
----
# (si n√©cessaire) Activer le secrets engine "database" au point de montage /database
vault secrets enable database

# D√©clarer une connexion "demo-postgres"
vault write database/config/demo-postgres \
  plugin_name=postgresql-database-plugin \
  allowed_roles="app-db-read,app-db-readwrite" \
  connection_url="postgresql://{{username}}:{{password}}@pg.apps.svc.cluster.local:5432/demo?sslmode=disable" \
  username="demo" \
  password="supersecret"
----

Explications :
* `plugin_name` : le plugin utilis√© (ici PostgreSQL).
* `connection_url` : gabarit que Vault utilise **avec** `username`/`password` ci-dessus pour se connecter en admin.
* `allowed_roles` : la liste des *r√¥les Vault* autoris√©s √† utiliser cette connexion.

=== Comprendre la structure des chemins Database

Une fois le moteur Database activ√©, Vault expose plusieurs *endpoints* d‚ÄôAPI.
Cette structure est d√©finie par le plugin (ex: `postgresql-database-plugin`) :

* `database/config/<name>` ‚Üí configuration d‚Äôune connexion DB (plugin, URL, user admin).
* `database/roles/<role>` ‚Üí d√©finition d‚Äôun r√¥le Vault : SQL de cr√©ation d‚Äôutilisateurs √©ph√©m√®res, TTL, droits.
* `database/creds/<role>` ‚Üí consommation d‚Äôun r√¥le : g√©n√®re un login/mot de passe temporaire √† la demande.
* `database/static-roles/<role>` ‚Üí gestion d‚Äôun compte fixe dont Vault assure la rotation r√©guli√®re.
* `database/rotate-root/<name>` ‚Üí rotation des credentials administrateur d√©clar√©s dans `config/<name>`.

[NOTE]
====
La logique est toujours la m√™me :

- **/roles/** = d√©finition de la recette (SQL + TTL)
- **/creds/** = ex√©cution de cette recette ‚Üí secrets dynamiques √©ph√©m√®res
- **/config/** = configuration de la connexion DB elle-m√™me
====

=== Cr√©er un r√¥le Vault (SQL embarqu√© + TTL)

Un **r√¥le Vault** (ici `app-db-read`) d√©crit **comment cr√©er** l‚Äôutilisateur √©ph√©m√®re et sa **dur√©e de vie**.

[source,bash]
----
vault write database/roles/app-db-read \
  db_name=demo-postgres \
  creation_statements="CREATE ROLE \"{{name}}\" WITH LOGIN PASSWORD '{{password}}' VALID UNTIL '{{expiration}}';
                      GRANT CONNECT ON DATABASE demo TO \"{{name}}\";
                      GRANT USAGE ON SCHEMA public TO \"{{name}}\";
                      GRANT SELECT ON ALL TABLES IN SCHEMA public TO \"{{name}}\";" \
  default_ttl="1h" \
  max_ttl="24h"
----

Points cl√©s :
* **Variables fournies par Vault** dans le SQL :
* `{{name}}` : nom d‚Äôutilisateur g√©n√©r√© (unique, tra√ßable)
* `{{password}}` : mot de passe al√©atoire
* `{{expiration}}` : date d‚Äôexpiration (selon `default_ttl`/`max_ttl`)
* `default_ttl`, `max_ttl` : TTL du secret (lease).

* Par d√©faut, la **r√©vocation** supprimera l‚Äôutilisateur (DROP ROLE). Vous pouvez personnaliser :

[source,bash]
----
vault write database/roles/app-db-read \
  db_name=demo-postgres \
  creation_statements="..." \
  revocation_statements="REVOKE ALL PRIVILEGES ON ALL TABLES IN SCHEMA public FROM \"{{name}}\"; DROP ROLE IF EXISTS \"{{name}}\";" \
  default_ttl="1h" max_ttl="24h"
----

(Optionnel) Un r√¥le **lecture/√©criture** :

[source,bash]
----
vault write database/roles/app-db-readwrite \
  db_name=demo-postgres \
  creation_statements="CREATE ROLE \"{{name}}\" WITH LOGIN PASSWORD '{{password}}' VALID UNTIL '{{expiration}}';
                      GRANT CONNECT ON DATABASE demo TO \"{{name}}\";
                      GRANT USAGE ON SCHEMA public TO \"{{name}}\";
                      GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO \"{{name}}\";" \
  default_ttl="30m" \
  max_ttl="8h"
----

=== G√©n√©rer des identifiants (lecture = g√©n√©ration)

Lire `database/creds/<role>` **g√©n√®re** un nouvel utilisateur :

[source,bash]
----
vault read database/creds/app-db-read
----

Exemple de sortie (simplifi√©e) :

[source,bash]
----
Key Value

lease_id database/creds/app-db-read/e1c...9a
lease_duration 1h
lease_renewable true
password Xy7!9abC
username v-root-app-db-read-1730833381-1
----

* `lease_id` : identifiant du lease (utile pour renew/revoke)
* `lease_duration` : TTL initial (ici 1h)
* `username/password` : **√©ph√©m√®res** ; expirent √† `{{expiration}}` (VALID UNTIL).

=== Tester l‚Äôacc√®s Postgres

Depuis un Pod outillage ou ta machine (avec `psql`) :

[source,bash]
----
export PGHOST=pg.apps.svc.cluster.local
export PGDATABASE=demo
export PGUSER="v-root-app-db-read-1730833381-1"   # <- username renvoy√© par Vault
export PGPASSWORD="Xy7!9abC"                      # <- password renvoy√©
psql -c '\du' | head
psql -c 'SELECT current_user, now();'
----

=== Cycle de vie du secret (leases)

Lister / renouveler / r√©voquer :

[source,bash]
----
# (1) G√©n√©rer et capturer le JSON
vault read -format=json database/creds/app-db-read | tee /tmp/creds.json

# (2) R√©cup√©rer le lease_id
LEASE_ID=$(jq -r .lease_id /tmp/creds.json)

# (3) Renouveler avant expiration (si autoris√© et < max_ttl)
vault lease renew "$LEASE_ID"

# (4) R√©voquer imm√©diatement (DROP ROLE + nettoyage)
vault lease revoke "$LEASE_ID"
----

Quand le TTL arrive √† √©ch√©ance (et si non renouvel√©), Vault d√©clenche la **r√©vocation** (par d√©faut : suppression de l‚Äôutilisateur).

== Donner l‚Äôacc√®s aux apps (policies + auth + injector/CSI)

=== Policy minimale (lecture du r√¥le dyn. uniquement)

[source,hcl]
----
# app-db.hcl
path "database/creds/app-db-read" {
  capabilities = ["read"]
}
----

[source,bash]
----
vault policy write app-db app-db.hcl
----

=== Auth Kubernetes (lier SA -> r√¥le Vault -> policy)

[source,bash]
----
# Si pas fait :
vault auth enable kubernetes

# Config globale kubernetes (API server, CA, reviewer_jwt) - cf. TP pr√©c√©dent
# vault write auth/kubernetes/config kubernetes_host=... token_reviewer_jwt=... kubernetes_ca_cert=...

# Cr√©er le r√¥le Vault "app-db" pour les pods avec le SA "sa-app-reader" du ns "apps"
vault write auth/kubernetes/role/app-db \
  bound_service_account_names=sa-app-reader \
  bound_service_account_namespaces=apps \
  policies="app-db" \
  ttl=1h
----

=== Injection c√¥t√© Pod (sidecar Vault Agent)

[source,yaml]
----
apiVersion: v1
kind: Pod
metadata:
  name: injector-db
  namespace: apps
  annotations:
    vault.hashicorp.com/agent-inject: "true"
    vault.hashicorp.com/role: "app-db"
    # Rend le JSON brut renvoy√© par /database/creds/app-db-read
    vault.hashicorp.com/agent-inject-secret-db-creds: "database/creds/app-db-read"
    # (Optionnel) Mise en forme personnalis√©e :
    vault.hashicorp.com/agent-inject-file-db-creds: "db/credentials.json"
    vault.hashicorp.com/agent-inject-template-db-creds: |
      {{- with secret "database/creds/app-db-read" -}}
      {{ toJSON .Data }}
      {{- end -}}
spec:
  serviceAccountName: sa-app-reader
  containers:
  - name: app
    image: busybox
    command: ["sh","-lc","find /vault/secrets -type f -maxdepth 3 -print -exec echo '----' \\; -exec cat {} \\; ; sleep 3600"]
----

=== Alternative CSI (montage volume)

D√©finir un `SecretProviderClass` qui lit `database/creds/app-db-read`, puis monter le volume CSI (cf. section d√©di√©e CSI).

== Rotation des *root creds* (s√©curit√© admin)

Le compte admin (`username=password` dans `database/config/...`) peut √™tre **rotat√©** par Vault pour √©viter l‚Äôexposition :

[source,bash]
----
vault write -f database/rotate-root/demo-postgres
# V√©rifier :
vault read database/config/demo-postgres
----

== Bonnes pratiques & pi√®ges

* **Ne stockez pas** de `db/password` statique en KV pour la prod ‚Üí pr√©f√©rez **secrets dynamiques**.
* Ajoutez `revocation_statements` adapt√©s √† votre politique (DROP ROLE, REVOKE, nettoyage d‚Äôobjets si besoin).
* Si vos apps cr√©ent de **nouvelles tables** au runtime, pensez aux **default privileges** Postgres (pour donner SELECT/INSERT by default √† un r√¥le).
* TTL : choisissez `default_ttl` **court** (ex. 15‚Äì60 min) et `max_ttl` raisonnable.
* Sur Kubernetes, pr√©f√©rez **Kubernetes Auth** + **Injector/CSI** pour l‚Äôergonomie et la rotation continue.
* Activez l‚Äô**audit** c√¥t√© Vault (file/socket) pour tracer la g√©n√©ration/lecture/r√©vocation.

== R√©sum√©

1. *Database engine* ‚â† KV : ici, `read` **g√©n√®re** un secret via un **plugin** (SQL ex√©cut√© c√¥t√© DB).
2. Vous **configurez** la connexion admin (`database/config/...`).
3. Vous **d√©finissez** un **r√¥le Vault** (`database/roles/<role>`) avec :
* `creation_statements` (SQL de cr√©ation + droits),
* `default_ttl` / `max_ttl`,
* (optionnel) `revocation_statements`, `rollback_statements`, `renew_statements`.
4. Vous **consommez** via `database/creds/<role>` ‚Üí `username/password` **√©ph√©m√®res** + `lease`.
5. Vous **renouvelez/r√©voquez** via les commandes `lease`.
6. Vous **exposez** aux apps via **policy + auth method** (K8s OIDC AppRole) et **Injector/CSI**.





== Vault ‚Äî PKI Secrets Engine (vue compl√®te)

=== D√©finitions fondamentales

* **PKI (Public Key Infrastructure)**
Une **infrastructure de gestion de cl√©s publiques**.
Elle regroupe :
- **Une ou plusieurs Autorit√©s de Certification (CA)** (root et interm√©diaires),
- les **certificats √©mis** (serveurs, clients, services, etc.),
- les **m√©canismes de validation** (CRL, OCSP, AIA),
- les **politiques de cycle de vie** (dur√©e de validit√©, r√©vocation, renouvellement, etc.).

  üëâ Ce n‚Äôest donc **pas seulement une CA** : c‚Äôest **tout l‚Äô√©cosyst√®me** permettant de faire confiance aux certificats.

* **CA (Certificate Authority)**
Une **entit√© (ou cl√© priv√©e)** qui peut **signer des certificats**.
- Une **Root CA** est auto-sign√©e et constitue la racine de confiance.
- Une **Intermediate CA** est sign√©e par une autre CA (souvent la Root).
- Un **Leaf certificate** (serveur ou client) est sign√© par une CA (souvent interm√©diaire).

  üëâ Une PKI peut contenir **plusieurs CA** (root + interm√©diaires).

* **PKI Secrets Engine dans Vault**
Vault ne se contente pas de stocker des certificats :
- il peut **jouer le r√¥le de CA** (root ou interm√©diaire),
- il peut **signer des CSR** g√©n√©r√©s ailleurs,
- il peut **√©mettre automatiquement des certificats** courts via des r√¥les,
- il g√®re **CRL, OCSP et AIA** (consultation √† distance des cl√©s publiques).

  üëâ Autrement dit : **Vault fournit une CA fonctionnelle + un service PKI complet** via des endpoints API. La diff√©rence essentielle avec une pki est qu'un pki vault n'est associ√©e qu'√† un seul certificat. Ce n'est donc qu'un maillon de la chaine de certification.

=== Step by step explanation

==== Cr√©er le mount root pki

[source,bash]
----
# On utilise le plugin pki pour cr√©er notre pki root (certificat + capacit√©s suppl√©mentaires d'une pki)
vault secrets enable -path=pki-root pki
vault secrets tune -description="Company Root CA" pki-root
----

vault secrets tune permets de manipuler les param√®tres du certificat, voici un exemple exhaustif de ses capacit√©s:

[source,bash]
----
vault secrets tune \
  -description="Root CA PKI" \                 # Description textuelle du secrets engine
  -default-lease-ttl=8760h \                   # TTL par d√©faut des secrets (ici 1 an pour les certs)
  -max-lease-ttl=87600h \                      # TTL maximum autoris√© (ici 10 ans pour les certs)
  -force-no-cache=false \                      # D√©sactiver (true) ou activer (false) le cache interne des secrets
  -plugin-version="" \                         # Sp√©cifie la version du plugin s‚Äôil y en a un (utile pour plugins externes)
  -audit-non-hmac-request-keys="" \            # Liste de cl√©s de requ√™te √† √©crire en clair dans les logs d‚Äôaudit
  -audit-non-hmac-response-keys="" \           # Liste de cl√©s de r√©ponse √† √©crire en clair dans les logs d‚Äôaudit
  -passthrough-request-headers="" \            # Liste des en-t√™tes HTTP que Vault peut transmettre directement au backend
  -allowed-response-headers="" \               # Liste des en-t√™tes HTTP autoris√©s √† √™tre retourn√©s par le backend
  pki-root
----

[NOTE]
--
En pratique on utilise en priorit√© **-description**, **-default-lease-ttl**, **-max-lease-ttl** et √©ventuellement **-force-no-cache**, qui d√©sactive le m√©canisme de cache interne de vault, afin d'obtenir avec certitude le certificat.
--

[IMPORTANT]
--
les ttl concernent les certificats qui seront cr√©√©s, cela peut √™tre surcharg√© par la commande write dans la limite du max-lease-ttl
--

A ce stade on a notre pki root, que l'on a tunn√© uniquement par desription conform√©mement √† la remarque pr√©c√©dente

=== Endpoints d‚Äôun PKI mount (structure standard)

On appelle notre pki un **mount** PKI. D√®s lorsque l'on a un mount pki on dispose des api suivantes. A noter que root/ et intermediate/ sont disponibles, mais il est incoh√©rent de les utiliser sur une m√™me pki.

Voici la vue compl√®te :

[source,bash]
----
pki-<name>/
‚îú‚îÄ‚îÄ root/
‚îÇ   ‚îú‚îÄ‚îÄ generate/internal
‚îÇ   ‚îÇ   # write : g√©n√®re une Root CA auto-sign√©e
‚îÇ   ‚îÇ   # (cl√© priv√©e conserv√©e par Vault).
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ generate/exported
‚îÇ   ‚îÇ   # write : g√©n√®re une Root CA auto-sign√©e
‚îÇ   ‚îÇ   # (cl√© priv√©e export√©e, hors de Vault).
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ generate/existing
‚îÇ       # write : importe une Root CA d√©j√† existante
‚îÇ       # (certificat + cl√© priv√©e fournis).
‚îÇ
‚îú‚îÄ‚îÄ intermediate/
‚îÇ   ‚îú‚îÄ‚îÄ generate/internal
‚îÇ   ‚îÇ   # write : g√©n√®re une CSR pour un interm√©diaire
‚îÇ   ‚îÇ   # (cl√© priv√©e g√©r√©e et stock√©e dans Vault).
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ generate/exported
‚îÇ   ‚îÇ   # write : g√©n√®re une CSR pour un interm√©diaire
‚îÇ   ‚îÇ   # (cl√© priv√©e export√©e en dehors de Vault).
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ set-signed
‚îÇ       # write : importer le certificat sign√© par une Root
‚îÇ       # pour activer l‚Äôinterm√©diaire.
‚îÇ
‚îú‚îÄ‚îÄ roles/<role_name>
‚îÇ   # read/write : d√©finir les r√®gles d‚Äô√©mission des leafs :
‚îÇ   #   - TTL min/max
‚îÇ   #   - domaines autoris√©s (CN, SAN)
‚îÇ   #   - usages autoris√©s (serverAuth, clientAuth, etc.)
‚îÇ   #   - contraintes diverses (wildcards, etc.)
‚îÇ
‚îú‚îÄ‚îÄ issue/<role_name>
‚îÇ   # write : √©met un certificat leaf complet
‚îÇ   # (cl√© + cert + chain) selon les r√®gles du r√¥le.
‚îÇ
‚îú‚îÄ‚îÄ sign/<role_name>
‚îÇ   # write : signe un CSR externe
‚îÇ   # en appliquant les r√®gles du r√¥le indiqu√©.
‚îÇ
‚îú‚îÄ‚îÄ cert/ca
‚îÇ   # read : lire le certificat CA actif (root ou interm√©diaire).
‚îÇ   # Utilis√© pour distribuer la cha√Æne de confiance.
‚îÇ
‚îú‚îÄ‚îÄ certs/<serial>
‚îÇ   # list : liste tous les certificats √©mis (par num√©ro de s√©rie).
‚îÇ   # read : lire un certificat sp√©cifique.
‚îÇ
‚îú‚îÄ‚îÄ issuers/<issuer_id>
‚îÇ   # list : liste tous les issuers (cert+cl√©) de ce mount.
‚îÇ   # read : d√©tail d‚Äôun issuer (cert, m√©tadonn√©es, associations).
‚îÇ   # write : config avanc√©e (ex: d√©finir l‚Äôissuer par d√©faut).
‚îÇ
‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îú‚îÄ‚îÄ ca
‚îÇ   ‚îÇ   # read : affiche l‚Äôissuer CA par d√©faut.
‚îÇ   ‚îÇ   # write : changer de CA par d√©faut pour ce mount.
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ urls
‚îÇ   ‚îÇ   # read/write : configure les AIA/CRL/OCSP endpoints.
‚îÇ   ‚îÇ   # => indispensable pour que les clients TLS puissent
‚îÇ   ‚îÇ   # reconstruire la cha√Æne et valider la r√©vocation.
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ crl
‚îÇ   ‚îÇ   # read/write : configure la g√©n√©ration des CRLs
‚îÇ   ‚îÇ   # (dur√©e, fr√©quence, activation/d√©sactivation).
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ cluster
‚îÇ       # read/write : config cluster HA/multi-DC.
‚îÇ       # Synchronisation des CRL/URLs en r√©plication.
‚îÇ
‚îú‚îÄ‚îÄ crl
‚îÇ   ‚îú‚îÄ‚îÄ pem
‚îÇ   ‚îî‚îÄ‚îÄ der
‚îÇ   # read : t√©l√©charger la CRL (Certificate Revocation List).
‚îÇ   # Contient la liste des certificats r√©voqu√©s.
‚îÇ
‚îú‚îÄ‚îÄ ocsp
‚îÇ   # read : endpoint OCSP (Online Certificate Status Protocol).
‚îÇ   # Permet la v√©rification en ligne du statut des certificats.
‚îÇ
‚îî‚îÄ‚îÄ tidy
    # write : lance le nettoyage des certificats expir√©s,
    # cl√©s orphelines et m√©tadonn√©es devenues inutiles.
----

=== Cr√©er le root certificate

On cr√©√© alors le root certificat associ√© √† notre root pki, c'est ici que l'on sp√©cifie le ttl, tr√®s long pour un root, pour ne pas avoir √† le renouveller, 10 ans ici.

[source,bash]
----
vault write pki-root/root/generate/internal \
    common_name="Company Root CA" \
    ttl=87600h
----

Il est possible de lire le certificat ici
[source,bash]
----
vault read pki-root/cert/ca
----

=== Cr√©ation du mount pki intermediate

[source,bash]
----
vault secrets enable -path=pki-int pki
# On configure le max lease
# Si on ne pr√©cise rien il durent 30 jours, sinon c'est max 1 an
vault secrets tune -description="Company Intermediate CA for .." \
  -default-lease-ttl=720h \       # 30 jours par d√©faut
  -max-lease-ttl=8760h \          # 1 an maximum
  pki-int
----

On configure les urls pour qu'ils soient greff√©s dans les certificats.

[source,bash]
----
vault write pki-int/config/urls \
    issuing_certificates="http://vault.company.local/v1/pki-bpce-tools-int-a/ca" \
    crl_distribution_points="http://vault.company.local/v1/pki-bpce-tools-int-a/crl" \
    ocsp_servers="http://vault.company.local/v1/pki-bpce-tools-int-a/ocsp"
----

Une fois le mount g√©n√©r√© on g√©n√®re sa csr que l'on fait signer par le root ca. Puis on la charge.

.G√©n√©ration de l'intermediate ca
[source,bash]
----
vault write pki-int/intermediate/generate/internal \
    common_name="Company Intermediate CA" \
    ttl=8760h \
    > pki_intermediate.csr
----

La csr ressemble ici √† quelque chose comme ceci :

[source,bash]
----
{ "request_id": "93d77131-547e-4711-d8dd-e4493c9ee1a7", "lease_id": "", "lease_duration": 0, "renewable": false, "data": { "csr": "-----BEGIN CERTIFICATE ... }, "warnings": null, "mount_type": "pki" }
----

Il faut selectionner uniquement le certificat

[source,bash]
----
grep '"csr"' pki_intermediate.csr \
  | cut -d '"' -f4 \
  | sed 's/\\n/\n/g' > pki_intermediate.csr
----

Ou plus simple:

[source,bash]
----
vault write pki-int/intermediate/generate/internal \
    common_name="Company Intermediate CA" \
    ttl=8760h | jq -r '.data.csr' > pki_intermediate.csr
----

On signe avec le root CA

[source,bash]
----
vault write pki-root/root/sign-intermediate \
    csr=@pki_intermediate.csr \
    format=pem_bundle \
    ttl=43800h \
    > pki_intermediate.pem
----

on garde de m√™me uniquement l'intermediate sign√©

[source,bash]
----
jq -r '.data.ca_chain[0]' pki_intermediate_bpce_a.json > intermediate_only.pem
----

Enfin on importe le ceritifcat sign√© pour l'intermediate, cr√©ant ainsi le haut de la chaine

[source,bash]
----
vault write pki-int/intermediate/set-signed certificate=@intermediate_only.pem
----

Nous avons ici le socle, notre root ca et notre intermediate ca.

=== Configurer le CRL

[source,bash]
----
vault write pki-int/config/crl expiry="72h"
----

Cette commande configure l‚Äôendpoint **CRL (Certificate Revocation List)** de la PKI mont√©e √† `pki-int`.

L‚Äôoption `expiry="72h"` signifie :

* Chaque CRL √©mise par cet intermediate sera valable **72 heures**.

* Quand tu r√©voques un certificat avec :

[source,bash]
----
vault write pki-int/revoke serial_number=...
----
Vault marque le certificat comme **revoked**.

* La CRL (fichier listant les certificats r√©voqu√©s) est r√©g√©n√©r√©e r√©guli√®rement.
* Cette CRL inclut une dur√©e de validit√© (`Next Update` dans l‚Äôextension X.509). Ici : **72h**.
* Les clients TLS (navigateurs, OpenSSL, Java, etc.) savent qu‚Äôils doivent redemander une CRL √† l‚ÄôURL publi√©e avant cette √©ch√©ance.

=== Cr√©ation du role, template de nos leaf certificats

Voici une version exhaustive des options d'une role, qui est un template pour nos leaf certificats:

[source,bash]
----
vault write pki-int/roles/web-servers \
allowed_domains="rr-dev.dev,*.rr-dev.dev" \        # Domaines autoris√©s pour les CN/SAN
allow_subdomains=true \                              # Autorise les sous-domaines si pas explicitement list√©s
allow_bare_domains=false \                           # Autorise (ou non) le domaine "nu" (ex: rr-dev.dev sans sous-domaine)
allow_glob_domains=false \                           # Autorise les glob patterns (ex: *.dev.*)
allow_wildcard_certificates=true \                   # Autorise les certificats wildcard (*.rr-dev.dev)
allow_ip_sans=false \                                # Autorise ou interdit les IP dans les SAN
allow_any_name=false \                               # Autorise n‚Äôimporte quel CN (‚ö†Ô∏è attention s√©curit√©)
allow_localhost=false \                              # Autorise "localhost" comme CN/SAN
key_type="rsa" \                                     # Type de cl√© par d√©faut : rsa, ec, ed25519
key_bits=2048 \                                      # Taille de cl√© RSA (2048, 3072, 4096)
key_usage="DigitalSignature,KeyEncipherment" \       # X.509 Key Usage
ext_key_usage="ServerAuth,ClientAuth" \              # Extended Key Usage : TLS serveur/client
require_cn=false \                                   # Exige que CN soit pr√©sent (sinon SAN uniquement)
server_flag=true \                                   # Marque le certificat comme utilisable pour un serveur TLS
client_flag=false \                                  # Marque le certificat comme utilisable pour un client TLS
enforce_hostnames=true \                             # V√©rifie que CN/SAN match un des allowed_domains
max_ttl="720h" \                                     # TTL max pour les certs √©mis (ici 30j)
ttl="168h" \                                         # TTL par d√©faut si non sp√©cifi√© (ici 7j)
no_store=false \                                     # Ne pas stocker le cert dans Vault (utile si confidentialit√© forte)
generate_lease=true \                                # Associer un lease √† chaque certificat √©mis
use_csr_common_name=true \                           # Si CSR fourni : utiliser le CN du CSR
use_csr_sans=true \                                  # Si CSR fourni : utiliser les SAN du CSR
allow_spiffe_uri_sans=false \                        # Autorise URI SAN type spiffe://...
allowed_uri_sans="" \                                # Liste de SAN URI explicitement autoris√©s
allowed_user_ids="" \                                # Autoriser des user IDs comme SAN
allowed_other_sans="" \                              # Liste de SAN "OtherName" autoris√©s
allow_wildcard_certificates=true \                   # Autorise *.domain.tld
enforce_only_sans=false                              # Si true ‚Üí ignore CN, oblige SAN
----

On choisit :

[source,bash]
----
vault write pki-int/roles/web-servers \
  allowed_domains="rr-dev.dev,*.rr-dev.dev" \
  allow_subdomains=true \
  allow_wildcard_certificates=true \
  key_type="rsa" \
  key_bits=2048 \
  key_usage="DigitalSignature,KeyEncipherment" \
  ext_key_usage="ServerAuth,ClientAuth" \
  max_ttl="8760h"
----

=== Utiliser notre role

On peut d√©sormais cr√©er nos certificats et les utiliser de la fa√ßon suivante:

[source,bash]
----
vault write -format=json pki-int/issue/web-servers \
    common_name="app.rr-dev.dev" ttl="720h" > cert.json

jq -r .data.certificate cert.json > cert.pem
jq -r .data.private_key cert.json > key.pem
jq -r .data.issuing_ca cert.json > ca.pem
jq -r '.data.ca_chain[]' cert.json > chain.pem
----

=== Notions cl√©s

* **PKI mount** : point de montage (ex: `pki/`) qui h√©berge la CA, les r√¥les et les endpoints d‚Äô√©mission.
* **Role PKI** : profil d‚Äô√©mission (noms autoris√©s, TTL max, SANs‚Ä¶).
(‚ö†Ô∏è √† distinguer des *auth roles*)
* **Paths principaux** :
- `pki/root/generate/internal` : g√©n√©rer une **CA racine** interne
- `pki/intermediate/generate/internal` : g√©n√©rer une **CA interm√©diaire** (CSR)
- `pki/root/sign-intermediate` : signer l‚Äôinterm√©diaire
- `pki/roles/<role>` : d√©clarer un profil d‚Äô√©mission
- `pki/issue/<role>` : √©mettre un **leaf certificate**
- `pki/revoke` : r√©voquer un certificat
- `pki/config/urls` : publier les URLs (CRL, AIA)
- `pki/tidy` : nettoyage CRL/objets expir√©s


=== Policies minimales (s√©paration √©mission vs config)

[source,hcl]
----
# √âmettre des certs (apps)
path "pki/issue/xxx" {
  capabilities = ["update"]
}

# Voir la CA (optionnel pour cha√Ænage)
path "pki/ca" {
  capabilities = ["read"]
}

# ADMIN PKI (ops uniquement)
path "pki/roles/*" { capabilities = ["read", "update", "list"] }
path "pki/*"       { capabilities = ["read", "update"] } # si besoin, plus granulaire
----
[NOTE]
====
Ne donne **jamais** √† une app l‚Äôacc√®s en √©criture sur `pki/roles/*` : elle pourrait √©largir les CN/SAN autoris√©s.
====

== Automatisation du TLS dans K8S (Ingress, IngressRoute, GatewayAPI)

L'automatisation repose enti√®rement sur la relation entre cert-manager et vault. vault doit √™tre reconnu comme ayant la capacit√© √† signer les certificats aupr√®s de cert-manager, et cert-manager doit √™tre autoris√© par vault √† les signer. Cette double relation de confiance s'√©tablit comme ceci :


=== √âtape 1 : activer l‚Äôauthentification Kubernetes

En introduction nous devons fournir √† vault la capacit√© de v√©rifier les token pr√©sent√©s afin de v√©rifier la validit√©. Pour ce faire nous devons activer l'authentification kubernetes dans vault et lui fournir le service account utilis√© par vault, le endpoint l'api-server

[source,bash]
----
vault auth enable kubernetes
----

Cela cr√©e le moteur d‚Äôauth √† l‚Äôemplacement `auth/kubernetes/`.

=== Configurer Vault pour dialoguer avec Kubernetes

[source,bash]
----
vault write auth/kubernetes/config \
    kubernetes_host="https://$KUBERNETES_PORT_443_TCP_ADDR:443" \
    kubernetes_ca_cert=@/var/run/secrets/kubernetes.io/serviceaccount/ca.crt \
    token_reviewer_jwt="$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)"
----

On fournit √† vault :

* **kubernetes_host**: c'est l'ip ou le service de l'api server, en utilisant la variable d'environnement on utilise l'ip, c'est gr√¢ce √† cela que vault sait ou envoyer ses demandes
* **token_reviewer_jwt**: C'est le token que vault fournit pour attester du fait qu'il a le droit de v√©rifier les tokens. En amont vault cr√©√© un service account vault qu'il monte sur son pod. En parrall√®le il a cr√©√© un rolebinding qui donne le role `system:auth-delegator`, c'est ce r√¥le qui donne le droit √† vault de cr√©er des tokenreview, qui permettent de v√©rifier les tokens.
* **kubernetes_ca_cert**: le certificat root est n√©cessaire √† l'√©tablissement d'une connexion s√©curis√© √† l'instar de n'importe quel connexion s√©curis√© qui doit avoir dans son trust store local le certificat racine. Cela permets de v√©rifier que c'est bien le root ca associ√© qui a sign√© le certificat pr√©sent√© par l'api server.

Avec cette combinaison, vault est en mesure d'√©tablir une connexion s√©curis√©e avec l'api server, afin de v√©rifier l'authenticit√© des tokens.

=== ClusterIssuer & Issuer : le lien entre cert-manager et Vault

Un `ClusterIssuer` (non namespaced) ou un `Issuer` est un **objet Kubernetes (CRD)** fourni par *cert-manager*.
Il d√©finit une **autorit√© de certification (AC)** utilisable dans tout le cluster et encapsule la fa√ßon dont les certificats doivent √™tre obtenus :

* **AC publique** (ex: Let's Encrypt via ACME),
* **AC interne** (ex: Vault PKI, Venafi, CA locale),
* **ou un Secret K8s** contenant directement une cl√© signataire.

En r√©sum√©, c‚Äôest le **lien entre cert-manager et Vault** dans notre architecture.

=== Pourquoi en avons-nous besoin ?

Notre Vault sait signer des certificats via l‚Äôendpoint :

[source,bash]
----
vault write pki-.../sign/web-servers ...
----

Mais les objets Kubernetes (Ingress, IngressRoute, Gateway API) ne savent pas parler directement √† Vault.
C‚Äôest l√† que *cert-manager* intervient :

. D√©tecte qu‚Äôun objet `Certificate` est cr√©√©.
. Lit la r√©f√©rence `issuerRef`.
. Appelle le `ClusterIssuer` ou l'`Issuer` (ici ‚Üí Vault).
. R√©cup√®re le certificat √©mis (cert + cl√© + CA).
. Stocke le tout dans un Secret Kubernetes (`tls.crt`, `tls.key`, `ca.crt`).

Ainsi, les composants K8s n‚Äôont plus besoin d‚Äôappeler Vault directement :
ils consomment simplement les Secrets TLS g√©n√©r√©s et mis √† jour automatiquement.

Plut√¥t que de setter manuellement les certificats dans tous nos ingress, on utilisera cert-manager pour qu'il s'occupe de la rotation des certificats.

=== Cr√©ation de l'issuer

On cr√©√© tout d'abord le service account qui sera pr√©sent√© par l'issuer (c'est lui qui fera la demande de signature, c'est lui qui sera pr√©sent√© √† vault, c'est donc √† lui qu'il faudra donner les bon roles vault).

[source,bash]
----
apiVersion: v1
kind: ServiceAccount
metadata:
  name: issuer-sa
  namespace: <namespace_pour_le_cert>
----

Dans le cas d'un clusterIssuer, le namespace dans lequel cr√©er le service account utilis√© est celui mis au d√©marrage du cert-manager via l'option **--cluster-resource-namespace**

.si on veut un issuer
[source,bash]
----
apiVersion: v1
kind: ServiceAccount
metadata:
  name: issuer-sa
  namespace: <namespace_cluster_ressource>
----

.si on veut un cluster issuer
[source,bash]
----
apiVersion: v1
kind: ServiceAccount
metadata:
  name: issuer-sa
  namespace: cert-manager # √† v√©rifier c√¥t√© param cert-manager
----

Lorsque cert-manager tentera de signer un certificat, il cr√©era tout d'abord un token pour ce service account, et pr√©sentera ce token √† vault, il faut donc lui donner √† cert-manager via son serviceaccount cert-manager de cr√©er des token pour le service account issuer-sa. En clusterIssuer, le serviceaccount de l'issuer est cr√©√© dans le namespace cert-manager, donc devrait avoir les droits pour cr√©er des service account, mais on peut le cr√©er tout de meme par souci de propret√©.

.role en clusterIssuer
[source,bash]
----
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: issuer-sa-tokenrequest
  namespace: cert-manager
rules:
- apiGroups: [""]
  resources: ["serviceaccounts/token"]
  verbs: ["create"]
----

.en issuer
[source,bash]
----
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: issuer-sa-tokenrequest
  namespace: <namespace_de_lissuer>
rules:
- apiGroups: [""]
  resources: ["serviceaccounts/token"]
  verbs: ["create"]
----

.enc clusterIssuer
[source,yaml]
----
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: issuer-sa-tokenrequest
  namespace: cert-manager
rules:
- apiGroups: [""]
  resources: ["serviceaccounts/token"]
  verbs: ["create"]
----

.rolebinding
[source,yaml]
----
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: issuer-sa-tokenrequest
  namespace: <namespace_de_lissuer_ou_cert-manager>
subjects:
- kind: ServiceAccount
  name: cert-manager
  namespace: cert-manager
roleRef:
  kind: Role
  name: issuer-sa-tokenrequest
  apiGroup: rbac.authorization.k8s.io
----

Avant de cr√©er l'issuer il nous nous assurer que le service account qui sera pr√©sent√© par cert-manager aura bien les droits pour signer des certificats depuis notre pki interm√©diaire.

=== Cr√©ation de la policy vault

Il faut que notre token vault puisse signer les csr, et consulter le certificat publique de la pki interm√©diaire.

[source,bash]
----
# On autorise la signature des certificate depuis l'interm√©diate
echo -e 'path "pki-int/sign/web-servers" {\n  capabilities = ["update"]\n}\n' > pki-cert-manager.hcl

# On autorise consultation des certificats
echo -e 'path "pki-int/ca" {\n  capabilities = ["read"]\n}' >> pki-cert-manager.hcl

# V√©rification
cat pki-cert-manager.hcl

# Application de la policy dans Vault
vault policy write pki-cert-manager pki-cert-manager.hcl
----

.fichier pki-cert-manager.hcl
[source,bash]
----
path "pki-bpce-tools-int-a/sign/web-servers" {
  capabilities = ["update"]
}

path "pki-bpce-tools-int-a/ca" {
  capabilities = ["read"]
}
----

A ce stade nous avons les bonnes policies d'un c√¥t√©, et nous avons de l'autre c√¥t√© un service account sera pr√©sent√©. Mais ce service account ne dispose pas encore de cette policy, le lien n'est pas fait.

=== Cr√©ation du r√¥le vault pour cert-manager

Nous venons de cr√©er la policy, il faut maintenant la rattacher aux services account qui proviendront de cert-manager. Nous cr√©er un r√¥le dans l'auth kubernetes (`auth/kubernetes/role`) et nous l'appelons `cert-manager`.

[source,bash]
----
vault write auth/kubernetes/role/cert-manager \
    bound_service_account_names=<issuer_service_account> \
    bound_service_account_namespaces=<issuer_namespace> \
    policies=pki-cert-manager \
    ttl=24h \
    audience="vault://<issuer_namespace>/<issuer_service_account>" \
----

==== Explications

Cette commande cr√©e un r√¥le d‚Äôauthentification Kubernetes dans Vault (`auth/kubernetes/role/cert-manager`).

* **`bound_service_account_names=issuer_service_account`**
Seuls les pods qui utilisent le ServiceAccount nomm√© `issuer_service_account`. Pour nous c'est issuer-sa.

* **`bound_service_account_namespaces=cert-manager`**
‚Ä¶et qui tournent dans le namespace `issuer_namespace`‚Ä¶. Pour nous c'est soit `cert-manager` dans le cas d'un clusterIssuer, soit le namespace de l'Issuer (sur lequel nous avons cr√©√© notre service account).

‚Ä¶sont autoris√©s √† utiliser ce r√¥le.
Cela agit comme un **garde-fou** pour √©viter qu‚Äôun autre pod du cluster ne s‚Äôauthentifie.

* **`policies=pki-cert-manager`**

Le token Vault √©mis sera attach√© √† la policy `pki-cert-manager`, qui contient par exemple :
[source,hcl]
----
path "pki-bpce-tools-int-a/sign/web-servers" {
capabilities = ["update"]
}
----

‚Üí Concr√®tement, cela autorise cert-manager √† demander la signature de certificat signing requests.

* **`ttl=24h`**
Le token Vault obtenu expirera automatiquement au bout de 24 heures.
cert-manager se charge de renouveler un nouveau token si n√©cessaire.

* **`audience=vault://<issuer_namespace>/<issuer_name>`**

Vault v√©rifie que le JWT du ServiceAccount contient bien `aud: "vault://<issuer_namespace>/<issuer_name>"`. Cette audience est fournit d√©finie par l'issuer et donc par cert manager lorsqu'il tente de communiquer avec vault. C'est √©crit dans la documentation officielle sous la forme suivante:

[source,bash]
----
The audience allows you to restrict the Vault role to a single Issuer or ClusterIssuer. The syntax is the following:

"vault://<namespace>/<issuer-name>"   # For an Issuer.
"vault://<cluster-issuer-name>"       # For a ClusterIssuer.
----

Cela √©vite qu‚Äôun jeton g√©n√©r√© pour le serveur API Kubernetes soit r√©utilis√© pour s‚Äôauthentifier √† Vault.
Cette option est une **mesure de s√©curit√©** et deviendra obligatoire √† partir de Vault ‚â• 1.21.

[IMPORTANT]
--
Ici pour continuer nous devonss donc fixer le nom de notre issuer, nous l'appelerons vault-issuer-rr-dev-dev.
--

Autrement dit pour nous l'audience est soit `vault://<namespace_de_lissuer>/vault-issuer-rr-dev-dev` soit `vault://vault-issuer-rr-dev-dev`

=== Cr√©ation de l'issuer

On cr√©√© ensuite l'issue ou le cluster issuer. C'est la brique manquante.

[source,bash]
----
apiVersion: cert-manager.io/v1
kind: Issuer
metadata:
  name: vault-issuer-rr-dev-dev
  namespace: kube-system
spec:
  vault:
    server: "http://vault.vault.svc.cluster.local:8200"
    path: "pki-int/sign/web-servers"
    auth:
      kubernetes:
        mountPath: /v1/auth/kubernetes
        role: cert-manager
        serviceAccountRef:
          name: issuer-sa
----

.clusterIssuer
[source,bash]
----
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: vault-issuer-rr-dev-dev
spec:
  vault:
    server: "http://vault.vault.svc.cluster.local:8200"
    path: "pki-int/sign/web-servers"
    auth:
      kubernetes:
        mountPath: /v1/auth/kubernetes
        role: cert-manager
        serviceAccountRef:
          name: issuer-sa
----

=== Cr√©ation d'un certificat √† l'aide du clusterIssuer ou de l'issuer

.clusterissuer
[source,bash]
----
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: wildcard-rr-dev
  namespace: apps
spec:
  secretName: wildcard-rr-dev-dev-tls
  commonName: "*.rr-dev.dev"
  dnsNames:
    - "*.rr-dev.dev"
  issuerRef:
    name: vault-issuer-rr-dev
    kind: ClusterIssuer
----

.issuer
[source,bash]
----
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: wildcard-rr-dev
  namespace: <bon_namespace_de_lissuer>
spec:
  secretName: wildcard-rr-dev-dev-tls
  commonName: "*.rr-dev.dev"
  dnsNames:
    - "*.rr-dev.dev"
  issuerRef:
    name: vault-issuer-rr-dev
    kind: Issuer
----
