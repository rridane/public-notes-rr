:author: rridane
:source-highlighter: rouge
:toc: left
:toclevels: 3
:numbered:

= üß© CUE - Configuration Unified Engine

== üöÄ Introduction √† CUE

CUE (Configuration Unified Engine) est un langage d√©claratif qui combine :

* la **d√©finition de donn√©es** (comme JSON ou YAML)
* la **validation par contraintes** (comme JSON Schema)
* la **g√©n√©ration de fichiers** (pour Kubernetes, Terraform, etc.)

L‚Äôid√©e cl√© : au lieu de s√©parer sch√©ma et donn√©es, tout est √©crit en CUE, et le moteur fait la fusion. Il faut donc comprendre que dans une m√™me s√©quences de fichiers (ou dans un meme fichier) on va combiner **d√©finitions de donn√©es**, **validation par contraintes**. cue est ensuite capable de g√©n√©rer les fichiers json. Nous reverrons cela, mais CUE est un langage de contraintes, une succession de contraintes viennent d√©finir un json, dont la contrainte absolue est une contrainte de valeur.

Exemple minimal :

[source, cue]
----
greeting: "Hello, World!"
----

√âvaluation :

[source, bash]
----
cue eval hello.cue
----

R√©sultat :

[source, json]
----
{
  "greeting": "Hello, World!"
}
----

== üîë CUE comme langage de contraintes

CUE n‚Äôest pas juste un format de donn√©es : c‚Äôest un **langage de contraintes**.

* Chaque d√©finition r√©duit l‚Äôespace des valeurs possibles.
* CUE fusionne toutes les contraintes.
* Une valeur concr√®te est une contrainte absolue (= doit √™tre exactement √ßa).

=== Exemple 1 : Contraintes s√©par√©es

[source, cue]
----
age: int
age: >=0
----

√âquivaut √† :

[source, cue]
----
age: int & >=0
----

=== Exemple 2 : Ajout d‚Äôune valeur

[source, cue]
----
age: int
age: >=0
age: 42
----

R√©sultat :

[source, json]
----
{
  "age": 42
}
----

Toutes les contraintes sont satisfaites :
* doit √™tre un entier
* doit √™tre >=0
* doit valoir 42

=== Exemple 3 : Contradiction

[source, cue]
----
age: int
age: >=0
age: -5
----

R√©sultat : **erreur** (car `-5` ne satisfait pas `>=0`).

== üì¶ Fusion des contraintes

Quand une cl√© appara√Æt plusieurs fois, CUE ne fait pas "dernier qui gagne" (comme YAML), mais calcule l‚Äô**intersection**.

=== Exemple valide

[source, cue]
----
person: {
  name: string
  age:  int & >=0
}

person: {
  name: "Alice"
  age: 5
}
----

R√©sultat :

[source, json]
----
{
  "person": {
    "name": "Alice",
    "age": 5
  }
}
----

=== Exemple invalide

[source, cue]
----
person: {
  name: string
  age:  int & >=0
}

person: {
  name: "Alice"
  age: -5
}
----

R√©sultat : **erreur**, car `-5` viole la contrainte.

L'intersection signifie donc que ceci est invalide, les deux contraintes de valeurs sont en oppositions.

[source, cue]
----
person: {
  name: string
  age:  int & >=0
}

person: {
  name: "Alice"
  age: -5
}

person: {
  name: "Lisa"
  age: -5
}
----

== üîí Champs obligatoires vs optionnels

Par d√©faut, dans CUE, **tous les champs sont obligatoires**.
Si un champ est d√©fini dans une contrainte et absent dans les donn√©es, cela provoque une erreur.

=== Exemple : champ obligatoire (invalide)

[source, cue]
----
person: {
  name: string
  age:  int & >=0
}

person: {
  name: "Lisa"
}
----

R√©sultat : **erreur**, car `age` est obligatoire et n‚Äôest pas fourni.

=== Exemple : champ optionnel (valide)

On peut rendre un champ optionnel en ajoutant `?`.

[source, cue]
----
person: {
  name: string
  age?: int & >=0
}

person: {
  name: "Lisa"
}
----

R√©sultat JSON :

[source, json]
----
{
  "person": {
    "name": "Lisa"
  }
}
----

Ici, `age` est **optionnel** :
* s‚Äôil est absent ‚Üí c‚Äôest valide
* s‚Äôil est pr√©sent ‚Üí il doit respecter la contrainte (`int >=0`)

=== üìù Interpolation de cha√Ænes

CUE permet d‚Äôins√©rer dynamiquement des expressions dans des cha√Ænes gr√¢ce √† la syntaxe `\(... )`.

[source, cue]
----
#cost:   102
#budget: 88

m: "You are \(#cost-#budget) dollars over budget!"

email: """
   Here is a message from the finance team:

      \(m)

   Regards,
     Your friends on the 12th floor
   """
----

R√©sultat :

[source, json]
----
{
  "m": "You are 14 dollars over budget!",
  "email": "Here is a message from the finance team:\n\n   You are 14 dollars over budget!\n\nRegards,\n  Your friends on the 12th floor\n"
}
----

‚ö° Points cl√©s :
* `\(expression)` ‚Üí ins√®re la valeur de l‚Äôexpression.
* Fonctionne dans les cha√Ænes simples (`"..."`) et multilignes (`""" ... """`).
* Tr√®s utile pour g√©n√©rer des messages, des chemins, des noms de ressources Kubernetes, etc.

== üî¢ Arrays, Maps et listes ouvertes/ferm√©es

En plus des objets simples, CUE permet de d√©finir des **listes (arrays)** et des **maps (dictionnaires)**.
Ces structures ob√©issent aux m√™mes r√®gles de contraintes et peuvent √™tre **ouvertes** (taille flexible) ou **ferm√©es** (taille fixe).

=== üìã D√©finir un array (liste)

==== 1. Liste explicite (valeurs exactes)

[source, cue]
----
numbers: [1, 2, 3, 4]
----

R√©sultat :

[source, json]
----
{ "numbers": [1, 2, 3, 4] }
----

==== 2. Liste ouverte (taille flexible)

[source, cue]
----
numbers: [...int]
----

* `numbers` est une liste ouverte,
* contenant **0 √† n √©l√©ments**,
* chaque √©l√©ment doit √™tre un `int`.

Exemple valide :

[source, cue]
----
numbers: [1, 2, 3, 42]
----

Exemple invalide :

[source, cue]
----
numbers: [1, "two"]  // ‚ùå "two" n‚Äôest pas un int
----

==== 3. Liste ferm√©e (taille fixe)

[source, cue]
----
pair: [string, int]
----

* `pair` doit contenir exactement **2 √©l√©ments**,
* le premier est une cha√Æne,
* le second est un entier.

Exemple valide :

[source, cue]
----
pair: ["Alice", 42]
----

Exemple invalide :

[source, cue]
----
pair: ["Alice"]        // ‚ùå manque un √©l√©ment
pair: ["Alice", "Bob"] // ‚ùå deuxi√®me √©l√©ment n‚Äôest pas un int
----

==== 4. Liste d‚Äôobjets inline

[source, cue]
----
people: [...{
  name: string
  age:  int & >=0
}]
----

Exemple valide :

[source, cue]
----
people: [
  { name: "Alice", age: 5 },
  { name: "Bob",   age: 42 }
]
----

=== üóÇÔ∏è D√©finir une map (dictionnaire)

Une **map** associe des cl√©s √† des valeurs.
On d√©finit la contrainte sur la cl√© et la valeur :

[source, cue]
----
scores: [string]: int

scores: {
  "Alice": 10
  "Bob":   15
}
----

R√©sultat :

[source, json]
----
{
  "scores": {
    "Alice": 10,
    "Bob":   15
  }
}
----

* Ici : chaque cl√© est une cha√Æne (`string`),
* chaque valeur est un entier (`int`).

Exemple invalide :

[source, cue]
----
scores: {
  "Alice": "dix"  // ‚ùå pas un int
}
----

=== üóÇÔ∏è D√©finir un array de map

Il est possible de combiner **listes** et **maps**.
Par exemple, une liste o√π chaque √©l√©ment est une map `string ‚Üí int`.

[source, cue]
----
scores: [...[string]: int]

scores: [
  { "Alice": 10, "Bob": 15 },
  { "Charlie": 20, "Diana": 25 }
]
----

R√©sultat :

[source, json]
----
{
  "scores": [
    { "Alice": 10, "Bob": 15 },
    { "Charlie": 20, "Diana": 25 }
  ]
}
----

‚öñÔ∏è √Ä distinguer de l‚Äôinverse :

[source, cue]
----
scores: [string]: [...int]

scores: {
  "Alice": [10, 20],
  "Bob":   [15, 25]
}
----

R√©sultat :

[source, json]
----
{
  "scores": {
    "Alice": [10, 20],
    "Bob":   [15, 25]
  }
}
----

* `scores: [...[string]: int]` ‚Üí **array de maps string‚Üíint**
* `scores: [string]: [...int]` ‚Üí **map de arrays d‚Äôint**

=== ‚öñÔ∏è Ouvert vs Ferm√©

* `[...]T` ‚Üí **liste ouverte** : peut avoir n √©l√©ments de type `T`.
* `[T1, T2, ‚Ä¶]` ‚Üí **liste ferm√©e** : doit avoir exactement ce nombre d‚Äô√©l√©ments.
* `[string]: T` ‚Üí **map ouverte** : n‚Äôimporte quelle cl√© de type string, valeur de type `T`.
* `{ key1: T1, key2: T2 }` ‚Üí **map ferm√©e** avec un nombre exact de cl√©s.

== üõ†Ô∏è Sch√©ma r√©utilisable avec `#Type`

En CUE, on peut d√©finir des sch√©mas r√©utilisables sous forme de **types**, par convention pr√©fix√©s par `#`.
Cela permet :

* de **factoriser** les d√©finitions (√©viter les duplications),
* de cr√©er des **templates** et les sp√©cialiser par composition,
* d‚Äôimposer une **coh√©rence globale** dans un projet,
* de travailler facilement avec des **arrays** ou des **maps** de ce type.

=== üéØ Exemple basique

Ici il faut comprendre que l'on fait une jointure entre les contraintes du template #Person et les contraintes de valeurs.

[source, cue]
----
#Person: {
  name: string
  age:  int & >=0
}

person: #Person & {
  name: "Alice"
  age: 42
}
----

R√©sultat :

[source, json]
----
{
  "person": {
    "name": "Alice",
    "age": 42
  }
}
----

Ici, `#Person` est un **type g√©n√©rique** r√©utilisable.
`person` est une **instance** conforme √† ce sch√©ma.

=== üîÑ Composition : variantes √† partir d‚Äôun m√™me type

[source, cue]
----
#Person: {
  name: string
  age:  int & >=0
}

employee: #Person & {
  role: "employee"
}

manager: #Person & {
  role: "manager"
  age:  >=30
}
----

R√©sultat :

[source, cue]
----
{
  "employee": {
    "name": string,
    "age": int,
    "role": "employee"
  },
  "manager": {
    "name": string,
    "age": int,
    "role": "manager"
  }
}
----

‚ö° Ici, `#Person` est le **socle commun**, et chaque variante ajoute ses contraintes.

=== üî¢ Arrays de `#Type`

[source, cue]
----
#Person: {
  name: string
  age:  int & >=0
}

people: [...#Person]

people: [
  { name: "Alice", age: 5 },
  { name: "Bob",   age: 42 }
]
----

R√©sultat :

[source, json]
----
{
  "people": [
    { "name": "Alice", "age": 5 },
    { "name": "Bob",   "age": 42 }
  ]
}
----

üëâ `people` est une liste d‚Äôobjets conformes √† `#Person`.

=== üóÇÔ∏è Maps de `#Type`

CUE permet aussi de d√©finir des **maps** (dictionnaires cl√©/valeur).

[source, cue]
----
#Person: {
  name: string
  age:  int & >=0
}

people: [string]: #Person

people: {
  "alice": { name: "Alice", age: 5 }
  "bob":   { name: "Bob",   age: 42 }
}
----

R√©sultat :

[source, json]
----
{
  "people": {
    "alice": { "name": "Alice", "age": 5 },
    "bob":   { "name": "Bob",   "age": 42 }
  }
}
----

üëâ Ici, `people` est une **map index√©e par cha√Æne de caract√®res**, chaque valeur respectant le sch√©ma `#Person`.

=== ‚ö° Int√©r√™ts concrets des `#Type`

* **Factorisation** : pas de duplication (DRY).
* **Composition** : un sch√©ma de base + des sp√©cialisations.
* **Coh√©rence** : les m√™mes contraintes sont appliqu√©es partout.
* **Interop√©rabilit√©** : tu peux d√©finir des sch√©mas `#Deployment`, `#DatabaseConfig`, etc., et les r√©utiliser dans tout ton projet.
* **Collections structur√©es** : arrays et maps fortement typ√©s.

== üßÆ Op√©rateurs avanc√©s

En plus de la simple intersection `&`, CUE fournit plusieurs op√©rateurs puissants pour exprimer des contraintes complexes.

=== ‚ûï Intersection (`&`)

D√©j√† vu : combine plusieurs contraintes ‚Üí seule la valeur qui satisfait **toutes** est valide.

[source, cue]
----
age: int & >=0 & <=120
----

R√©sultat : `age` doit √™tre un entier compris entre `0` et `120`.

=== ‚ûñ Union (`|`)

D√©finit une **valeur alternative** : l‚Äôune ou l‚Äôautre.

[source, cue]
----
status: "pending" | "done" | "failed"
----

Exemple valide :

[source, cue]
----
status: "done"
----

Exemple invalide :

[source, cue]
----
status: "unknown"  // ‚ùå pas dans l‚Äôunion
----

‚ö° Pratique pour d√©finir des **√©num√©rations**.

=== ‚ùå N√©gation (`!`)

Permet d‚Äôexclure une valeur (ou un ensemble de valeurs).

[source, cue]
----
color: string & !="red"
----

Exemples :

* `"blue"` ‚Üí ‚úÖ
* `"red"` ‚Üí ‚ùå interdit

=== üî¢ Plages et intervalles

On peut utiliser des contraintes num√©riques avec `>=`, `<=`, etc.

[source, cue]
----
temperature: int & >=-50 & <=50
----

‚ö° Combine avec `&` pour d√©finir un intervalle.

=== üß© Types combin√©s (union + intersection)

On peut combiner unions et intersections.

[source, cue]
----
id: (int & >=0) | string
----

üëâ Ici, `id` peut √™tre soit un entier positif, soit une cha√Æne.

Exemples valides :
* `42`
* `"abc"`

Exemple invalide :
* `-5` ‚ùå

=== üìù Contraintes sur la longueur des cha√Ænes

Avec `len` on impose une contrainte sur la taille.

[source, cue]
----
username: string & len>=3 & len<=20
----

* `"Al"` ‚Üí ‚ùå trop court
* `"Alice"` ‚Üí ‚úÖ
* `"AliceInWonderlandIsTooLong"` ‚Üí ‚ùå trop long

=== üóÇÔ∏è Contraintes sur les listes

On peut contraindre la taille avec `len`.

[source, cue]
----
numbers: [...int] & len>=1 & len<=5
----

üëâ Liste d‚Äôentiers, longueur comprise entre 1 et 5.

Exemple valide :

[source, cue]
----
numbers: [1, 2, 3]
----

Exemple invalide :

[source, cue]
----
numbers: []
----

=== üé≠ Valeurs par d√©faut (`*`)

Le `*` d√©finit une valeur **par d√©faut**, si aucune autre valeur n‚Äôest donn√©e.

[source, cue]
----
replicas: *1 | int & >=1
----

* par d√©faut, `replicas = 1`
* mais on peut surcharger par une autre valeur enti√®re >=1

Exemple :

[source, cue]
----
replicas: 3
----

R√©sultat : `replicas = 3`

=== ‚öñÔ∏è Comparaisons par type (int, float, string, null)

Les op√©rateurs de comparaison (`<`, `>`, `<=`, `>=`, `!=`) fonctionnent avec plusieurs types,
pas seulement les nombres.

[source, cue]
----
#floatOver5:  >5.0   // type: float
#negativeNum: <0     // type: int | float
#afterL:      >"L"   // type: string (ordre lexicographique)
#notNull:     !=null // type: any sauf null

zero:      0    & >10          // ‚ùå √©chec : 0 n‚Äôest pas >10
float10:   10.0 & #floatOver5  // ‚úÖ 10.0 > 5.0
float5:    5.0  & #floatOver5  // ‚ùå √©chec : 5.0 n‚Äôest pas >5.0
"num-6":   -6   & #negativeNum // ‚úÖ -6 < 0
A:         "A"  & #afterL      // ‚ùå "A" < "L"
Z:         "Z"  & #afterL      // ‚úÖ "Z" > "L"
isNull:    null & #notNull     // ‚ùå √©chec : null interdit
isNotNull: "X"  & #notNull     // ‚úÖ "X" est non null

float425:  42.5 & #notNull & <100 & #floatOver5
// ‚úÖ 42.5 est non null, <100, >5.0
----

‚ö° Points cl√©s :
* Les comparaisons s‚Äôappliquent √† plusieurs types :
- num√©riques (`int`, `float`)
- cha√Ænes (`string`) avec ordre lexicographique
- `null` avec `!=null` ou `==null`
* On peut combiner plusieurs contraintes (`&`) pour raffiner les conditions.

=== üî§ Expressions r√©guli√®res

CUE supporte les expressions r√©guli√®res via les op√©rateurs `=~` (match) et `!~` (ne match pas).

* `a =~ b` ‚Üí vrai si `a` correspond √† l‚Äôexpression r√©guli√®re `b`.
* `a !~ b` ‚Üí vrai si `a` ne correspond pas √† `b`.

Comme les op√©rateurs de comparaison (`<`, `>=`), on peut utiliser les regex en **contraintes unaires**, pour d√©finir un ensemble de cha√Ænes valides.

[source, cue]
----
fooBar:  "foo bar" =~ "^[a-z ]{1,100}$"
bazQuux: "baz Quux" !~ "[A-Z]"

#lowercaseLength3: =~"^[[:lower:]]{3}$"
#noNumbers:        !~"[0-9]"

foo:       "foo" & #lowercaseLength3
BAR:       "BAR" & #lowercaseLength3
baaz:      "baaz" & #lowercaseLength3
theAnswer: "42"  & #noNumbers
----

R√©sultat :

[source, text]
----
fooBar:    true
bazQuux:   false
foo:       "foo"
BAR:       _|_ // "BAR" invalide (n‚Äôest pas 3 lettres minuscules)
baaz:      _|_ // "baaz" invalide (trop long)
theAnswer: _|_ // "42" invalide (contient des chiffres)
----

‚ö° D√©tails importants :
* CUE utilise la syntaxe **RE2 de Go** pour les regex.
* Voir aussi la doc du package standard `regexp` et la spec (`Comparison operators` + `Pattern constraints`).

=== üîÑ Null Coalescing (gestion des valeurs manquantes ou invalides)

Le *null coalescing* (ou plut√¥t **error coalescing**) permet de donner une **valeur de repli** si une expression produit `_|_` (bottom, erreur).

CUE l‚Äôimpl√©mente naturellement via les **disjonctions** (`|`) combin√©es avec le marqueur de d√©faut `*`.

üëâ R√®gle cl√© : `_|_ | valeur` = `valeur`

Exemple :

[source, cue]
----
#pets: ["Cat", "Mouse", "Dog"]

// √âvite un out-of-bounds
pet0: *#pets[0] | "Pet not found"
pet5: *#pets[5] | "Pet not found"

#nums: [7, "8", "9"]

// V√©rifie le type
num0: *(#nums[0] & int) | "Not an integer"
num1: *(#nums[1] & int) | "Not an integer"
----

R√©sultat :

[source, text]
----
pet0: "Cat"
pet5: "Pet not found"
num0: 7
num1: "Not an integer"
----

‚ö° Utile pour :
* g√©rer les **index hors limites** dans une liste,
* tester le **type d‚Äôune valeur**,
* fournir un **fallback** robuste si une contrainte √©choue.


== ‚öñÔ∏è Conditions (`if`)

CUE permet d‚Äôexprimer des contraintes conditionnelles avec `if`.
Cela permet d‚Äôajouter ou de restreindre des champs selon une valeur.

=== üéØ Exemple simple

[source, cue]
----
price: number

if price > 100 {
    reason!:       string
    authorisedBy!: string
}
----

üëâ Ici :
* `price` est toujours requis.
* Si `price > 100`, alors les champs `reason` et `authorisedBy` deviennent obligatoires (`!`).

=== ‚úÖ Exemple valide

[source, cue]
----
price: 120
reason: "Special order"
authorisedBy: "Alice"
----

R√©sultat JSON :

[source, json]
----
{
  "price": 120,
  "reason": "Special order",
  "authorisedBy": "Alice"
}
----

=== ‚ùå Exemple invalide

[source, cue]
----
price: 150
----

R√©sultat : **erreur**, car `reason` et `authorisedBy` sont obligatoires d√®s que `price > 100`.

‚ö° Points cl√©s :
* `if` s‚Äôutilise comme une contrainte logique.
* On peut marquer des champs obligatoires avec `!`.
* Permet d‚Äôexprimer des r√®gles de validation dynamiques (ex: seuils, d√©pendances).

== üîÅ G√©n√©ration (comprehensions)

CUE ne poss√®de pas de boucles imp√©ratives comme dans les langages classiques.
√Ä la place, on utilise des **comprehensions**, qui permettent de g√©n√©rer des listes ou des maps √† partir d‚Äôautres donn√©es.

=== üìã G√©n√©rer une liste

On peut g√©n√©rer une liste en appliquant une transformation √† chaque √©l√©ment.

[source, cue]
----
squares: [ for i in [1, 2, 3, 4] { i*i } ]
----

R√©sultat :

[source, json]
----
{
  "squares": [1, 4, 9, 16]
}
----

üëâ Ici, chaque `i` est pris dans la liste `[1,2,3,4]` et transform√© en `i*i`.

=== üóÇÔ∏è G√©n√©rer une map

On peut √©galement g√©n√©rer une **map** en it√©rant sur une autre.

[source, cue]
----
table: {
  for k, v in {"a":1, "b":2, "c":3} {
    "\(k)": v*10
  }
}
----

R√©sultat :

[source, json]
----
{
  "table": {
    "a": 10,
    "b": 20,
    "c": 30
  }
}
----

üëâ Les cl√©s `a, b, c` sont r√©utilis√©es, et les valeurs multipli√©es par 10.

=== üéõÔ∏è Avec conditions

On peut filtrer dans une comprehension.

[source, cue]
----
evens: [ for i in [1,2,3,4,5,6] if i%2 == 0 { i } ]
----

R√©sultat :

[source, json]
----
{
  "evens": [2, 4, 6]
}
----

=== ‚ö° Points cl√©s

* Une comprehension n‚Äôest pas une boucle mais une **d√©finition d√©clarative**.
* Elle sert √† **g√©n√©rer** des listes ou des maps √† partir d‚Äôautres.
* On peut inclure des **conditions** (`if`).
* Combine parfaitement avec les contraintes et les `#types`.

== üß© Sch√©mas param√©tr√©s (√©quivalents de fonctions)

CUE n‚Äôa pas de fonctions imp√©ratives comme Go ou Python.
√Ä la place, on utilise des **sch√©mas param√©tr√©s** : des d√©finitions `#Type` qui acceptent des **arguments**, un peu comme des constructeurs ou des fonctions pures.

=== üéØ Exemple simple

[source, cue]
----
#Service(name, port): {
  name: name
  port: port
}

svc1: #Service("frontend", 8080)
svc2: #Service("backend", 9090)
----

R√©sultat :

[source, json]
----
{
  "svc1": { "name": "frontend", "port": 8080 },
  "svc2": { "name": "backend", "port": 9090 }
}
----

üëâ Ici `#Service` agit comme une fonction qui prend `(name, port)` et g√©n√®re un objet.

=== üîÑ Composition avec contraintes

On peut enrichir le sch√©ma avec des contraintes suppl√©mentaires.

[source, cue]
----
#Service(name, port): {
  name:  string & name
  port:  int & >=1024 & port
}

svc1: #Service("cache", 6379)
svc2: #Service("api",   80)   // ‚ùå erreur, port < 1024
----

üëâ `#Service` impose :
* `name` doit √™tre une cha√Æne,
* `port` doit √™tre un entier ‚â• 1024,
* puis fusionne avec les valeurs pass√©es en argument.

=== üóÇÔ∏è Sch√©ma param√©tr√© dans une liste

[source, cue]
----
#Service(name, port): {
  name: name
  port: port
}

services: [
  #Service("svc1", 8080),
  #Service("svc2", 8081),
  #Service("svc3", 8082),
]
----

R√©sultat :

[source, json]
----
{
  "services": [
    { "name": "svc1", "port": 8080 },
    { "name": "svc2", "port": 8081 },
    { "name": "svc3", "port": 8082 }
  ]
}
----

üëâ Pratique pour g√©n√©rer plusieurs objets homog√®nes.

=== ‚ö° Points cl√©s

* Les **sch√©mas param√©tr√©s** sont l‚Äô√©quivalent des fonctions en CUE.
* On les d√©finit avec `#Name(args): { ‚Ä¶ }`.
* Ils permettent de g√©n√©rer des objets r√©utilisables avec diff√©rents param√®tres.
* On peut y inclure des **contraintes** pour valider automatiquement les arguments.
* En combinaison avec `#defs` (donn√©es interm√©diaires), ils servent √† g√©n√©rer des collections enti√®res de ressources (ex : Kubernetes services).

== üîÅ G√©n√©ration (comprehensions)

‚ö†Ô∏è Note : *comprehension* est un terme **technique** en CUE (comme en Python ou Haskell).
Il d√©signe une construction qui combine :
* une **query** ‚Üí s√©lection des √©l√©ments √† traiter,
* une **projection** ‚Üí d√©finition de la forme des r√©sultats.

=== üìã G√©n√©rer une liste

On peut g√©n√©rer une liste en appliquant une transformation √† chaque √©l√©ment.

[source, cue]
----
squares: [ for i in [1, 2, 3, 4] { i*i } ]
----

R√©sultat :

[source, json]
----
{
  "squares": [1, 4, 9, 16]
}
----

üëâ Chaque `i` est pris dans la liste `[1,2,3,4]` et projet√© en `i*i`.

=== üóÇÔ∏è G√©n√©rer une map

On peut √©galement g√©n√©rer une **map** en it√©rant sur une autre.

[source, cue]
----
table: {
  for k, v in {"a":1, "b":2, "c":3} {
    "\(k)": v*10
  }
}
----

R√©sultat :

[source, json]
----
{
  "table": {
    "a": 10,
    "b": 20,
    "c": 30
  }
}
----

üëâ Les cl√©s `a, b, c` sont conserv√©es et les valeurs multipli√©es par 10.

---

=== üéõÔ∏è Avec conditions

On peut filtrer les r√©sultats avec `if`.

[source, cue]
----
evens: [ for i in [1,2,3,4,5,6] if i%2 == 0 { i } ]
----

R√©sultat :

[source, json]
----
{
  "evens": [2, 4, 6]
}
----

---

=== üîß Comprehensions avanc√©es (for + if + let)

On peut enrichir une comprehension avec `let` (variables locales) et combiner `for` + `if`.

[source, cue]
----
import "strings"

#censusData: [
    {name: "Kinshasa", pop: 16_315_534},
    {name: "Lagos",    pop: 15_300_000},
    {name: "Cairo",    pop: 10_100_166},
    {name: "Giza",     pop: 9_250_791},
]

// city map: lowercase name ‚Üí d√©tails
city: {
    for index, value in #censusData
    let lower = strings.ToLower(value.name)
    if value.pop > 10_000_000 {
        "\(lower)": {
            population: value.pop
            name:       value.name
            position:   index + 1
        }
    }
}
----

R√©sultat :

[source, json]
----
{
  "city": {
    "kinshasa": { "population": 16315534, "name": "Kinshasa", "position": 1 },
    "lagos":    { "population": 15300000, "name": "Lagos",    "position": 2 },
    "cairo":    { "population": 10100166, "name": "Cairo",    "position": 3 }
  }
}
----

=== üîç Queries et Projections

On peut voir chaque comprehension comme deux phases :

1. **Query** ‚Üí quels √©l√©ments garder ?
2. **Projection** ‚Üí quelle nouvelle forme leur donner ?

[source, cue]
----
_data: {
    foo: {a: 1,    b: "a foo",     c: true}
    bar: {a: 100,  b: "some bar",  c: false}
    baz: {a: 1000, b: "this is baz", c: false}
    quux:{a: 10000,b: "quux?",     c: true}
}

result: {
    for k, v in _data
    if v.a < 10 || v.c || v.b =~ "bar" {
        (k): {
            b: v.b
            a: 1 + v.a*2
        }
    }
}
----

R√©sultat :

[source, json]
----
{
  "result": {
    "foo":  { "b": "a foo",    "a": 3 },
    "bar":  { "b": "some bar", "a": 201 },
    "quux": { "b": "quux?",    "a": 20001 }
  }
}
----

üëâ La query garde `foo`, `bar`, `quux`.
üëâ La projection red√©finit chaque entr√©e avec un champ `b` inchang√© et un champ `a` transform√©.

=== ‚ö° Points cl√©s

* `for` ‚Üí it√©ration sur listes ou maps.
* `if` ‚Üí filtrage conditionnel.
* `let` ‚Üí variables temporaires.
* **Query** = s√©lection, **Projection** = transformation.
* Equivalent de `map` + `filter` en programmation fonctionnelle.


== üì¶ Organisation, packages et imports

Dans un vrai projet CUE, on s√©pare les fichiers et r√©utilise des d√©finitions entre eux.
CUE permet cela avec :

* `package` : d√©finit le package d‚Äôun fichier (comme Go).
* `import` : permet de r√©utiliser un autre package.
* conventions : les d√©finitions **internes** commencent par `#` et ne sont pas export√©es.

=== üéØ Exemple minimal multi-fichiers

`schema.cue` :

[source, cue]
----
package schema

#Service(name, port): {
  name: name
  port: port
}
----

`app.cue` :

[source, cue]
----
package main

import "schema"

services: [
  schema.#Service("frontend", 8080),
  schema.#Service("backend", 9090),
]
----

√âvaluation :

[source, bash]
----
cue eval ./...
----

R√©sultat :

[source, json]
----
{
  "services": [
    { "name": "frontend", "port": 8080 },
    { "name": "backend", "port": 9090 }
  ]
}
----

=== üìÇ Structure √©tat de l‚Äôart : projet Kubernetes

Voici une organisation type pour utiliser CUE comme g√©n√©rateur de manifests Kubernetes.

[source, text]
----
my-kube-project/
‚îú‚îÄ‚îÄ cue.mod/                # Module CUE (√©quivalent de go.mod, voir section d√©di√©e un peu plus bas)
‚îÇ   ‚îî‚îÄ‚îÄ module.cue
‚îú‚îÄ‚îÄ schema/                 # Sch√©mas r√©utilisables (types param√©tr√©s)
‚îÇ   ‚îú‚îÄ‚îÄ deployment.cue
‚îÇ   ‚îú‚îÄ‚îÄ service.cue
‚îÇ   ‚îî‚îÄ‚îÄ ingress.cue
‚îú‚îÄ‚îÄ envs/                   # D√©finition par environnement
‚îÇ   ‚îú‚îÄ‚îÄ dev.cue
‚îÇ   ‚îú‚îÄ‚îÄ staging.cue
‚îÇ   ‚îî‚îÄ‚îÄ prod.cue
‚îú‚îÄ‚îÄ apps/                   # Applications concr√®tes
‚îÇ   ‚îú‚îÄ‚îÄ frontend.cue
‚îÇ   ‚îî‚îÄ‚îÄ backend.cue
‚îî‚îÄ‚îÄ kustomize/              # (optionnel) dossiers d‚Äôexport JSON/YAML
    ‚îî‚îÄ‚îÄ base/
----

=== üóÇÔ∏è Exemple concret

`scehma/deployment.cue` :

[source, cue]
----
package schema

#Deployment(name, image, replicas): {
  apiVersion: "apps/v1"
  kind:       "Deployment"
  metadata: name: name
  spec: {
    replicas: replicas
    template: spec: containers: [{
      name:  name
      image: image
    }]
  }
}
----

`apps/frontend.cue` :

[source, cue]
----
package main

import "schema"

frontend: schema.#Deployment("frontend", "nginx:1.25", 2)
----

=== ‚ö° Export en manifests Kubernetes

Une fois d√©fini, on peut g√©n√©rer du YAML pr√™t pour `kubectl` :

[source, bash]
----
cue export ./apps/frontend.cue --out yaml > frontend.yaml
----

R√©sultat YAML :

[source, yaml]
----
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend
spec:
  replicas: 2
  template:
    spec:
      containers:
      - name: frontend
        image: nginx:1.25
----

=== üìÇ cue.mod et module.cue

Comme Go utilise `go.mod`, CUE utilise un r√©pertoire sp√©cial `cue.mod/` pour d√©finir un **module**.
C‚Äôest ce qui permet d‚Äôorganiser un projet, g√©rer les imports et √©viter les collisions de noms.

Structure minimale :

[source, text]
----
my-kube-project/
‚îú‚îÄ‚îÄ cue.mod/
‚îÇ   ‚îî‚îÄ‚îÄ module.cue
‚îú‚îÄ‚îÄ schema/
‚îÇ   ‚îî‚îÄ‚îÄ deployment.cue
‚îî‚îÄ‚îÄ apps/
    ‚îî‚îÄ‚îÄ frontend.cue
----

==== Contenu d‚Äôun `module.cue`

Exemple :

[source, cue]
----
module: "github.com/rridane/my-kube-project"
----

* La valeur `"github.com/rridane/my-kube-project"` est l‚Äôidentifiant du module.
* Tu peux mettre une URL (comme Go), ou un simple nom (`"my-project"`).
* Tous les `import` dans le projet utiliseront ce namespace comme pr√©fixe.

==== Exemple avec import local

`scehma/deployment.cue` :

[source, cue]
----
package schema

#Deployment(name, image, replicas): {
  apiVersion: "apps/v1"
  kind:       "Deployment"
  metadata: name: name
  spec: {
    replicas: replicas
    template: spec: containers: [{
      name:  name
      image: image
    }]
  }
}
----

`apps/frontend.cue` :

[source, cue]
----
package main

import "github.com/rridane/my-kube-project/schema"

frontend: schema.#Deployment("frontend", "nginx:1.25", 2)
----

==== ‚ö° Pourquoi c‚Äôest important ?

* Le `cue.mod/` transforme ton dossier en **vrai module CUE**, r√©utilisable.
* Tu peux importer ses d√©finitions dans d‚Äôautres projets.
* Tu assures la coh√©rence des imports (pas besoin de chemins relatifs comme `../schema`).
* √âtat de l‚Äôart ‚Üí toujours initialiser un projet avec un module.

==== Initialiser un module

Commande :

[source, bash]
----
cue mod init github.com/rridane/my-kube-project
----

üëâ Cela cr√©e automatiquement `cue.mod/module.cue`.

=== ‚úÖ Bonnes pratiques

* **S√©parer les sch√©mas (`schema/`) et les donn√©es (`apps/`, `envs/`)**.
* Utiliser des **`#types` param√©tr√©s** pour factoriser (`#Deployment`, `#Service`).
* G√©rer les **environnements** (dev/staging/prod) dans des fichiers d√©di√©s.
* Toujours utiliser `cue export` pour g√©n√©rer des manifests propres (sans `#defs`).


== üìö Biblioth√®que standard et imports

CUE dispose d‚Äôune **biblioth√®que standard** riche, organis√©e en packages, que l‚Äôon importe avec `import "nom"`.
Ces fonctions sont soit utilis√©es pour transformer des valeurs, soit comme **contraintes** suppl√©mentaires.

‚ö†Ô∏è Important : CUE est un **langage ferm√©**.
Il n‚Äôest pas possible de d√©finir ses propres fonctions.
On peut seulement utiliser :
* les **builtins** fournis par CUE,
* les **sch√©mas param√©tr√©s** (`#Type(arg1, arg2): { ‚Ä¶ }`) comme pseudo-fonctions.

=== üî§ Package `strings`

Manipulation de cha√Ænes de caract√®res.

[source, cue]
----
import "strings"

s: "Hello World"

hasHello: strings.HasPrefix(s, "Hello")   // true
lower:    strings.ToLower(s)              // "hello world"
upper:    strings.ToUpper(s)              // "HELLO WORLD"
trimmed:  strings.TrimSpace("  foo  ")    // "foo"
replaced: strings.Replace("foo-bar", "-", "_", -1) // "foo_bar"
split:    strings.Split("a,b,c", ",")     // ["a","b","c"]
joined:   strings.Join(["a","b","c"], ";") // "a;b;c"

max5:     s & strings.MaxRunes(5)   // contrainte : max 5 caract√®res
min2:     s & strings.MinRunes(2)   // contrainte : min 2 caract√®res
----

=== üßÆ Package `math`

Fonctions math√©matiques.

[source, cue]
----
import "math"

a: 3 + 2                // op√©rateurs de base existent d√©j√†
f: math.Floor(3.7)      // 3.0
c: math.Ceil(3.1)       // 4.0
l: math.Log(10.0)       // log naturel
p: math.Pow(2.0, 8.0)   // 256
s: math.Sin(3.14159/2)  // ‚âà 1
----

=== üìã Package `list`

Manipulation de listes.
Tr√®s utile pour combiner ou r√©duire des contraintes.

[source, cue]
----
import "list"

// Unifie toutes les contraintes contenues dans la liste
c: [int, >99, <1000]
data: [string]: list.and(c)  // contrainte : int entre 100 et 999

// Concat√©nation
concat: list.Concat([[1,2], [3,4]])  // [1,2,3,4]

// Longueur
lenOK: [...int] & list.MinItems(2) & list.MaxItems(5)
----

=== üìê Expressions r√©guli√®res

Validation par regex avec `=~` et `!~`.

[source, cue]
----
email: string & =~"^[^@]+@[^@]+\\.[^@]+$"

notUpper: string & !~"^[A-Z]+$"  // interdit les cha√Ænes en majuscules
----

=== üóÇÔ∏è Package `encoding/json`

Permet d‚Äôencoder/d√©coder des donn√©es JSON.

[source, cue]
----
import "encoding/json"

raw: `{ "name": "Alice", "age": 30 }`

parsed: encoding.json.Decode(raw) & {
  name: string
  age:  int
}
----

R√©sultat apr√®s √©valuation :

[source, json]
----
{
  "parsed": {
    "name": "Alice",
    "age": 30
  }
}
----

=== üóÇÔ∏è Package `encoding/yaml`

M√™me principe que `json`, mais pour YAML.

[source, cue]
----
import "encoding/yaml"

raw: """
name: Alice
age: 30
"""

parsed: encoding.yaml.Decode(raw)
----

=== üîë Package `encoding/base64`

Encodage / d√©codage en base64.

[source, cue]
----
import "encoding/base64"

txt: "hello"
encoded: encoding.base64.Encode(txt)   // "aGVsbG8="
decoded: encoding.base64.Decode("aGVsbG8=")
----

=== ‚úÖ R√©sum√©

* **strings** ‚Üí op√©rations sur cha√Ænes (`ToLower`, `Replace`, `Split`, `Join`, contraintes `MaxRunes`, `MinRunes`).
* **math** ‚Üí fonctions num√©riques (`Floor`, `Ceil`, `Log`, trigonom√©trie‚Ä¶).
* **list** ‚Üí manipulations de listes (`Concat`, `and`, contraintes de longueur).
* **regexp** ‚Üí op√©rateurs `=~`, `!~`.
* **encoding/json** et **encoding/yaml** ‚Üí d√©coder/encoder JSON et YAML.
* **encoding/base64** ‚Üí encode/decode base64.

‚ö†Ô∏è Il n‚Äôest **pas possible de d√©finir ses propres fonctions**.
Pour g√©n√©rer dynamiquement, on utilise soit :
* des **sch√©mas param√©tr√©s** (`#Type(args)`)
* des **comprehensions** (`for ‚Ä¶ in ‚Ä¶ { ‚Ä¶ }`)

== üõ†Ô∏è Commandes essentielles de CUE

CUE fournit plusieurs commandes en ligne de commande pour travailler avec les fichiers `.cue`.
Ces commandes permettent d‚Äô√©valuer, d‚Äôexporter et de valider les donn√©es.

=== ‚ñ∂Ô∏è cue eval

√âvalue les fichiers CUE et affiche le r√©sultat en JSON par d√©faut.
Affiche √©galement les d√©finitions `#`.

[source, bash]
----
cue eval ./apps/frontend.cue
----

Exemple de sortie :

[source, json]
----
{
  "frontend": {
    "apiVersion": "apps/v1",
    "kind": "Deployment",
    "metadata": {
      "name": "frontend"
    },
    "spec": {
      "replicas": 2,
      "template": {
        "spec": {
          "containers": [
            { "name": "frontend", "image": "nginx:1.25" }
          ]
        }
      }
    }
  }
}
----

‚ö†Ô∏è Inclut aussi les d√©finitions internes (`#`) ‚Üí pour le rendu final, utiliser `cue export`.

=== üì§ cue export

Exporte uniquement les valeurs concr√®tes, en **JSON** ou **YAML**.
Id√©al pour g√©n√©rer des manifests Kubernetes.

[source, bash]
----
cue export ./apps/frontend.cue --out yaml > frontend.yaml
----

R√©sultat :

[source, yaml]
----
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend
spec:
  replicas: 2
  template:
    spec:
      containers:
      - name: frontend
        image: nginx:1.25
----

=== ‚úÖ cue vet

Valide un fichier de donn√©es (JSON, YAML) contre un sch√©ma CUE.
Permet de v√©rifier qu‚Äôun manifest respecte bien les contraintes.

Exemple : valider un JSON contre un sch√©ma `schema.cue`.

[source, bash]
----
cue vet schema.cue data.json
----

Si `data.json` respecte les contraintes ‚Üí ‚úÖ pas d‚Äôerreur.
Sinon ‚Üí ‚ùå message d‚Äôerreur explicite.

=== üîç cue def

Affiche les **d√©finitions implicites** et les contraintes r√©sultantes.
Utile pour comprendre comment CUE a fusionn√© les contraintes.

[source, bash]
----
cue def ./apps/frontend.cue
----

Exemple de sortie simplifi√©e :

[source, cue]
----
frontend: {
    apiVersion: "apps/v1"
    kind:       "Deployment"
    metadata: name: string
    spec: {
        replicas: int & >=1
        template: {
            spec: containers: [...{
                name:  string
                image: string
            }]
        }
    }
}
----

üëâ Permet de d√©boguer et de comprendre les r√®gles.

== üîç Interop√©rabilit√© avec `cue vet`

CUE permet non seulement de **d√©finir et g√©n√©rer** des donn√©es, mais aussi de **valider des fichiers externes** (JSON, YAML) contre un sch√©ma CUE.

C‚Äôest la commande `cue vet` qui sert √† v√©rifier qu‚Äôun fichier de donn√©es respecte bien les contraintes d‚Äôun sch√©ma.

=== üéØ Exemple avec JSON

`schema.cue` :

[source, cue]
----
#Person: {
  name: string
  age:  int & >=0
}

person: #Person
----

`data.json` :

[source, json]
----
{
  "person": {
    "name": "Alice",
    "age": 30
  }
}
----

Validation :

[source, bash]
----
cue vet schema.cue data.json
----

R√©sultat : ‚úÖ pas d‚Äôerreur, le fichier est valide.

=== ‚ùå Exemple invalide

`data.json` :

[source, json]
----
{
  "person": {
    "name": "Alice",
    "age": -5
  }
}
----

Validation :

[source, bash]
----
cue vet schema.cue data.json
----

R√©sultat :

[source, text]
----
person.age: invalid value -5 (out of bound >=0):
    ./schema.cue:4:10
    ./data.json:4:12
----

üëâ CUE indique pr√©cis√©ment :
* la valeur en faute (`-5`),
* la contrainte viol√©e (`>=0`),
* la position dans le sch√©ma et dans le fichier de donn√©es.

=== üìã Exemple avec YAML

`data.yaml` :

[source, yaml]
----
person:
  name: Bob
  age: 42
----

Validation :

[source, bash]
----
cue vet schema.cue data.yaml
----

R√©sultat : ‚úÖ valide (m√™me logique que pour JSON).

=== ‚ö° Points cl√©s

* `cue vet sch√©ma.cue fichier.json` ‚Üí valide les donn√©es contre le sch√©ma.
* Fonctionne avec JSON et YAML.
* Messages d‚Äôerreur explicites (valeur fautive + contrainte viol√©e).
* Tr√®s utile pour **auditer des configurations existantes** (manifests Kubernetes, fichiers applicatifs).


=== üìö Autres commandes utiles

* `cue fmt` ‚Üí formate automatiquement les fichiers `.cue` (comme `gofmt`).
* `cue mod init <module>` ‚Üí initialise un module (cr√©e `cue.mod/module.cue`).
* `cue mod tidy` ‚Üí met √† jour et nettoie les imports.

=== ‚ö° R√©sum√©

* `cue eval` ‚Üí √©valuation (tout, y compris d√©finitions).
* `cue export` ‚Üí export final (JSON/YAML).
* `cue vet` ‚Üí validation de donn√©es externes.
* `cue def` ‚Üí afficher les contraintes fusionn√©es.
* `cue fmt` / `cue mod` ‚Üí gestion du projet.

