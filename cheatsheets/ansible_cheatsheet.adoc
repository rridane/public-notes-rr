:author-url: https://github.com/rridane
:author: rridane
:source-highlighter: rouge
:hardbreaks:
:table-caption!:
:toc: left

= Ansible Cheatsheet

== Configuration & inventories

Ansible cherche sa configuration dans l'ordre suivant :

.ansible.cfg
[source, markdown]
----
# Ordre de recherche

- variable d'environnement : ANSIBLE_CONFIG
- fichier ansible.cfg dans le répertoire courant
- fichier ~/.ansible.cfg dans le dossier home
- fichier /etc/ansible/ansible.cfg

# sections

- [defaults] : # comportement global (inventory, callbacks, diff, gather, paths…)
- [ssh_connection] # tuning de la connexion SSH (pipelining, multiplexing…)
- [privilege_escalation] # sudo par défaut (become)
- Sections additionnelles selon besoin # [inventory], [galaxy], [colors], etc.
----

[TIP]
--
Diagnostiquer ce qui est réellement appliqué :
[source,bash]
ansible-config view # fichier effectif
ansible-config dump --only-changed
ansible-config list # catalogue complet des options
--

.ansible.cfg (commenté)
[source, bash]
----
[defaults]

inventory = inventories/staging/hosts.ini  # Chemin par défaut de l’inventaire (évite -i partout)
interpreter_python = auto_silent # Auto-détection silencieuse du Python distant (utile sur OS minimal)
stdout_callback = yaml # Sortie plus lisible par défaut (YAML)
bin_ansible_callbacks = True # Autorise l’exécution des callbacks (profilage, timer…)

## (Lab/CI) Désactive la vérif d’empreinte SSH ; en prod → True + known_hosts géré
# host_key_checking = False
timeout = 30 # Timeout de connexion SSH (secondes)
retry_files_enabled = True # Écrit des .retry pour rejouer facilement les hôtes en échec
roles_path = roles # Répertoire(s) des rôles (séparer par ":" si multiple)
collections_paths = collections # Où Ansible cherche/installe les collections
forks = 20 # Parallélisme (nb d’hôtes en parallèle)
gathering = smart # Collecte “intelligente” des facts (cache-friendly)
callbacks_enabled = profile_tasks,timer # Active les callbacks de profilage : temps par tâche + temps total

# -------- Fact cache (accélère les runs répétés) --------
fact_caching = jsonfile # Type de cache de facts (ici fichiers JSON locaux)
fact_caching_connection = .fact_cache # Dossier de cache des facts
fact_caching_timeout = 86400 # Durée de validité du cache (secondes) → 1 jour

[ssh_connection]
pipelining = True # Réduit les allers-retours SSH (plus rapide). Attention à requiretty côté sudo.
----

[NOTE]
--
.Ignorer le cache et les retry dans Git
[source,bash]
----
echo ".fact_cache/" >> .gitignore
echo ".retry/" >> .gitignore
----
--

=== Commands cheatsheet

.liste des commandes ansible
[source,bash]
----
ansible all -m ping # Test simple de connectivité (module ping), all pour all hosts
ansible all -a "uptime" # Commande ad-hoc (module command par défaut)
ansible web -m shell -a "df -h" # Utiliser explicitement le module shell

ansible-playbook playbooks/site.yml # Exécuter un playbook
ansible-playbook -i inventories/prod/hosts.ini playbooks/site.yml # Forcer un inventaire INI
ansible-playbook -i inventories/prod/hosts.yml playbooks/site.yml # Forcer un inventaire YAML

ansible-playbook -i inventories/prod/hosts.ini -l server1 playbooks/site.yml # --limit : cibler un hôte/groupe/pattern dans l'inventory de prod
ansible-playbook -t motd playbooks/site.yml # --tags : exécuter seulement certaines tâches
ansible-playbook --skip-tags motd playbooks/site.yml # --skip-tags : ignorer des tâches
ansible-playbook --list-tags playbooks/site.yml # Lister les tags disponibles
ansible-playbook --list-tasks playbooks/site.yml # Lister toutes les tâches
ansible-playbook --list-hosts playbooks/site.yml # Lister les hôtes ciblés

ansible-playbook --check playbooks/site.yml # Dry-run : simuler sans changer l’état
ansible-playbook --diff playbooks/site.yml # Afficher les diffs (templates/copy)
ansible-playbook --step playbooks/site.yml # Exécution pas-à-pas
ansible-playbook --start-at-task "Installer Nginx" playbooks/site.yml # Reprendre à partir d’une tâche
ansible-playbook --syntax-check playbooks/site.yml # Vérifier la syntaxe

ansible-playbook -v playbooks/site.yml # Verbosité 1
ansible-playbook -vv playbooks/site.yml # Verbosité 2
ansible-playbook -vvv playbooks/site.yml # Verbosité 3 (debug)
ansible-playbook -vvvv playbooks/site.yml # Verbosité 4 (SSH debug)

ansible-playbook -u ubuntu playbooks/site.yml # Utilisateur SSH
ansible-playbook --private-key=~/.ssh/id_rsa playbooks/site.yml # Clé privée SSH
ansible-playbook -b playbooks/site.yml # become (sudo)
ansible-playbook --become-user=root playbooks/site.yml # Changer d’utilisateur

ansible-playbook -e "motd_message='Hello world'" playbooks/site.yml # Variables inline
ansible-playbook -e "@vars.yml" playbooks/site.yml # Charger un fichier YAML
ansible-playbook -e '{"list":[1,2],"obj":{"a":1}}' playbooks/site.yml # JSON inline

ansible-inventory -i inventories/prod/hosts.ini --list --yaml # Afficher l’inventaire résolu
ansible-inventory -i inventories/prod/hosts.ini --graph # Graphe groupes↔hôtes
ansible-inventory -i inventories/prod/hosts.ini --host server1 # Variables effectives d’un hôte

ansible-doc -l # Lister tous les modules
ansible-doc copy # Aide détaillée sur un module
ansible-config list # Lister toutes les options
ansible-config view # Voir la configuration active
ansible-config dump # Afficher paramètres + source

ansible-galaxy init roles/nginx # Générer un rôle
ansible-galaxy install geerlingguy.nginx # Installer un rôle Galaxy
ansible-galaxy collection install community.general # Installer une collection

ansible-vault create group_vars/all/vault.yml # Créer un fichier chiffré
ansible-vault edit group_vars/all/vault.yml # Éditer un fichier chiffré
ansible-vault encrypt_string 'secret' --name 'db_password' # Variable inline chiffrée
ansible-playbook --ask-vault-pass playbooks/site.yml # Demander le mot de passe Vault
ansible-playbook --vault-password-file ~/.vault_pass # Fournir le pass Vault via fichier
----

.fiche ciblage & variables (patterns, limit, vars, vault)
[source,bash]
----
# -------------------------
# Patterns d’hôtes
# -------------------------

ansible all -m ping # Tous les hôtes
ansible web -m ping # Groupe "web"
ansible 'web:&prod' -m ping # Intersection (web ET prod)
ansible 'web:!db' -m ping # Exclusion (web SAUF db)
ansible 'server1,server2' -m ping # Union explicite
ansible 'web[1:3]' -m ping # Plage de noms (web1..web3)

# -------------------------
# --limit
# -------------------------

ansible-playbook -i inventories/prod/hosts.ini -l server1 playbooks/site.yml # Un seul hôte
ansible-playbook -l 'web:!db' playbooks/site.yml # Pattern combiné
ansible-playbook -l '@/path/run.retry' playbooks/site.yml # Rejouer hôtes en échec

# -------------------------
# Inventaires & introspection
# -------------------------

ansible-inventory -i inventories/prod/hosts.ini --graph # Vue graphe
ansible-inventory -i inventories/prod/hosts.ini --host server1 # Vars d’un hôte
ansible-playbook --list-hosts playbooks/site.yml # Hôtes ciblés par le playbook

# -------------------------
# Variables
# -------------------------

ansible-playbook -e "env=prod version=1.2.3" playbooks/site.yml # Variables inline
ansible-playbook -e "@vars/common.yml" playbooks/site.yml # Fichier YAML
ansible-playbook -e '{"features":["a","b"],"replicas":3}' playbooks/site.yml # JSON inline

# -------------------------
# Facts & debug
# -------------------------

ansible server1 -m setup -a 'filter=ansible_*_version' # Inspecter certains facts
ansible server1 -m debug -a 'var=ansible_facts' # Afficher les facts
ansible server1 -m debug -a 'var=vars.some_var' # Afficher une variable définie

# -------------------------
# Vault
# -------------------------

ansible-vault create group_vars/all/vault.yml # Créer un fichier chiffré
ansible-vault edit group_vars/all/vault.yml # Éditer
ansible-vault encrypt_string 'p@ssw0rd' --name 'db_password' # Var chiffrée inline
ansible-playbook --ask-vault-pass playbooks/site.yml # Mot de passe demandé
ansible-playbook --vault-password-file ~/.vault_pass # Pass via fichier

# -------------------------
# Connexion & privilèges
# -------------------------

ansible-playbook -u ubuntu --private-key=~/.ssh/id_rsa playbooks/site.yml # User + clé
ansible-playbook -b --become-user=root playbooks/site.yml # sudo + user ciblé

----

== Tasks

=== Directives Conditionnelles et Contrôle d'Exécution

.directives conditionnelles
[source, bash]
----
# when:: Exécute conditionnellement une tâche sur la base d'une expression booléenne

when: maintenance_mode | bool # execute si maintenance_mode est true
when: ansible_os_family == "Debian" # execute si ansible_os_family est "debian"
when: "'webservers' in group_names" or env == 'development'

# changed_when/failed_when:: Redéfinit les conditions de changement/échec
changed_when: "'RESTARTED' in service_check.stdout" # a été changé sir service_check.stdout contient 'RESTARTED'
failed_when: script_result.rc not in [0, 2] # a échoué si script_result.rc n'est pas 0 ou 2

# ignore_errors:: Continue l'exécution malgré les erreurs
ignore_errors: yes

# loop:: Itère sur une liste d'éléments
loop:
  - alice
  - bob
loop:
  - { user: 'alice', key: 'ssh-rsa...' }


# delegate_to:: Délègue l'exécution à un hôte spécifique
delegate_to: localhost
delegate_to: bastion.example.com

#run_once:: Exécute la tâche une seule fois
run_once: true

# block/rescue/always:: Groupe de tâches avec gestion d'erreurs
block:
  - # tâches principales
rescue:
  - # en cas d'erreur
always:
  - # toujours exécuté

# Stratégies
strategy:: # free (parallèle) ou linear (séquentiel)
serial:: # Nombre d'hôtes traités simultanément
max_fail_percentage:: # Pourcentage d'échecs tolérés

# Tags
#tags:: Permet de filtrer l'exécution des tâches
tags:
  - base
  - security

# Handlers

notify:: # Déclenche un handler
listen:: # Permet à plusieurs tâches de notifier le même handler
notify: "restart apache" # côté tâche
listen: "apache service" # côté handler (cela palie au fait que plusieurs tâches ne peuvent pas avoir le même nom)
----

== roles

.architecture exhaustive d'un rôle
[source,yaml]
----
roles/
│   └── base_setup/
│       ├── tasks/ # dossier central, nos tâches
│       │   ├── main.yml
│       │   ├── secondary_task.yml
│       │   └── cleanup_task.yml
│       ├── handlers/ # handlers, tâches notifiée au changemnt uniquement
│       │   └── main.yml
│       ├── templates/ # templates jinja2
│       │   └── systemd/
│       │       └── custom_service.service.j2
│       ├── files/ # fichiers statiques à copier, donne la vraie arborescence si possible
│       │   ├── etc/
│       │   │   └── motd
│       │   └── usr/
│       │       └── local/
│       │           └── bin/
│       │               └── custom_script.sh
│       ├── vars/ # variables difficilement surchargeables, à disposition du rôle uniquement
│       │   ├── main.yml
│       │   ├── Debian.yml
│       │   └── RedHat.yml
│       ├── defaults/
│       │   └── main.yml # variables par défaut facilement surchargeables
│       ├── meta/ # le dossier de la documentation
│       │   ├── arguments_specs.yml # déclare les variables attendues, c'est la documentation
│       │   └── main.yml # décrit le rôle (notamment pour ansible galaxy)
│       ├── library/ # nos custom modules
│       ├── module_utils/ # dossier partagés pour nos custom modules
│       ├── lookup_plugins/ # lookup disponible dans les templates ou les tasks
│       ├── filter_plugins/ # filter disponible dans les templates ou les tasks
│       └── tests/ # tests d'intégration basés sur les molécules
│           ├── inventory
│           └── test.yml
----

.meta/main.yml (version condensée)
[source,yaml]
----
galaxy_info:
  namespace: rridane           # Identifiant unique pour publication sur Galaxy
  role_name: mon_role          # Nom du rôle (doit correspondre au répertoire)
  author: "Rida Ridane"        # Auteur principal du rôle
  description: "Rôle d'exemple documenté" # Description concise du rôle
  license: MIT                 # Licence SPDX (MIT, Apache-2.0, etc.)
  min_ansible_version: "2.15"  # Version minimale d'Ansible requise
  platforms:                   # Liste des systèmes d'exploitation supportés
    - name: Debian             # Support Debian
      versions: ["bullseye", "bookworm"] # Versions spécifiques supportées
    - name: Ubuntu             # Support Ubuntu
      versions: ["focal", "jammy"]
  galaxy_tags: ["devops", "system"] # Mots-clés pour la découverte sur Galaxy

dependencies:                  # Rôles requis avant l'exécution
  - rridane.common_base        # Dépendance simple (sans paramètres)
  - role: rridane.keepalived   # Dépendance avec paramètres
    vars: {vip: "10.0.0.10/24", iface: "eth0", priority: 110} # Variables passées au rôle
    when: keepalived is defined # Condition d'exécution de la dépendance

allow_duplicates: false        # Empêche l'exécution multiple du même rôle

collections:                   # Collections nécessaires au rôle
  - ansible.builtin            # Collection built-in d'Ansible
  - community.general          # Collection community générale
----

.meta/argument_specs.yml (version condensée)
[source,yaml]
----
argument_specs:
  main:                        # Point d'entrée principal (tasks/main.yml)
    description: "Configure un service applicatif" # Description de l'entrypoint
    options:                   # Définition des variables acceptées par le rôle
      name:                    # Variable de type chaîne
        type: str              # Type string
        default: "my-service"  # Valeur par défaut
      enabled:                 # Variable booléenne
        type: bool             # Type boolean
        default: true          # Valeur par défaut (true)
      config_path:             # Variable de type chemin
        type: path             # Type path (validation de chemin)
        required: true         # Champ obligatoire
      state:                   # Variable avec valeurs prédéfinies
        type: str              # Type string
        default: "present"     # Valeur par défaut
        choices: ["present", "absent"] # Valeurs autorisées
      extra_packages:          # Variable de type liste
        type: list             # Type liste
        elements: str          # Type des éléments de la liste
        default: []            # Valeur par défaut (liste vide)
      backends:                # Variable de liste de dictionnaires
        type: list             # Type liste
        elements: dict         # Chaque élément est un dictionnaire
        options:               # Définition des clés attendues dans chaque dict
          name:                # Clé 'name' dans le dictionnaire
            type: str          # Type string
            required: true     # Champ obligatoire
          servers:             # Clé 'servers' dans le dictionnaire
            type: list         # Type liste
            elements: str      # Type des éléments (string)
            required: true     # Champ obligatoire
----

.variables de rôles : defaults/main.yml - Variables par défaut (surchargeables)
[source,yaml]
----
# Valeurs par défaut alignées avec meta/argument_specs.yml
name: "my-service"                    # STR simple
enabled: true                         # BOOL
max_connections: 2000                 # INT
ratio: 0.75                           # FLOAT
state: "present"                      # ENUM (choices: present/absent)
extra_packages: ["curl", "htop"]      # LISTE de STR
ports: [80, 443]                      # LISTE d'INT
backends:                             # LISTE de DICTS
  - name: "api"
    servers: ["10.0.0.11:8080"]
    balance: "roundrobin"
defaults:                             # DICT avec sous-options
  mode: "http"
  timeouts: {connect: "5s", client: "50s"}
advanced_debug: false                 # Option booléenne
ha:                                    # DICT optionnel
  vip: "10.0.0.10/24"
  iface: "eth0"
  priority: 100
----

.variables de rôles : vars/ - Variables non surchargeables (spécifiques au rôle)
[source,yaml]
----
# vars/main.yml - Variables communes
service_name_map:                     # Noms de service par OS
  Debian: "webapp"
  RedHat: "webapp"
base_packages_map:                    # Paquets obligatoires par OS
  Debian: ["webapp", "ca-certificates"]
  RedHat: ["webapp", "ca-certificates"]
config_dir_map:                       # Répertoires de configuration
  Debian: "/etc/webapp"
  RedHat: "/etc/webapp"
system_user: "webapp"                 # Valeurs fixes
system_group: "webapp"

# Structure recommandée:
vars/
├─ main.yml     # commun
├─ Debian.yml   # spécifique Debian
├─ RedHat.yml   # spécifique RHEL
----

.Chargement des variables spécifiques à l'OS
[source,yaml]
----
- name: Charger les variables spécifiques à l'OS
  ansible.builtin.include_vars:
    file: "{{ lookup('first_found', params) }}"
  vars:
    params:
      files:
        - "{{ ansible_facts.os_family }}.yml"
        - "default.yml"
      paths:
        - "{{ role_path }}/vars"
----

[NOTE]
--
.CAUTION: Ansible charge automatiquement vars/main.yml et defaults/main.yml
Pour les autres fichiers vars/, utiliser include_vars
--

.Tâches : Bonnes pratiques générales
[source,yaml]
----
# Imdempotence: Tâches rejouables sans changements inutiles
# Tags: Toujours tagger les tâches par fonctionnalité
# Noms: Utiliser des noms explicites ('Web :: Installer plugin')
# Modules: Préférer les modules Ansible aux commandes shell/command
# Sécurité: no_log: true pour les secrets, validate sur les templates
# Handlers: Utiliser notify -> handlers pour les redémarrages
# Check mode: Respecter le mode check et diff quand possible
----

.Exemples de tâches types
[source,yaml]
----
# Chargement variables OS
- name: "Vars :: Charger variables spécifiques OS"
  include_vars:
    file: "{{ lookup('first_found', params) }}"
  vars:
    params:
      files:
        - "{{ ansible_facts.os_family }}.yml"
        - "default.yml"
      paths: "{{ role_path }}/vars"
  tags: [vars]

# Validation entrée
- name: "Assert :: Variables valides"
  assert:
    that:
      - name is string
      - enabled is boolean
    fail_msg: "Contrat brisé: vérifie tes variables."
  tags: [assert]

# Gestion fichiers
- name: "FS :: Créer répertoire"
  file:
    path: "{{ config_dir }}"
    state: directory
    owner: "{{ system_user }}"
    mode: "0755"
  tags: [fs]

# Installation paquets
- name: "Pkg :: Installer paquets"
  package:
    name: "{{ base_packages + extra_packages }}"
    state: present
  tags: [pkg]

# Templates avec validation
- name: "Cfg :: Template systemd"
  template:
    src: "service.j2"
    dest: "/etc/systemd/system/{{ name }}.service"
    validate: "systemd-analyze verify %s"
  notify: "Systemd :: Daemon-reload"
  tags: [cfg, systemd]

# Gestion secrets
- name: "Secret :: Créer utilisateur DB"
  postgresql_user:
    name: "appuser"
    password: "{{ db_password }}"
  no_log: true
  tags: [secret, db]

# Boucles
- name: "Cfg :: Déployer backends"
  template:
    src: "backend.conf.j2"
    dest: "/etc/app/conf.d/{{ item.name }}.conf"
  loop: "{{ backends }}"
  loop_control:
    label: "{{ item.name }}"
  tags: [cfg]

# Gestion services
- name: "Svc :: Démarrer service"
  service:
    name: "{{ name }}"
    state: "{{ 'started' if enabled else 'stopped' }}"
    enabled: "{{ enabled }}"
  tags: [svc]

# Gestion erreurs avec block
- block:
    - name: "Health :: Vérifier port"
      wait_for:
        port: "{{ ports[0] }}"
        timeout: 10

    - name: "Health :: Probe HTTP"
      uri:
        url: "http://127.0.0.1:{{ ports[0] }}/health"
        status_code: 200
      register: health_uri
      changed_when: false

  rescue:
    - name: "Health :: Debug journal"
      command: "journalctl -u {{ name }} -n 100"
      changed: false

  always:
    - meta: flush_handlers

# Mode check
- name: "Check :: Prévisualiser template"
  template:
    src: "example.conf.j2"
    dest: "/etc/app/example.conf"
  check_mode: true
  diff: true
  tags: [check]

# Tâches async
- name: "Async :: Migration longue"
  command: "/opt/app/migrate"
  async: 300
  poll: 5
  tags: [async]

# Délégation
- name: "Bastion :: Vérifier accès externe"
  uri:
    url: "https://example.org/health"
    method: HEAD
  delegate_to: bastion.example.org
  run_once: true
  changed_when: false
  tags: [bastion]
----

[NOTE]
--
.Points clés à retenir:
- Utiliser des modules Ansible plutôt que shell/command quand possible
- Tagger toutes les tâches pour un ciblage précis
- Valider les templates quand c'est possible
- Masquer les secrets avec no_log: true
- Gérer les erreurs avec block/rescue/always
- Respecter le mode check pour le dry-run
--

.Handlers principaux pour systemd
[source,yaml]
----
# handlers/main.yml
- name: "Systemd :: Daemon-reload"          # Recharge la configuration systemd
  command: systemctl daemon-reload
  become: true

- name: "Systemd :: Reload"                 # Recharge le service sans interruption
  service:
    name: "{{ name }}"
    state: reloaded
  listen: "Systemd :: Reload"               # Permet plusieurs notifications

- name: "Systemd :: Restart"                # Redémarrage complet du service
  service:
    name: "{{ name }}"
    state: restarted
----

[NOTE]
--
.Bonnes pratiques handlers:
- Utiliser `listen` pour gérer plusieurs notifications vers le même handler
- Chaîner `daemon-reload` avant `reload` pour les changements systemd
- Les handlers ne s'exécutent qu'une fois même si notifiés multiple times
- Exécution en fin de play sauf avec `meta: flush_handlers`
--

.dossier files
[source,yaml]
----
# Bonnes pratiques:
# - Arborescence mimant la destination (files/etc/motd)
# - Utiliser copy avec checksum implicite
# - Pour gros fichiers: préférer get_url ou package

- name: "Files :: Déployer /etc/motd"
  copy:
    src: "etc/motd"          # Cherché dans files/etc/motd
    dest: "/etc/motd"
    owner: root
    group: root
    mode: "0644"
  notify: "Systemd :: Restart"  # Si l'app lit /etc/motd au démarrage
----

.Dossier template : Bonnes pratiques templates
[source,yaml]
----
# - Logique minimale dans les templates
# - Espaces/indentations stables (éviter les diffs)
# - Valider quand possible (validate:)
# - Séparer les snippets si gros (include Jinja)
# - Types: config, units systemd, fragments conf.d
----

.Filtres Jinja2 courants
[source,jinja]
----
{{ var | default('value') }}      # Valeur par défaut
{{ var | mandatory }}             # Variable obligatoire
{{ list | join(',') }}            # Joindre une liste
{{ dict | to_nice_yaml(indent=2) }} # Format YAML
{{ items | selectattr('enabled') | list }} # Filtre sur attribut
{{ mylist | unique | list }}      # Éléments uniques
----

.Contrôle de flux Jinja2
[source,jinja]
----
{% if defaults.mode == 'http' %} ... {% endif %}   # Condition
{% for b in backends %} ... {% endfor %}           # Boucle
{%- ... -%}                                        # Contrôle espaces
----

.Exemple template de configuration
[source,jinja]
----
# templates/config.yml.j2
app: {{ name }}
enabled: {{ enabled | bool }}
server:
  mode: {{ defaults.mode | default('http') }}
  listen_port: {{ listen_port | default(8080) }}
backends:
{% for b in backends %}
  - name: {{ b.name }}
    balance: {{ b.balance | default('roundrobin') }}
    servers: {{ b.servers | to_json }}
{% endfor %}
----

.Exemple template systemd
[source,ini]
----
# templates/systemd/service.j2
[Unit]
Description={{ name }} service
After=network.target

[Service]
User={{ system_user }}
ExecStart=/usr/bin/{{ name }} --port {{ ports[0] }}
Restart=always
----

.Tâches template typiques
[source,yaml]
----
- name: "Cfg :: Générer configuration principale"
  template:
    src: "config.yml.j2"
    dest: "/etc/app/config.yml"
    owner: "{{ system_user }}"
    group: "{{ system_group }}"
    mode: "0644"
    validate: "app validate %s"  # Validation si possible
  notify: "App :: Reload"

- name: "Systemd :: Déployer unit"
  template:
    src: "systemd/service.j2"
    dest: "/etc/systemd/system/{{ name }}.service"
    validate: "systemd-analyze verify %s"
  notify:
    - "Systemd :: Daemon-reload"
    - "App :: Restart"

- name: "Cfg :: Fragments conf.d"
  template:
    src: "conf.d/backend.conf.j2"
    dest: "/etc/app/conf.d/{{ item.name }}.conf"
  loop: "{{ backends }}"
  loop_control:
    label: "{{ item.name }}"
  notify: "App :: Reload"
----

.Factorisation avec includes et macros
[source,jinja]
----
{# templates/macros.j2 #}
{% macro emit_kv(d) %}
{% for k,v in d.items() %}
{{ k }}={{ v }}
{% endfor %}
{% endmacro %}

{# Utilisation dans un template #}
{% from 'macros.j2' import emit_kv %}
env:
{{ emit_kv(env_vars) | indent(2) }}

{# Inclusion partielle #}
{% include 'partials/tls_block.j2' %}
----

.Sécurité et robustesse
[source,yaml]
----
- name: "Sécurité :: Template avec validation"
  template:
    src: "nginx.conf.j2"
    dest: "/etc/nginx/nginx.conf"
    validate: "nginx -t -c %s"  # Validation syntaxe nginx
    owner: root
    group: root
    mode: "0644"
  no_log: true  # Masquer les logs si contient des secrets
----

.dossier library
[source,python]
----
# library/my_echo.py - Module simple
from ansible.module_utils.basic import AnsibleModule

def run_module():
    module = AnsibleModule(
        argument_spec=dict(
            message=dict(type='str', required=True),
            uppercase=dict(type='bool', default=False)
        ),
        supports_check_mode=True
    )

    msg = module.params['message']
    if module.params['uppercase']:
        msg = msg.upper()

    module.exit_json(changed=False, echo=msg)

if __name__ == '__main__':
    run_module()
----

[source,yaml]
----
# Utilisation dans une tâche
- name: "Test module custom"
  my_echo:
    message: "hello"
    uppercase: true
  register: result

- debug: var=result.echo
----

.exemple de structure simple
[source,bash]
----
roles/webapp/
├─ lookup_plugins/
│  └─ kv.py
├─ filter_plugins/
│  └─ strings.py
├─ files/
│  └─ data/
│     └─ kv.yml
├─ templates/
│  └─ config.env.j2
├─ tasks/
│  └─ main.yml
└─ defaults/
   └─ main.yml
----

.dossier module_utils
[source,python]
----
# module : helpers partagés
# module_utils/http_helpers.py - Helper HTTP
import urllib.request

def http_get(url, timeout=5):
    """Effectue un GET HTTP basique"""
    with urllib.request.urlopen(url, timeout=timeout) as r:
        return r.status, r.read().decode()
----

[source,python]
----
# library/my_check_http.py - Module utilisant le helper
from ansible.module_utils.basic import AnsibleModule
from ansible.module_utils.http_helpers import http_get

def run_module():
    module = AnsibleModule(
        argument_spec=dict(
            url=dict(type='str', required=True),
            timeout=dict(type='int', default=5)
        )
    )

    status, body = http_get(module.params['url'], module.params['timeout'])
    module.exit_json(changed=False, status=status, body=body[:200])
----

.dossier filter_plugins
[source,python]
----
# filter_plugins/strings.py - Filtres personnalisés
def slug(value: str) -> str:
    """Transforme 'My App PROD' -> 'my-app-prod'"""
    return str(value).strip().lower().replace(" ", "-")

class FilterModule:
    def filters(self):
        return {"slug": slug}
----

.dossier lookup_plugins
[source,python]
----
# lookup_plugins/kv.py - Lookup personnalisé
from ansible.plugins.lookup import LookupBase
import yaml

class LookupModule(LookupBase):
    def run(self, terms, variables=None, **kwargs):
        # Implémentation simplifiée
        results = []
        for term in terms:
            # Logique de recherche de clés
            results.append(f"value_for_{term}")
        return results
----

.utilisation d'un lookup
[source,yaml]
----
# Utilisation dans les templates
APP_NAME={{ lookup('webapp.kv', 'app.name') | slug }}

# Utilisation dans les tâches
- name: "Récupérer valeur"
  debug:
    msg: "{{ lookup('webapp.kv', 'app.name') }}"
----

[NOTE]
--
.Bonnes pratiques plugins:
- Les modules custom doivent être idempotents
- Utiliser module_utils pour partager du code entre modules
- Les filtres doivent avoir une interface simple
- Les lookups doivent gérer proprement les erreurs
- Tester les plugins avec ansible-doc et en ligne de commande
--

.Test des plugins
[source,bash]
----
# Tester un module
ansible localhost -m my_echo -a "message=test"

# Tester un lookup
ansible localhost -m debug -a "msg={{ lookup('webapp.kv', 'app.name') }}"

# Documenter un module
ansible-doc my_echo
----

[NOTE]
Molecule est un framework de test qui permet de créer et gérer des environnements de test temporaires pour valider vos rôles Ansible.

.Workflow Molecule
[source,bash]
----
molecule test        # Cycle complet: create → converge → verify → destroy
molecule create      # Crée l'environnement de test (containers/VM)
molecule converge    # Applique le rôle (équivalent ansible-playbook)
molecule verify      # Exécute les tests de vérification
molecule destroy     # Nettoie l'environnement
molecule lint        # Vérifie la syntaxe et les bonnes pratiques
----

.Structure typique
[source,bash]
----
roles/mon_role/
└── molecule/
    └── default/           # Scénario par défaut
        ├── molecule.yml   # Configuration du scénario
        ├── converge.yml   # Playbook de test principal
        └── verify.yml     # Tests de validation
----

.Exemple molecule.yml
[source,yaml]
----
dependency:
  name: galaxy           # Gestion des dépendances
driver:
  name: docker          # Pilote (docker, vagrant, etc.)
platforms:
  - name: instance
    image: debian:11     # Image de base
provisioner:
  name: ansible         # Utilise Ansible comme provisioner
verifier:
  name: ansible         # Utilise Ansible pour la vérification
----

.Exemple converge.yml
[source,yaml]
----
- hosts: all
  roles:
    - role: ../../      # Teste le rôle courant
      vars:
        enabled: true
        state: present
----

.Exemple verify.yml
[source,yaml]
----
- hosts: all
  tasks:
    - name: "Vérifier service actif"
      service:
        name: "{{ name }}"
        state: started
      changed_when: false

    - name: "Vérifier port en écoute"
      wait_for:
        port: "{{ ports[0] }}"
        timeout: 5
----

.Validation et Linting
[source,bash]
----
# Validation syntaxique
ansible-playbook --syntax-check playbook.yml

# Vérification des bonnes pratiques
ansible-lint playbook.yml

# Validation YAML
yamllint .

# Test dry-run
ansible-playbook --check --diff playbook.yml
----

[NOTE]
--
.Conseils testing:
- Utiliser différents scénarios pour différents OS (default, debian, rhel)
- Tester les états present/absent de votre rôle
- Vérifier l'idempotence (2ème converge ne doit rien changer)
- Utiliser assert pour valider la configuration finale
- Intégrer molecule dans votre CI/CD
--

== Playbooks et Structure Avancée

=== Structure de Playbook

[source,yaml]
----
- name: Play de configuration
  hosts: all
  become: yes
  vars:
    motd_message: "Bienvenue"
  tasks:
    - name: Déployer MOTD
      template:
        src: motd.j2
        dest: /etc/motd

- name: Play applicatif
  hosts: webservers
  roles:
    - nginx
    - app_server
  tasks:
    - name: Vérifier application
      uri:
        url: "http://localhost:{{ app_port }}"
        status_code: 200
----

=== Directives Principales

[source,yaml]
----
hosts: webservers:&staging      # Intersection de groupes
become: yes                     # Escalade de privilèges
remote_user: deploy             # Utilisateur SSH
gather_facts: true              # Collecte d'informations
gather_subset: minimal          # Sous-ensemble de facts
----

=== Hiérarchie des Variables

[source,yaml]
----
# Ordre de priorité (croissant):
1. Rôle defaults/ (plus basse)
2. Rôle vars/
3. Inventaire (group_vars/, host_vars/)
4. Variables de play (vars:)
5. Variables incluses (vars_files:)
6. Variables de tâche (vars:)
7. Ligne de commande (-e) (plus haute)
----

.Gestion d'Erreurs avec Block
[source,yaml]
----
- block:
    - name: Tâche critique
      command: /bin/critical_task.sh
  rescue:
    - name: En cas d'échec
      debug:
        msg: "Tâche critique échouée"
  always:
    - name: Nettoyage
      file:
        path: /tmp/lockfile
        state: absent
----

.Modules vs Shell/Command
[source,yaml]
----
# Préférer les modules (idempotents)
- name: Installer nginx
  package:
    name: nginx
    state: present

# Éviter les commandes shell (non idempotentes)
- name: Installer nginx
  command: apt-get install -y nginx
----

.Sécurité et Validation
[source,yaml]
----
# Masquer les secrets
- name: Créer utilisateur DB
  postgresql_user:
    name: appuser
    password: "{{ db_password }}"
  no_log: true

# Valider les configurations
- name: Déployer config nginx
  template:
    src: nginx.conf.j2
    dest: /etc/nginx/nginx.conf
    validate: "nginx -t -c %s"
----

.Inventaire Dynamique
[source,yaml]
----
# inventories/prod/hosts.yml
all:
  children:
    webservers:
      hosts:
        web1.prod.example.com:
          ansible_host: 192.168.1.10
    databases:
      hosts:
        db1.prod.example.com:
          ansible_host: 192.168.1.20
          db_role: primary
----

.Inventory dynamique (script)
[source,python]
----
#!/usr/bin/env python3
# inventories/ec2.py
import json
import boto3

ec2 = boto3.client('ec2')
instances = ec2.describe_instances(Filters=[...])

inventory = {'_meta': {'hostvars': {}}}
for reservation in instances['Reservations']:
    for instance in reservation['Instances']:
        if instance['State']['Name'] == 'running':
            hostname = instance['PrivateDnsName']
            inventory['_meta']['hostvars'][hostname] = {
                'ansible_host': instance['PrivateIpAddress'],
                'instance_type': instance['InstanceType']
            }
            for tag in instance.get('Tags', []):
                if tag['Key'] == 'Role':
                    if tag['Value'] not in inventory:
                        inventory[tag['Value']] = {'hosts': []}
                    inventory[tag['Value']]['hosts'].append(hostname)

print(json.dumps(inventory))
----

Lorsque l'on donne un script python dans les inventory, ansible comprends qu'il doit l'executer. Il attends en retour un inventory au format _meta json:

[source,json]
----
{
  "<group>": {
    "hosts": ["<hostname>", "..."],
    "vars": { "<varname>": "<value>", "...": "..." },
    "children": ["<subgroup>", "..."]
  },
  "_meta": {
    "hostvars": {
      "<hostname>": {
        "<varname>": "<value>",
        "...": "..."
      }
    }
  }
}
----

Le contrat minimal est le suivant :

[source,json]
----
{
  "_meta": {
    "hostvars": {}
  }
}
----

.propriétés attendues par le contrat
[cols="1,1,1,5",options="header"]
|===
| Clé | Type | Optionnel | Exemple

| `<group>`
| objet
| oui
a|
[source,json]
----
"webservers": {
  "hosts": ["web1", "web2"],
  "vars": { "nginx_port": 80 },
  "children": ["frontend"]
}
----
| `<group>.hosts`
| tableau de chaînes
| oui
| `["web1", "web2"]`

| `<group>.vars`
| objet (clé=string, valeur=any)
| oui
| `{ "ansible_user": "ubuntu" }`

| `<group>.children`
| tableau de chaînes (noms de sous-groupes)
| oui
| `["frontend", "backend"]`

| `_meta`
| objet
| oui (recommandé)
a|
[source,json]
----
"_meta": { "hostvars": {} }
----

| `_meta.hostvars`
| objet (clé=hostname, valeur=objet)
| oui
a|
[source,json]
----
"hostvars": {
  "web1": { "ansible_host": "10.0.0.1" },
  "db1":  { "ansible_host": "10.0.0.2" }
}
----
|===

== Collections

.structure d'une collection
[source,bash]
----
Une collection est un package regroupant:
- Modules
- Plugins
- Rôles
- Documentation
- Playbooks
----

Organisés par espaces de noms (namespace.name) pour une distribution modulaire.

.principales collections
[width="100%",cols="2,3",options="header"]
|===
| Collection | Usage Typique
| `ansible.builtin` | Modules core: `copy`, `file`, `template`, `package`, `service`
| `community.general` | Modules divers: `git`, `homebrew`, `openssl`, `lsof`
| `ansible.posix` | Systèmes POSIX: `firewalld`, `seboolean`, `sysctl`
| `community.docker` | Conteneurs Docker: `docker_container`, `docker_image`
| `community.aws` | Amazon AWS: `ec2_instance`, `s3_bucket`, `lambda_function`
| `community.azure` | Microsoft Azure: `azure_rm_virtualmachine`, `azure_rm_webapp`
| `google.cloud` | Google Cloud: `gcp_compute_instance`, `gcp_storage_bucket`
| `community.crypto` | Cryptographie: `openssh_key`, `acme_certificate`
| `community.network` | Réseau: `aci_tenant`, `vyos_config`, `ios_command`
| `community.postgresql` | PostgreSQL: `postgresql_user`, `postgresql_db`
| `community.mysql` | MySQL: `mysql_user`, `mysql_db`
| `kubernetes.core` | Kubernetes: `k8s_deployment`, `k8s_service`
| `community.grafana` | Monitoring: `grafana_dashboard`, `grafana_datasource`
| `community.hashi_vault` | HashiCorp Vault: `hashi_vault_secret`
| `community.proxmox` | Virtualisation Proxmox: `proxmox_vm`
| `community.windows` | Windows: `win_feature`, `win_domain`
| `ansible.windows` | Modules Windows core: `win_copy`, `win_service`
|===

.Utilisation dans les Playbooks
[source,yaml]
----
# Méthode 1: Préfixage explicite
- community.general.git:
    repo: "https://github.com/example/repo.git"
    dest: /opt/repo

# Méthode 2: Déclaration en en-tête
- hosts: all
  collections:
    - community.general
    - community.docker
  tasks:
    - git:
        repo: "https://github.com/example/repo.git"
        dest: /opt/repo
    - docker_container:
        name: app
        image: nginx
----

.requirements.yml
[source,yaml]
----
# requirements.yml
collections:
  - name: ansible.posix
  - name: community.general
  - name: community.docker

# Installation
ansible-galaxy collection install -r requirements.yml
----

.Tags et Stratégies de Filtrage
[source,yaml]
----
tags:
  - always       # (Avec prudence) Toujours exécuté
  - installation # Paquets, bibliothèques
  - configuration # Fichiers de config, templates
  - service      # Gestion des services
  - validation   # Tests, vérifications
  - cleanup      # Nettoyage
----

== Vault

.Sécurité avec Ansible Vault
[source,bash]
----
# Chiffrement
ansible-vault create secrets.yml
ansible-vault edit secrets.yml

# Exécution
ansible-playbook site.yml --ask-vault-pass
ansible-playbook site.yml --vault-password-file .vault_pass
----

[source,yaml]
----
# Inclusion dans les playbooks
vars_files:
  - "{{ playbook_dir }}/group_vars/all/secrets.yml"
----

== Optimisation des performances

.Optimisation des Performances
[source,ini]
----
# ansible.cfg
[defaults]
forks = 50
gathering = smart
fact_caching = jsonfile
fact_caching_connection = ~/.ansible/facts
fact_caching_timeout = 86400

[ssh_connection]
pipelining = True
# ssh_args = -o ControlMaster=auto -o ControlPersist=60s
----

== Debug

.debug task
[source,yaml]
----
- debug:
    msg: "Message visible seulement avec -vvv"
    verbosity: 3

- debug:
    msg: "Message toujours visible"
    changed_when: false
----

.debug
[source,bash]
----
# Verbosité et Variables d'Environnement

# Niveaux de verbosité
ansible-playbook -vvv playbooks/site.yml
ansible -vvv all -m ping

# Debug interne Ansible (stack trace)
ANSIBLE_DEBUG=1 ansible-playbook playbooks/site.yml

# Conserver les fichiers temporaires
ANSIBLE_KEEP_REMOTE_FILES=1 ansible-playbook playbooks/site.yml

# Forcer un fichier de config spécifique
ANSIBLE_CONFIG=./ansible.cfg ansible-playbook playbooks/site.yml

# Debug SSH hors Ansible
ssh -vvv -i ~/.ssh/id_ed25519 user@host
----

.Introspection de Configuration et Inventaire
[source,bash]
----
# Voir la configuration appliquée
ansible-config view
ansible-config dump --only-changed

# Lister l'inventaire
ansible-inventory -i inventories/prod/hosts.ini --graph
ansible-inventory -i inventories/prod/hosts.ini --list --yaml

# Documentation des modules
ansible-doc -l
ansible-doc template
----

.Diagnostiquer les Changements et Échecs
[source,bash]
----
# Dry-run avec diff
ansible-playbook site.yml --check --diff -vv

# Format de sortie YAML
ANSIBLE_STDOUT_CALLBACK=yaml ansible-playbook site.yml -vv
----

.SSH et Transport
[source,bash]
----
# Tester la chaîne SSH manuellement
ssh -vvv -o ProxyCommand='ssh -W %h:%p bastion' user@target

# Désactiver le multiplexing
ANSIBLE_SSH_ARGS="-o ControlMaster=no" ansible -m ping all -vvv

# Tester les timeouts
ansible -m wait_for -a "host=example.com port=22 timeout=5" localhost
----

.Privilege Escalation (sudo)
[source,bash]
----
# Tester sudo
ansible all -m command -a "id -u" -b -K -vv

# Désactiver pipelining temporairement
ANSIBLE_PIPELINING=0 ansible all -m setup -vv
----

.Facts et Interpréteur Python
[source,bash]
----
# Vérifier Python distant
ansible all -m setup -a 'filter=ansible_python*' -vv

# Interpréteur auto_silent
ANSIBLE_CONFIG=./ansible.cfg ansible all -m ping -vv

# Désactiver facts
ansible-playbook site.yml -e "gather_facts=false" -vv
----

.Inspection des Fichiers Distants
[source,bash]
----
# Avec ANSIBLE_KEEP_REMOTE_FILES=1, sur l'hôte distant:
sudo ls -la /root/.ansible/tmp/
sudo cat /root/.ansible/tmp/ansible-tmp-*/debug_payload
----

.Performance et Exécution Pas-à-Pas
[source,bash]
----
# Profilage des tâches
ANSIBLE_CONFIG=./ansible.cfg ansible-playbook site.yml -vv

# Exécution interactive
ansible-playbook site.yml --step -vv
----

.Connexion SSH via Bastion
[source,ini]
----
# Inventaire
[prod]
web1 ansible_host=10.1.0.10 ansible_ssh_common_args='-o ProxyJump=user@bastion.example.com'

# Group vars
ansible_ssh_common_args: '-o ProxyJump=user@bastion.example.com'
----

.Erreurs Fréquentes et Solutions
.Error Patterns & Quick Fixes
[source,text]
----
"FAILED! => {'msg': 'Missing sudo password'}"
→ Utiliser -K, configurer become/become_user, vérifier NOPASSWD

"Timeout (12s) waiting for privilege escalation prompt"
→ Nettoyer /etc/sudoers.d, tester -K, réduire MOTD interactif

"python not found" / "MODULE FAILURE"
→ Installer python3, utiliser interpreter_python=auto_silent
ou: ansible all -m raw -a "apt-get update && apt-get install -y python3"

Diff systemd invalide
→ Ajouter validate: "systemd-analyze verify %s" sur le template

Fichier rendu invalide (nginx/haproxy)
→ Utiliser validate: "nginx -t -c %s" / "haproxy -c -f %s" + --check --diff
----

.Astuce Finale
[source,text]
----
Réduire le scope pour isoler (un hôte, une tâche, -vvv) puis élargir progressivement
----

.Structure de Projet Avancée
[source,bash]
----
ansible/
├─ inventories/
│ ├─ production/
│ │ ├─ hosts.ini
│ │ ├─ group_vars/
│ │ └─ host_vars/
│ └─ staging/...
├─ playbooks/
│ ├─ site.yml
│ ├─ web.yml
│ └─ db.yml
├─ roles/
│ ├─ base_setup/
│ │ ├─ defaults/main.yml
│ │ ├─ tasks/main.yml
│ │ ├─ templates/
│ │ └─ files/
│ └─ webapp/...
├─ collections/
├─ plugins/
└─ .fact_cache/
----

[NOTE]
--
.Bonnes pratiques:
- Utiliser des inventaires multi-environnements
- Privilégier les modules aux commandes shell
- Valider les configurations avec validate
- Masquer les secrets avec no_log: true
- Structurer les variables par ordre de priorité
- Utiliser des collections pour étendre les fonctionnalités
--

