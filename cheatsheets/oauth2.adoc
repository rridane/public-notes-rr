:author-url: https://github.com/rridane
:author: rridane
:source-highlighter: rouge
:hardbreaks:
:table-caption!:
:toc: left
:toclevels: 3
:numbered:

= OAuth 2.0 – Cheatsheet

*grant types* = comment un client obtient un *access token* :

* *Authorization Code* – Pour les applications côté serveur (clients confidentiels) type front php. Sécurisé, recommandé dans la majorité des cas.
* *Authorization Code + PKCE* – Variante renforcée du flux précédent pour les applications publiques (SPA, mobile), évitant l’exposition du token. Pour toutes les applications type react, angular, vue, flutter... Toutes les applications dont le code est accessible pour un attaquant.
* *Client Credentials* – Pour les communications machine-à-machine, sans intervention utilisateur.
* *Device Code* – Pour les appareils sans navigateur (TV, IoT), où l’utilisateur s’authentifie sur un autre terminal.
* *Refresh Token* – Pour obtenir de nouveaux tokens sans ré-authentification de l’utilisateur.
* *Implicit Flow* – Ancien flux désormais déconseillé, car les tokens transitent dans l’URL du navigateur. (Non abordé ici)

== Flux Authorization Code

__FLUX MACHINE SECURISÉ À MACHINE SECURISÉ__

[plantuml]
----
@startuml
actor "Utilisateur" as User
participant "Navigateur"
participant "Client (App Web)" as Client
participant "Authorization Server (AS)" as AS

== Accès initial ==
User -> Navigateur : Accès à une ressource protégée (/photos)
Navigateur -> Client : GET /photos

Client -> Navigateur : Redirection 302 vers AS

note right of Navigateur
Redirection vers :
https://auth.example.com/authorize?
- response_type=code
- client_id=client123
- redirect_uri=https://client.com/callback
- scope=read:photos
- state=xyz123
end note

Navigateur -> AS : GET /authorize avec paramètres

note right of AS
L’AS :
- Identifie le client via client_id
- Vérifie redirect_uri
- Affiche une page de login
end note

AS -> Navigateur : Page HTML avec formulaire de login
@enduml
----

[plantuml]
----
@startuml
actor "Utilisateur" as User
participant "Navigateur"
participant "Client (App Web)" as Client
participant "Authorization Server (AS)" as AS

== Authentification ==
User -> Navigateur : Remplit login / mot de passe
Navigateur -> AS : POST /login avec credentials

AS -> AS : Vérifie les identifiants

== Consentement ==
note right of AS
Affiche une page de consentement :
- Scopes demandés
- Nom du client
- Bouton "Autoriser"
end note

User -> Navigateur : Clique sur "Autoriser"
Navigateur -> AS : POST /consent

== Génération du code ==
note right of AS
L’AS :
- Génère un code unique (ex: abc123)
- Associe code + client_id + utilisateur + scopes
- Stocke en base temporairement
end note

AS -> Navigateur : Redirection 302 vers redirect_uri

note right of Navigateur
Redirection vers :
https://client.com/callback?
- code=abc123
- state=xyz123
end note

Navigateur -> Client : GET /callback?code=abc123&state=xyz123

== Échange de code contre token ==
Client -> AS : POST /token

note right of Client
Body :
- grant_type=authorization_code
- code=abc123
- redirect_uri=https://client.com/callback
- client_id + client_secret (ou header Basic)
end note

AS -> AS : Vérifie code, expiration, client_id

AS -> Client : access_token + refresh_token (JSON)
@enduml
----

[source,http]
----
POST /token HTTP/1.1
Host: auth.example.com
Content-Type: application/x-www-form-urlencoded
Authorization: Basic base64(client_id:client_secret)
grant_type=authorization_code&
code=abc123&
redirect_uri=https://client.com/callback
----

Ou, sans en-tête Authorization :
[source,x-www-form-urlencoded]
----
POST /token HTTP/1.1
Host: auth.example.com
Content-Type: application/x-www-form-urlencoded
grant_type=authorization_code
&code=abc123
&redirect_uri=https://client.com/callback
&client_id=client123
&client_secret=secret456
----

== Flux Authorization Code + PKCE

PKCE (Proof Key for Code Exchange)

[plantuml]
----
@startuml
actor "Utilisateur" as User
participant "Navigateur (App SPA/Mobile)" as App
participant "Authorization Server (AS)" as AS

== Génération côté client ==
note right of App
Avant toute redirection :
- Génère un `code_verifier` (chaîne aléatoire)
- Calcule `code_challenge = BASE64URL(SHA256(code_verifier))`
end note

User -> App : Demande une ressource protégée
App -> AS : Redirection vers /authorize

note right of App
GET /authorize?
- response_type=code
- client_id=public123
- redirect_uri=https://app.com/callback
- code_challenge=xyz987
- code_challenge_method=S256
- scope=read:photos openid
- state=abc999
end note

App -> AS : GET /authorize avec code_challenge
AS -> App : Affiche page login / mot de passe
@enduml
----

[plantuml]
----
@startuml
actor "Utilisateur" as User
participant "Navigateur (App SPA/Mobile)" as App
participant "Authorization Server (AS)"

== Authentification ==
User -> App : Saisie identifiants
App -> AS : POST /login (username, password)
AS -> AS : Vérifie l'identité

== Consentement ==
note right of AS
Affiche consentement :
- Scopes demandés
- Client concerné
- Bouton "Autoriser"
end note

User -> App : Autorise les accès
App -> AS : POST /consent

== Redirection avec code ==
note right of AS
L’AS :
- Génère un code unique (auth code)
- L’associe au client + code_challenge + scopes
end note

AS -> App : Redirection 302 vers redirect_uri?code=abc123&state=abc999
App -> App : Extrait le code d'autorisation

== Échange avec code_verifier ==
App -> AS : POST /token

note right of App
POST :
- grant_type=authorization_code
- code=abc123
- redirect_uri=https://app.com/callback
- code_verifier = original string générée
- client_id = public123
(end note)

AS -> AS : Vérifie code + calcule SHA256(code_verifier)

note right of AS
Vérifie que :
SHA256(code_verifier) == code_challenge reçu à l’étape /authorize
end note

AS -> App : Renvoie access_token (+ id_token, refresh_token si OIDC)
@enduml
----

== Flux Client Credentials

__FLUX MACHINE À MACHINE (SANS UTILISATEUR )__

[plantuml]
----
@startuml
participant "Client (Backend Service)" as Client
participant "Authorization Server (AS)" as AS
participant "Resource Server (API)" as API

== Authentification ==
Client -> AS : POST /token

note right of Client
Body :
grant_type=client_credentials
client_id=backend-app
client_secret=s3cr3t
scope=read:logs (optionnel)
end note

AS -> AS : Vérifie client_id + client_secret
AS -> Client : access_token (JSON)

== Appel API ==
Client -> API : GET /resource
note right of Client
Authorization: Bearer <access_token>
end note

API -> Client : Données autorisées
@enduml
----

[source,http]
----
POST /token HTTP/1.1
Host: auth.example.com
Content-Type: application/x-www-form-urlencoded
Authorization: Basic base64(client_id:client_secret)
grant_type=client_credentials
&scope=read:logs

Ou sans en-tête Authorization, dans le corps :
[source,x-www-form-urlencoded]
grant_type=client_credentials
&client_id=backend-app
&client_secret=s3cr3t
&scope=read:logs
----

== Flux Device Code

Appareils **dépourvus de navigateur** ou avec **interface utilisateur limitée** (TV, consoles, imprimantes, IoT).

[plantuml]
----
@startuml
actor "Utilisateur" as User
participant "Device (Appareil)" as Device
participant "Authorization Server (AS)" as AS
participant "Navigateur (sur autre appareil)" as Browser
participant "Resource Server (API)" as API

== 1. Demande de code ==
Device -> AS : POST /device_authorization
note right of Device
Paramètres :
- client_id
- scope
end note

AS -> Device : device_code + user_code + verification_uri
note right of AS
Réponse :
- device_code
- user_code
- verification_uri
- verification_uri_complete
- expires_in
- interval
end note

== 2. L'utilisateur autorise ==
Device -> User : Affiche user_code + URL
User -> Browser : Va sur verification_uri
User -> AS : S’authentifie et saisit le user_code
AS -> User : Demande consentement
User -> AS : Autorise l’accès

== 3. Polling token ==
loop polling
Device -> AS : POST /token
note right of Device
Paramètres :
- grant_type=device_code
- device_code
- client_id
end note

AS -> Device : pending / slow_down / access_token
end loop

== 4. Accès API ==
Device -> API : Authorization: Bearer <access_token>
API -> Device : Données autorisées
@enduml
----

[source,http]
----
POST /device_authorization
Host: auth.example.com
Content-Type: application/x-www-form-urlencoded

client_id=client123&
scope=read:profile
----

Réponse :

[source,json]
----
{
  "device_code": "abc123xyz",
  "user_code": "XY12-ZZ45",
  "verification_uri": "https://auth.example.com/activate",
  "verification_uri_complete": "https://auth.example.com/activate?user_code=XY12-ZZ45",
  "expires_in": 1800,
  "interval": 5
}
----

L’appareil affiche :
----
Pour continuer, rendez-vous sur : https://auth.example.com/activate
Code : XY12-ZZ45
----

. Ouvre son navigateur sur un autre appareil
. Va sur la `verification_uri`
. S’authentifie (login/mot de passe)
. Saisit le `user_code`
. Accepte les scopes demandés

__Le device interroge régulièrement le serveur__

[source,http]
----
POST /token
Host: auth.example.com
Content-Type: application/x-www-form-urlencoded

grant_type=urn:ietf:params:oauth:grant-type:device_code&
device_code=abc123xyz&
client_id=client123
----

Réponses possibles :

* `authorization_pending` → l’utilisateur n’a pas encore validé
* `slow_down` → trop de requêtes
* `access_token` → succès

== Flux Refresh Token

Obtenir un nouveau `access_token` **sans interaction utilisateur**, une fois que le token d’origine a expiré.

.refresh_token avec client sûr
[plantuml]
----
@startuml
actor "Utilisateur" as User
participant "Client (App)" as Client
participant "Authorization Server (AS)" as AS
participant "Resource Server (API)" as API

== 1. Flux initial ==
User -> Client : Authentification initiale (ex: code)
Client -> AS : POST /token
AS -> Client : access_token + refresh_token

== 2. Appel API ==
Client -> API : Authorization: Bearer access_token
API -> Client : Données

== 3. Le token expire ==
note right of Client
access_token expiré (ex: 3600s)
end note

== 4. Rafraîchissement ==
Client -> AS : POST /token
note right of Client
Paramètres :
- grant_type=refresh_token
- refresh_token
- client_id (+ client_secret si confidentiel)
end note

AS -> Client : Nouveau access_token (+ refresh_token si rotation)
@enduml
----

.client publique non sûr (pkce)

[plantuml]
----
@startuml
actor "Utilisateur" as User
participant "Client (SPA – public)" as Client
participant "Authorization Server (AS)" as AS
participant "Resource Server (API)" as API

== 1. Flux initial ==
User -> Client : Authentification initiale (avec PKCE)
Client -> AS : POST /token (code + code_verifier)
AS -> Client : access_token + refresh_token

== 2. Appel API ==
Client -> API : Authorization: Bearer access_token
API -> Client : Données

== 3. Le token expire ==
note right of Client
access_token expiré (ex: 3600s)
end note

== 4. Rafraîchissement ==
Client -> AS : POST /token

note right of Client
Paramètres :
- grant_type=refresh_token
- refresh_token
- client_id
(N.B. : PAS de client_secret)
end note

AS -> Client : Nouveau access_token (+ refresh_token si rotation)
@enduml
----

[source,http]
----
POST /token HTTP/1.1
Host: auth.example.com
Content-Type: application/x-www-form-urlencoded
Authorization: Basic base64(client_id:client_secret)

grant_type=refresh_token
&refresh_token=def456uvw
----

Ou dans le corps :

[source,x-www-form-urlencoded]
----
grant_type=refresh_token
&client_id=client123
&client_secret=s3cr3t # Si applicable
&refresh_token=def456uvw
----

== 🔐 Gestion de l’URL cible et du state

----
state=csrf123___/photos/1234
----

Le format permet d’associer protection CSRF et redirection.

Une fois l’utilisateur redirigé vers le client avec `?code=abc123&state=csrf123___/photos/1234`, le client :

. vérifie la partie anti-CSRF (`csrf123`)
. récupère ou décode l’URL d’origine (`/photos/1234`)
. effectue la redirection finale vers la ressource cible

=== 🔐 JAR – JWT Authorization Request

*JAR* (JWT Authorization Request) : Envoyer une requête `/authorize` encapsulée dans un JWT signé

[source,http]
----
GET /authorize?request=eyJhbGciOiJSUzI1NiIsImtpZCI6ImtleS0xIn0... (JWT signé)
----

Ce JWT contient tous les paramètres OAuth habituels, comme :
- `client_id`
- `redirect_uri`
- `response_type`
- `scope`
- `state`
- `exp`, `aud`, `iss` (normes JWT)

.En-tête (header)
[source,json]
----
{
  "alg": "RS256",
  "typ": "JWT",
  "kid": "client-key-1"
}
----

.Payload (claims)
[source,json]
----
{
  "response_type": "code",
  "client_id": "client123",
  "redirect_uri": "https://client.example.com/callback",
  "scope": "openid profile",
  "state": "abcXYZ123",
  "nonce": "n-0S6_WzA2Mj",
  "aud": "https://auth.example.com",
  "iss": "client123",
  "exp": 1710000000
}
----

Signée avec la clé privée du client, référencée par `kid`.
Le client fournit une URL lors de son enregistrement (statique ou dynamique) :

[source,json]
----
{
  "client_id": "client123",
  "jwks_uri": "https://client.example.com/jwks.json"
}
----

Exemple de `jwks.json` publié par le client :

[source,json]
----
{
  "keys": [
    {
      "kty": "RSA",
      "kid": "client-key-1",
      "use": "sig",
      "alg": "RS256",
      "n": "MIIBIjANBgkqhk...",  // clé publique modulaire (base64url)
      "e": "AQAB"
    }
  ]
}
----

Ou via `jwks` inline à l’enregistrement

[source,json]
----
{
  "client_id": "client123",
  "jwks": {
    "keys": [ ... ] // même format que ci-dessus
  }
}
----

=== 📦 JARM – JWT Secured Authorization Response Mode

JARM (*JWT Secured Authorization Response Mode*) permet à l’Authorization Server de **renvoyer la réponse `/authorize` encapsulée dans un JWT signé**, au lieu de transmettre les paramètres (`code`, `state`, etc.) directement dans l’URL.

==== 🧭 Exemple de flux avec JARM

[source,http]
----
GET /authorize?response_mode=jwt
----

Au lieu d’un retour classique :
[source,http]
----
302 Found
Location: https://client.com/callback?code=abc123&state=xyz456
----

L’AS renvoie :
[source,http]
----
302 Found
Location: https://client.com/callback?response=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...
----

.En-tête
[source,json]
----
{
  "alg": "RS256",
  "kid": "as-key-1",
  "typ": "JWT"
}
----

.Payload
[source,json]
----
{
  "iss": "https://auth.example.com",
  "aud": "client123",
  "exp": 1710000000,
  "iat": 1709999400,
  "code": "abc123",
  "state": "xyz456",
  "redirect_uri": "https://client.com/callback"
}
----

.Signature
Signée par l’Authorization Server avec sa clé privée.

Le client doit :
. Vérifier la signature avec la clé publique de l’AS (`jwks_uri` de l’AS)
. Vérifier les claims `iss`, `aud`, `exp`
. Extraire le `code` et le `state` du payload

Comme pour tous les JWT OIDC, l’AS expose sa clé via son fichier de configuration OIDC :

[source,http]
----
GET /.well-known/openid-configuration
----

Extrait typique :
[source,json]
----
{
  "issuer": "https://auth.example.com",
  "jwks_uri": "https://auth.example.com/.well-known/jwks.json"
}
----

Le client récupère les clés :
[source,json]
----
{
  "keys": [
    {
      "kty": "RSA",
      "kid": "as-key-1",
      "alg": "RS256",
      "use": "sig",
      "n": "...",
      "e": "AQAB"
    }
  ]
}
----

=== 🔐 DPoP – Demonstration of Proof-of-Possession

DPoP (*Demonstration of Proof-of-Possession*) : Extension OAuth 2.0 visant à **protéger les access tokens contre le vol et le rejeu**.

==== Vulgarisation du fonctionnement

Dans chaque access_token on trouve une clé publique, il s'agit tout simplement de celle fournie par le client, lors de la demande de token. Le client peut mettre la clé publique de son choix. La seule condition est que si il utilise cet access_token il doit prouver qu'il détient la clé privée associée. Cela se fait via le champ DPoP, qui contient un jwt signé par la clé privée associée à la clé publique.

Autrement dit, l'utilisateur du token doit prouver qu'il détient la clé privée associée à la clé publique.

==== 🧭 Vue d’ensemble du fonctionnement

. Le client génère localement une **paire de clés** asymétriques (ex: EC P-256)
. Lors de l’appel `/token`, il envoie un JWT signé dans l’en-tête HTTP `DPoP`, qui contient :
- la **clé publique** dans le champ `jwk` de l’en-tête du JWT
- la méthode HTTP (`htm`)
- l’URL cible (`htu`)
- un `jti` unique
- un timestamp `iat`
- et est **signé avec la clé privée correspondant à la clé publique fournie**
. L’Authorization Server :
- extrait la **clé publique (`jwk`) de l’en-tête du JWT**
- vérifie que la signature est correcte avec cette clé
- **l’inclut dans l’`access_token`** via le champ `cnf.jwk`

. Lors des appels aux APIs, le client :
  - signe chaque requête avec un nouveau JWT DPoP
  - fournit le même `access_token`, précédé du mot-clé `DPoP`
. Le serveur de ressources :
  - vérifie que le JWT est signé avec la même clé publique que celle liée au token
  - rejette les appels dont la clé ne correspond pas ou dont le `jti` a déjà été vu (anti-rejeu)

[source,http]
----
POST /token
Host: auth.example.com
Authorization: Basic base64(client_id:client_secret)
Content-Type: application/x-www-form-urlencoded
DPoP: eyJhbGciOiJFUzI1NiIsInR5cCI6ImRwb3Arand0Iiwian... (JWT signé)

grant_type=authorization_code
&code=abc123
&redirect_uri=https://client.com/callback
----

L’en-tête `DPoP` est un JWT signé avec la **clé privée** du client.


.Header :
[source,json]
----
{
  "typ": "dpop+jwt",
  "alg": "ES256",
  "jwk": {
    "kty": "EC",
    "crv": "P-256",
    "x": "f83OJ3D2xF4U2hK2Y7KiGH2V",
    "y": "x_FEzRu9bktM6uZ7RzvJ2HiV"
  }
}
----

.Payload :
[source,json]
----
{
  "htu": "https://auth.example.com/token",
  "htm": "POST",
  "iat": 1723212345,
  "jti": "550e8400-e29b-41d4-a716-446655440000"
}
----

.Signature :
- Faite avec la **clé privée associée au `jwk` ci-dessus**
- Le `jti` est un ID **unique généré par le client**, utilisé pour l’anti-rejeu
- Le `iat` est un timestamp Unix (en secondes)
- Le `htm` (HTTP Method) et `htu` (Target URI) lient la preuve à la requête

L’Authorization Server inclut la **clé publique du client** dans le `access_token`, sous le champ `cnf.jwk`.

Exemple de payload JWT :

[source,json]
----
{
  "sub": "user123",
  "iss": "https://auth.example.com",
  "aud": "https://api.example.com",
  "scope": "read:profile",
  "exp": 1723216000,
  "cnf": {
    "jwk": {
      "kty": "EC",
      "crv": "P-256",
      "x": "f83OJ3D2xF4U2hK2Y7KiGH2V",
      "y": "x_FEzRu9bktM6uZ7RzvJ2HiV"
    }
  }
}
----

[source,http]
----
GET /me HTTP/1.1
Host: api.example.com
Authorization: DPoP eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
DPoP: eyJhbGciOiJFUzI1NiIsInR5cCI6ImRwb3Arand0Iiwian... (JWT signé)
----

* Le champ `Authorization` contient le `access_token`, précédé du mot-clé `DPoP` (et non `Bearer`)
* Le champ `DPoP` contient un **nouveau JWT signé**, généré pour cette requête spécifique

.Header :
[source,json]
----
{
  "typ": "dpop+jwt",
  "alg": "ES256",
  "jwk": { ... même que précédemment ... }
}
----

.Payload :
[source,json]
----
{
  "htu": "https://api.example.com/me",
  "htm": "GET",
  "iat": 1723212450,
  "jti": "7ca3c4a1-b1f3-43a6-9f4f-f9ea38cfcd99"
}
----

L’API doit vérifier :

* que le JWT DPoP est bien formé et non expiré
* que le `jwk` dans le header correspond au `cnf.jwk` du token
* que la signature est valide (avec la clé publique)
* que le `htm` et `htu` correspondent à la requête réelle
* que le `jti` n’a jamais été vu (anti-rejeu)

=== 🔐 MTLS – Mutual TLS (certificat client + access_token lié)

OAuth 2.0 **détourne mTLS** pour deux usages bien précis :

1. 🔐 **Authentification du client OAuth**
- Le client **présente son certificat** lors du handshake TLS vers `/token`
- Le serveur OAuth (AS) utilise ce certificat pour **identifier et authentifier le `client_id`**

- Deux modes sont possibles :

a. `tls_client_auth` : certificat signé par une CA connue, c'est le full handshake qui valide le certificat
b. `self_signed_tls_client_auth` : certificat auto-signé, mais dont la **clé publique est pré-enregistrée**, c'est l'étape /token qui valide le certificat en comparant la clé publique fournie avec celles enregistrées

2. 🔗 **Liaison de l’`access_token` à ce certificat**
- L’AS extrait l’empreinte SHA-256 du certificat présenté
- Il l’intègre dans le `access_token` (JWT) dans le champ `cnf.x5t#S256`
- Ainsi, **le token ne pourra être utilisé que via mTLS avec ce même certificat**

.tls_client_auth
[plantuml]
----
@startuml
actor "Client OAuth" as Client
participant "Auth Server" as AS
participant "TLS Layer" as TLS

== Connexion TLS mutualisée ==

Client -> TLS : ClientHello (propose mTLS)
TLS -> Client : CertificateRequest
Client -> TLS : Certificat X.509 signé (par CA)
note right of Client
Le client signe un challenge TLS
avec sa clé privée
end note
note right of TLS
Vérifie :
* Validité du CA
* Possession de la clé privée via challenge
end note
TLS -> AS : TLS OK, connexion établie

== Appel /token ==

Client -> AS : POST /token\n(client_id, grant_type, scope)
note right of AS
Compare le certificat reçu avec
celui attendu pour client_id
end note
AS -> AS : Calcule x5t#S256 du certificat
AS -> Client : access_token JWT\n(avec cnf.x5t#S256)
@enduml
----

.self_signed_tls_client_auth
[plantuml]
----
@startuml
actor "Client OAuth" as Client
participant "Auth Server" as AS
participant "TLS Layer" as TLS

== Connexion TLS mutualisée ==

Client -> TLS : ClientHello (propose mTLS)
TLS -> Client : CertificateRequest
Client -> TLS : Certificat X.509 auto-signé
note right of Client
Le client signe un challenge TLS
avec sa clé privée
end note
note right of TLS
Vérifie :
* Possession de la clé privée via challenge
⚠️ Pas de vérification de l’émetteur (auto-signé)
end note
TLS -> AS : TLS OK, connexion établie

== Appel /token ==

Client -> AS : POST /token\n(client_id, grant_type, scope)
note right of AS
Compare la **clé publique** du certificat TLS
avec celle enregistrée pour ce `client_id`
end note
AS -> AS : Calcule x5t#S256 du certificat
AS -> Client : access_token JWT\n(avec cnf.x5t#S256)
@enduml
----

.Récupération du token (identique au deux flux)
[plantuml]
----
@startuml
actor "Client OAuth" as Client
participant "API Server" as API
participant "TLS Layer" as TLS

== Connexion mTLS ==

Client -> TLS : ClientHello (mTLS)
TLS -> Client : CertificateRequest
Client -> TLS : Certificat X.509 (même que /token)
note right of Client
Le client signe un challenge TLS
avec sa clé privée
end note
note right of TLS
Vérifie :
* Validité du CA
* Possession de la clé privée via challenge
end note
TLS -> API : TLS OK, session établie

== Appel API ==

Client -> API : GET /data\nAuthorization: Bearer eyJ...
API -> API : Extrait le certificat de TLS
API -> API : Calcule x5t#S256
API -> API : Compare avec cnf.x5t du token

alt Correspondance OK
  API -> Client : ✅ Donne la ressource
else Mauvaise clé ou token volé
  API -> Client : ❌ 401 Unauthorized
end
@enduml
----

[source,http]
----
POST /token
Host: auth.example.com
Content-Type: application/x-www-form-urlencoded

grant_type=client_credentials
&client_id=backend-app
&scope=read:data
----

[source,json]
----
{
  "sub": "backend-app",
  "aud": "https://api.example.com",
  "exp": 1723216000,
  "scope": "read:data",
  "cnf": {
    "x5t#S256": "FhS7ey5eTxN0GqR5twF7K1v0Vya8lJcvZP9ZT2aPjSo"
  }
}
----

`cnf.x5t#S256` :
- empreinte SHA-256 du certificat **présenté à `/token`**
- encodée en base64url (format conforme à JWK Thumbprint)
- calculé comme ceci en accord avec la RFC 7638: thumbprint = base64url(SHA-256(canonicalized certificate))

> Utilisable **qu’avec ce même certificat** dans les appels aux APIs.

[source,http]
----
GET /me HTTP/1.1
Host: api.example.com
Authorization: Bearer eyJhbGciOiJSUzI1NiIs...
----

✔️ La requête est faite **en HTTPS avec mTLS**
✔️ Le **même certificat client** est présenté que lors de `/token`
✔️ Le serveur API :
- extrait ce certificat de la session TLS
- calcule son empreinte SHA-256
- la compare à `cnf.x5t#S256` dans le JWT

✅ Requête acceptée **uniquement si l’empreinte correspond**

=== 🔐 FAPI – Financial-grade API (OAuth 2.0 durci)

FAPI est une *spécification de l’OpenID Foundation* visant à sécuriser les APIs sensibles (finance, santé, identité…).

Elle repose entièrement sur OAuth 2.0, mais impose une *combinaison stricte de mécanismes existants* pour renforcer l’authentification, l’intégrité, la confidentialité et la non-répudiation.

.Exigences de FAPI
[cols="1,4a",options="header"]
|===
|Élément |Rôle

|*PKCE* (RFC 7636)
|Empêche le vol du code d'autorisation

|*JAR* – JWT Authorization Request
|Signature de la requête `/authorize` (intégrité + non-répudiation)

|*JARM* – JWT Authorization Response
|Signature de la réponse à `/authorize` (intégrité + vérifiabilité)

|*mTLS* ou *DPoP*
|Preuve de possession du client + liaison des tokens (`cnf`)

|*Access Token lié au certificat ou JWK*
|Via `cnf.x5t#S256` (mTLS) ou `cnf.jwk` (DPoP)

|*HTTP Message Signing*
|Protection des appels API contre la falsification

|*Scopes strictement limités*
|Principe du moindre privilège renforcé

|*Rotation obligatoire des refresh_token*
|Réduction de l'impact en cas de vol

|*Pas de token réutilisable hors preuve*
|Les tokens liés à un certificat ou une clé privée ne peuvent pas être réutilisés ailleurs
|===

[NOTE]
====
FAPI *n’est pas un nouveau protocole*, mais un *profil de sécurité OAuth 2.0 renforcé*, souvent requis en Open Banking (Royaume-Uni, UE…).
====

📖 https://openid.net/fapi/[Spécification officielle]
