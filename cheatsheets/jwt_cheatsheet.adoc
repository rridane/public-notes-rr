:author-url: https://github.com/rridane
:author: rridane
:source-highlighter: rouge
:hardbreaks:
:table-caption!:
:toc: left
:toclevels: 3
:numbered:

= JWT (JSON Web Tokens) ‚Äì CheatSheet

== Header

Le header est le m√™me (en structure), que l'on soit en JWS ou en JWE.

[source,json]
----
{
  "alg": "RS256",
  "typ": "JWT",
  "kid": "abc123"
}
----

* `alg` : algorithme de signature (`HS256`, `RS256`, `ES256`, ‚Ä¶) ou de chiffrement (`RSA-OAEP`, ‚Ä¶)
* `typ` : type du jeton ‚Äì g√©n√©ralement `"JWT"`
* `kid` : **Key ID** (Identifiant de la cl√© publique) optionnel, indispensable pour la rotation de cl√©s

== Payload (claims)

.Exemple exhaustif
[source,json]
----
{
  "iss": "https://auth.example.com",
  "sub": "user_123456",
  "aud": "api.example.com",
  "exp": 1710000000,
  "nbf": 1709990000,
  "iat": 1709980000,
  "jti": "abcd-1234-efgh-5678",
  "scope": "read:users write:users",
  "roles": ["admin", "user"],
  "email": "john.doe@example.com",
  "username": "johndoe",
  "tenant_id": "tenant_abc",
  "custom_claim": "custom_value"
}
----

.Tableau des *registered claims*
[cols="1,1,2",options="header"]
|===
|Claim |Type |Description
|`iss` |string |Issuer : √©metteur du token
|`sub` |string |Subject : identifiant du sujet
|`aud` |string / array |Audience : destinataire pr√©vu
|`exp` |timestamp |Expiration : date d‚Äôexpiration (obligatoire en prod)
|`nbf` |timestamp |Not Before : valide √† partir de
|`iat` |timestamp |Issued At : date de cr√©ation
|`jti` |string |JWT ID : identifiant unique
|===

Autres claims fr√©quents : `scope`, `roles`, `email`, `tenant_id`, `custom_*`.

== JWS

=== Algorithmes de signature JWS

[cols="1,1,2",options="header"]
|===
|Algorithme |Type |Usage
|`HS256`, `HS384`, `HS512` |Sym√©trique (HMAC) |Cl√© partag√©e entre parties (simple mais risqu√© √† grande √©chelle)
|`RS256`, `RS384`, `RS512` |Asym√©trique (RSA + SHA) |Cl√© priv√©e pour signer, cl√© publique (JWKS) pour v√©rifier
|`ES256`, `ES384`, `ES512` |Asym√©trique (ECDSA) |Compact, rapide, s√©curis√© (bas√© sur courbes elliptiques)
|`none` |‚ö†Ô∏è Aucun |‚ö†Ô∏è √Ä proscrire : vuln√©rabilit√© historique
|===

*Recommand√© :* `RS256` ou `ES256` avec rotation (`kid` + JWKS)

=== üîÅ √âtapes de la signature JWS (`RS256`)

[source,text]
----
1. Encodage Base64URL :
   encoded_header  = base64url(header JSON)
   encoded_payload = base64url(payload JSON)

2. Construction du message √† signer :
   message = encoded_header + "." + encoded_payload

3. Hash du message :
   hash = SHA-256(message)

4. Signature RSA :
   signature = RSA_sign(private_key, hash)

5. Encodage final :
   encoded_signature = base64url(signature)

6. JWT final :
   JWT = encoded_header + "." + encoded_payload + "." + encoded_signature
----

=== ‚úÖ V√©rification de la signature JWS pas √† pas (RS256)

[source,text]
----
# D√©coder le JWT :
JWT = <header_b64>.<payload_b64>.<signature_b64>

D√©coder Base64URL :
header = base64url_decode(header_b64)
payload = base64url_decode(payload_b64)
signature = base64url_decode(signature_b64)

Reconstituer le message sign√© :
message = header_b64 + "." + payload_b64

Calculer le hash :
hash = SHA-256(message)

V√©rifier la signature RSA :
is_valid = RSA_verify(public_key, hash, signature)
----

[source,code]
----
# Supposons que $JWS contienne le JWT complet
# Note : la commande read utilise nativement IFS, raison pour laquelle elle d√©compose le jws

IFS='.' read -r header_b64 payload_b64 signature_b64 <<< "$JWS"

# Reconstituer le message sign√©
message="${header_b64}.${payload_b64}"

# D√©coder la signature
printf '%s' "$signature_b64" | base64 -d -A > sig.bin

# V√©rifier la signature avec la cl√© publique
printf '%s' "$message" | openssl dgst -sha256 -verify public.pem -signature sig.bin
----

=== üîê JWE

.Structure
----
<HEADER>.<ENCRYPTED_KEY>.<IV>.<CIPHERTEXT>.<TAG>   (JWE)

# En r√©alit√© tout est en base64
Base64URL(HEADER).Base64URL(ENCRYPTED_KEY).Base64URL(IV).Base64URL(CIPHERTEXT).Base64URL(TAG)
----

R√©alis√© via **chiffrement sym√©trique** (ex : AES-256-GCM) avec une **cl√© CEK** unique par message.

[cols="1,3",options="header"]
|===
|Segment |Contenu

|`HEADER` |Instructions sur les algorithmes utilis√©s (`alg`, `enc`, `kid`, etc.)
|`ENCRYPTED_KEY` |Cl√© de chiffrement de contenu (CEK) **chiffr√©e** avec la **cl√© publique** du destinataire
|`IV` |Vecteur d‚Äôinitialisation al√©atoire pour AES-GCM
|`CIPHERTEXT` |Payload JSON chiffr√©e avec CEK et IV
|`TAG` |Tag d‚Äôauthentification assurant l‚Äôint√©grit√© du message
|===

[NOTE]
----
L‚Äô**AAD** est une **donn√©e d‚Äôen-t√™te** (g√©n√©ralement le `header`) incluse dans le calcul du **tag d‚Äôauthentification**
----

=== ‚öôÔ∏è √âtapes d√©taill√©es du processus de chiffrement JWE

. G√©n√©rer une CEK (**Content Encryption Key**) al√©atoire (ex: 256 bits pour AES)
. G√©n√©rer un IV (ex: 96 bits pour AES-GCM)
. Chiffrer la **payload JSON** avec CEK + IV ‚Üí produit `CIPHERTEXT` + `TAG`
. Chiffrer la **CEK** avec la **cl√© publique du destinataire** (`alg`) ‚Üí `ENCRYPTED_KEY`
. Construire le `HEADER` avec les m√©tadonn√©es (`alg`, `enc`, `kid`)
. Encoder tous les √©l√©ments en Base64URL et concat√©ner

[source,text]
----
1. G√©n√©ration al√©atoire :
   - CEK = cl√© sym√©trique (ex : 256 bits pour A256GCM)
   - IV  = vecteur d‚Äôinitialisation (ex : 96 bits al√©atoires)

2. Construction du Header :
   header = {
     "alg": "RSA-OAEP",
     "enc": "A256GCM",
     "kid": "abc123"
   }

3. Encodage Base64URL du header :
   encoded_header = base64url( JSON(header) )

4. AAD (Additional Authenticated Data) :
   AAD = encoded_header   (non chiffr√©, mais authentifi√©)

5. Chiffrement AES-GCM :
   - Entr√©e : payload JSON
   - AES-GCM(key=CEK, iv=IV, aad=AAD) ‚ûú CIPHERTEXT + TAG

6. Chiffrement de la CEK (cl√© de session) :
   - encrypted_key = RSA_encrypt(public_key, CEK)

7. Encodages Base64URL :
   - encrypted_key_b64  = base64url(encrypted_key)
   - iv_b64             = base64url(IV)
   - ciphertext_b64     = base64url(CIPHERTEXT)
   - tag_b64            = base64url(TAG)

8. Construction finale du JWE compact :
   JWE = encoded_header + "." +
         encrypted_key_b64 + "." +
         iv_b64 + "." +
         ciphertext_b64 + "." +
         tag_b64
----

=== ‚úÖ V√©rification du TAG JWE (AES-GCM)

[source,bash]
----
# Suppose que $JWE contient le token compact : HEADER.ENCRYPTED_KEY.IV.CIPHERTEXT.TAG

IFS="." read -r header_b64 encrypted_key_b64 iv_b64 ciphertext_b64 tag_b64 <<< "$JWE"

# 1. D√©codage des segments en base64url (sans padding)
b64url_decode() {
  local input="$1"
  local rem=$(( ${#input} % 4 ))
  [[ $rem -eq 2 ]] && input="${input}=="
  [[ $rem -eq 3 ]] && input="${input}="
  echo "$input" | tr '_-' '/+' | openssl base64 -d -A
}

header=$(b64url_decode "$header_b64")
encrypted_key=$(b64url_decode "$encrypted_key_b64")
iv=$(b64url_decode "$iv_b64")
ciphertext=$(b64url_decode "$ciphertext_b64")
tag=$(b64url_decode "$tag_b64")

# 2. D√©chiffrer la CEK avec la cl√© priv√©e
# Cela suppose que tu as la cl√© priv√©e dans private.pem
CEK=$(echo -n "$encrypted_key" | openssl rsautl -decrypt -inkey private.pem -oaep -raw | xxd -p -c256)

# 3. Rejouer le d√©chiffrement AES-GCM avec AAD = header_b64
# Pr√©parer les fichiers
echo -n "$ciphertext" > ciphertext.bin
echo -n "$tag" > tag.bin
echo -n "$iv" > iv.bin
echo -n "$header_b64" > aad.txt

# Reconstituer payload.json (si le tag est valide)
openssl enc -d -aes-256-gcm \
  -K "$CEK" \
  -iv "$(< iv.bin | xxd -p)" \
  -in ciphertext.bin \
  -out payload.json \
  -nosalt \
  -p \
  -aad "$(< aad.txt)" \
  -tag "$(< tag.bin | xxd -p)"

# Si le TAG est incorrect, openssl retournera une erreur :
# > bad decrypt
----

==== Algorithmes JWE (structure hybride)

[cols="1,1,2",options="header"]
|===
|Champ |Algorithmes |Usage

|`alg` |RSA-OAEP, ECDH-ES, A256KW, etc. |Chiffre la CEK (asym√©trique)
|`enc` |A128GCM, A256GCM, A128CBC-HS256, etc. |Chiffre la payload avec la CEK (sym√©trique)
|===

=== üõ†Ô∏è Atelier pratique : g√©n√©rer & v√©rifier un JWS puis un JWE en *Bash*

.Pr√©requis (install en 1 min)
----
# Linux / macOS
brew install jq openssl            # ou apt install jq openssl
npm install -g jose-util           # outil CLI pour JWE (Node ‚â• 18)
----

[source,bash]
----
#!/usr/bin/env bash
set -euo pipefail

# 1) G√©n√©rer une paire RSA
openssl genrsa -out private.pem 2048
openssl rsa -in private.pem -pubout -out public.pem

# 2) Pr√©parer une payload JSON (claims)
cat > payload.json <<'JSON'
{
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true,
  "iat": 1709980000
}
JSON

# 3) ---------- JWS (RS256) ----------
HEADER='{"alg":"RS256","typ":"JWT","kid":"demo1"}'

# Helper pour base64url sans padding
b64url() { openssl base64 -e -A | tr '+/' '-_' | tr -d '='; }

header_b64=$(printf '%s' "$HEADER" | b64url)
payload_b64=$(jq -c . < payload.json | b64url)
unsigned="${header_b64}.${payload_b64}"

signature=$(printf '%s' "$unsigned" \
           | openssl dgst -sha256 -sign private.pem | b64url)

JWS="${unsigned}.${signature}"
echo -e "\nüîë JWS (RS256 sign√©) :\n${JWS}"

# 4) ---------- JWE (RSA-OAEP / AES-256-GCM) ----------
#   Chiffre TOUTE la payload ‚Äì r√©sultat = 5 segments
jose-util encrypt \
  --alg RSA-OAEP \
  --enc A256GCM \
  --key public.pem \
  --input payload.json > token.jwe

echo -e "\nüõ°Ô∏è  JWE (chiffr√©) :\n$(cat token.jwe)"

# 5) D√©chiffrer le JWE pour v√©rif
echo -e "\nüîé D√©chiffrement JWE ‚ûú payload :"
jose-util decrypt --key private.pem --input token.jwe
----

=== ‚öôÔ∏è Atelier Bash : focus ‚Äúpayload ‚Üí ciphertext‚Äù

*payload ‚Üí ciphertext*

[code, bash]
----
# (suite du script pr√©c√©dent, juste apr√®s g√©n√©ration de payload.json)

echo -e "\n--- STAGE: Payload en clair ---"
cat payload.json | jq

#  ‚ûú Chiffrement AES-256-GCM (offline) pour visualiser les √©l√©ments
CEK=$(openssl rand -hex 32)                      # 32 bytes = 256 bits
IV=$(openssl rand -hex 12)                       # 12 bytes = 96 bits (GCM)
AAD=$(printf '%s' '{"alg":"dir","enc":"A256GCM"}' | openssl base64 -A | tr '+/' '-_' | tr -d '=')

CIPHERTEXT_TAG=$( \
  openssl enc -aes-256-gcm -K "$CEK" -iv "$IV" \
    -in payload.json -out /dev/stdout -a -A \
    -p -aad "$AAD" )

echo -e "\n--- STAGE: Ciphertext + Tag (local demo) ---"
echo "$CIPHERTEXT_TAG"

----

.Lecture des r√©sultats
* **JWS** ‚Üí 3 segments : `HEADER.PAYLOAD.SIGNATURE`
*Lisible* via :
`echo "$JWS" | cut -d'.' -f1-2 | tr '.' '\n' | while read p; do echo "$p" | openssl base64 -d -A | jq; done`
* **JWE** ‚Üí 5 segments : `HEADER.ENCRYPTED_KEY.IV.CIPHERTEXT.TAG`
*Illisible* sans la cl√© priv√©e. La commande `jose-util decrypt ‚Ä¶` affiche la payload initiale.

== üîÅ Rotation des cl√©s (`kid`, JWKS)

[cols="1,3"]
|===
|`kid` |Identifie la cl√© de signature dans l‚Äôen-t√™te
|JWKS  |Endpoint JSON exposant les **cl√©s publiques**
|Rotation |Remplacement r√©gulier de la cl√© priv√©e + publication cl√© publique
|===

=== Exemple : JWT sign√©

[source,json]
----
{
  "alg": "RS256",
  "typ": "JWT",
  "kid": "abc123"
}
----

.JWKS
[source,json]
----
{
  "keys": [
    { "kid": "abc123", "kty": "RSA", "alg": "RS256", "n": "...", "e": "AQAB" },
    { "kid": "def456", "kty": "RSA", "alg": "RS256", "n": "...", "e": "AQAB" }
  ]
}
----

1. Le client lit `kid = abc123` dans le JWT.
2. Il r√©cup√®re (ou met √† jour) le **JWKS**.
3. Il extrait la cl√© publique `abc123`.
4. Il v√©rifie la signature.

* **Signature (JWS)** : int√©grit√© & authenticit√© ‚Äì la payload reste *en clair*.
* **Chiffrement (JWE)** : confidentialit√© ‚Äì personne ne lit la payload sans la cl√© priv√©e.
* **`kid` + JWKS** : ajoute facilement une nouvelle cl√© ‚Üí signe ‚Üí publie ‚Üí clients v√©rifient sans downtime.
