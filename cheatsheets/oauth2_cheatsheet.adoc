:author-url: https://github.com/rridane
:author: rridane
:source-highlighter: rouge
:hardbreaks:
:table-caption!:
:toc: left
:toclevels: 3
:numbered:

= OAuth 2.0 â€“ Cheatsheet

*grant types* = comment un client obtient un *access token* :

* *Authorization Code* â€“ Pour les applications cÃ´tÃ© serveur (clients confidentiels) type front php. SÃ©curisÃ©, recommandÃ© dans la majoritÃ© des cas.
* *Authorization Code + PKCE* â€“ Variante renforcÃ©e du flux prÃ©cÃ©dent pour les applications publiques (SPA, mobile), Ã©vitant lâ€™exposition du token. Pour toutes les applications type react, angular, vue, flutter... Toutes les applications dont le code est accessible pour un attaquant.
* *Client Credentials* â€“ Pour les communications machine-Ã -machine, sans intervention utilisateur.
* *Device Code* â€“ Pour les appareils sans navigateur (TV, IoT), oÃ¹ lâ€™utilisateur sâ€™authentifie sur un autre terminal.
* *Refresh Token* â€“ Pour obtenir de nouveaux tokens sans rÃ©-authentification de lâ€™utilisateur.
* *Implicit Flow* â€“ Ancien flux dÃ©sormais dÃ©conseillÃ©, car les tokens transitent dans lâ€™URL du navigateur. (Non abordÃ© ici)

== Flux Authorization Code

__FLUX MACHINE SECURISÃ‰ Ã€ MACHINE SECURISÃ‰__

[plantuml]
----
@startuml
actor "Utilisateur" as User
participant "Navigateur"
participant "Client (App Web)" as Client
participant "Authorization Server (AS)" as AS

== AccÃ¨s initial ==
User -> Navigateur : AccÃ¨s Ã  une ressource protÃ©gÃ©e (/photos)
Navigateur -> Client : GET /photos

Client -> Navigateur : Redirection 302 vers AS

note right of Navigateur
Redirection vers :
https://auth.example.com/authorize?
- response_type=code
- client_id=client123
- redirect_uri=https://client.com/callback
- scope=read:photos
- state=xyz123
end note

Navigateur -> AS : GET /authorize avec paramÃ¨tres

note right of AS
Lâ€™AS :
- Identifie le client via client_id
- VÃ©rifie redirect_uri
- Affiche une page de login
end note

AS -> Navigateur : Page HTML avec formulaire de login
@enduml
----

[plantuml]
----
@startuml
actor "Utilisateur" as User
participant "Navigateur"
participant "Client (App Web)" as Client
participant "Authorization Server (AS)" as AS

== Authentification ==
User -> Navigateur : Remplit login / mot de passe
Navigateur -> AS : POST /login avec credentials

AS -> AS : VÃ©rifie les identifiants

== Consentement ==
note right of AS
Affiche une page de consentement :
- Scopes demandÃ©s
- Nom du client
- Bouton "Autoriser"
end note

User -> Navigateur : Clique sur "Autoriser"
Navigateur -> AS : POST /consent

== GÃ©nÃ©ration du code ==
note right of AS
Lâ€™AS :
- GÃ©nÃ¨re un code unique (ex: abc123)
- Associe code + client_id + utilisateur + scopes
- Stocke en base temporairement
end note

AS -> Navigateur : Redirection 302 vers redirect_uri

note right of Navigateur
Redirection vers :
https://client.com/callback?
- code=abc123
- state=xyz123
end note

Navigateur -> Client : GET /callback?code=abc123&state=xyz123

== Ã‰change de code contre token ==
Client -> AS : POST /token

note right of Client
Body :
- grant_type=authorization_code
- code=abc123
- redirect_uri=https://client.com/callback
- client_id + client_secret (ou header Basic)
end note

AS -> AS : VÃ©rifie code, expiration, client_id

AS -> Client : access_token + refresh_token (JSON)
@enduml
----

[source,http]
----
POST /token HTTP/1.1
Host: auth.example.com
Content-Type: application/x-www-form-urlencoded
Authorization: Basic base64(client_id:client_secret)
grant_type=authorization_code&
code=abc123&
redirect_uri=https://client.com/callback
----

Ou, sans en-tÃªte Authorization :
[source,x-www-form-urlencoded]
----
POST /token HTTP/1.1
Host: auth.example.com
Content-Type: application/x-www-form-urlencoded
grant_type=authorization_code
&code=abc123
&redirect_uri=https://client.com/callback
&client_id=client123
&client_secret=secret456
----

== Flux Authorization Code + PKCE

PKCE (Proof Key for Code Exchange)

[plantuml]
----
@startuml
actor "Utilisateur" as User
participant "Navigateur (App SPA/Mobile)" as App
participant "Authorization Server (AS)" as AS

== GÃ©nÃ©ration cÃ´tÃ© client ==
note right of App
Avant toute redirection :
- GÃ©nÃ¨re un `code_verifier` (chaÃ®ne alÃ©atoire)
- Calcule `code_challenge = BASE64URL(SHA256(code_verifier))`
end note

User -> App : Demande une ressource protÃ©gÃ©e
App -> AS : Redirection vers /authorize

note right of App
GET /authorize?
- response_type=code
- client_id=public123
- redirect_uri=https://app.com/callback
- code_challenge=xyz987
- code_challenge_method=S256
- scope=read:photos openid
- state=abc999
end note

App -> AS : GET /authorize avec code_challenge
AS -> App : Affiche page login / mot de passe
@enduml
----

[plantuml]
----
@startuml
actor "Utilisateur" as User
participant "Navigateur (App SPA/Mobile)" as App
participant "Authorization Server (AS)"

== Authentification ==
User -> App : Saisie identifiants
App -> AS : POST /login (username, password)
AS -> AS : VÃ©rifie l'identitÃ©

== Consentement ==
note right of AS
Affiche consentement :
- Scopes demandÃ©s
- Client concernÃ©
- Bouton "Autoriser"
end note

User -> App : Autorise les accÃ¨s
App -> AS : POST /consent

== Redirection avec code ==
note right of AS
Lâ€™AS :
- GÃ©nÃ¨re un code unique (auth code)
- Lâ€™associe au client + code_challenge + scopes
end note

AS -> App : Redirection 302 vers redirect_uri?code=abc123&state=abc999
App -> App : Extrait le code d'autorisation

== Ã‰change avec code_verifier ==
App -> AS : POST /token

note right of App
POST :
- grant_type=authorization_code
- code=abc123
- redirect_uri=https://app.com/callback
- code_verifier = original string gÃ©nÃ©rÃ©e
- client_id = public123
(end note)

AS -> AS : VÃ©rifie code + calcule SHA256(code_verifier)

note right of AS
VÃ©rifie que :
SHA256(code_verifier) == code_challenge reÃ§u Ã  lâ€™Ã©tape /authorize
end note

AS -> App : Renvoie access_token (+ id_token, refresh_token si OIDC)
@enduml
----

== Flux Client Credentials

__FLUX MACHINE Ã€ MACHINE (SANS UTILISATEUR )__

[plantuml]
----
@startuml
participant "Client (Backend Service)" as Client
participant "Authorization Server (AS)" as AS
participant "Resource Server (API)" as API

== Authentification ==
Client -> AS : POST /token

note right of Client
Body :
grant_type=client_credentials
client_id=backend-app
client_secret=s3cr3t
scope=read:logs (optionnel)
end note

AS -> AS : VÃ©rifie client_id + client_secret
AS -> Client : access_token (JSON)

== Appel API ==
Client -> API : GET /resource
note right of Client
Authorization: Bearer <access_token>
end note

API -> Client : DonnÃ©es autorisÃ©es
@enduml
----

[source,http]
----
POST /token HTTP/1.1
Host: auth.example.com
Content-Type: application/x-www-form-urlencoded
Authorization: Basic base64(client_id:client_secret)
grant_type=client_credentials
&scope=read:logs

Ou sans en-tÃªte Authorization, dans le corps :
[source,x-www-form-urlencoded]
grant_type=client_credentials
&client_id=backend-app
&client_secret=s3cr3t
&scope=read:logs
----

== Flux Device Code

Appareils **dÃ©pourvus de navigateur** ou avec **interface utilisateur limitÃ©e** (TV, consoles, imprimantes, IoT).

[plantuml]
----
@startuml
actor "Utilisateur" as User
participant "Device (Appareil)" as Device
participant "Authorization Server (AS)" as AS
participant "Navigateur (sur autre appareil)" as Browser
participant "Resource Server (API)" as API

== 1. Demande de code ==
Device -> AS : POST /device_authorization
note right of Device
ParamÃ¨tres :
- client_id
- scope
end note

AS -> Device : device_code + user_code + verification_uri
note right of AS
RÃ©ponse :
- device_code
- user_code
- verification_uri
- verification_uri_complete
- expires_in
- interval
end note

== 2. L'utilisateur autorise ==
Device -> User : Affiche user_code + URL
User -> Browser : Va sur verification_uri
User -> AS : Sâ€™authentifie et saisit le user_code
AS -> User : Demande consentement
User -> AS : Autorise lâ€™accÃ¨s

== 3. Polling token ==
loop polling
Device -> AS : POST /token
note right of Device
ParamÃ¨tres :
- grant_type=device_code
- device_code
- client_id
end note

AS -> Device : pending / slow_down / access_token
end loop

== 4. AccÃ¨s API ==
Device -> API : Authorization: Bearer <access_token>
API -> Device : DonnÃ©es autorisÃ©es
@enduml
----

[source,http]
----
POST /device_authorization
Host: auth.example.com
Content-Type: application/x-www-form-urlencoded

client_id=client123&
scope=read:profile
----

RÃ©ponse :

[source,json]
----
{
  "device_code": "abc123xyz",
  "user_code": "XY12-ZZ45",
  "verification_uri": "https://auth.example.com/activate",
  "verification_uri_complete": "https://auth.example.com/activate?user_code=XY12-ZZ45",
  "expires_in": 1800,
  "interval": 5
}
----

Lâ€™appareil affiche :
----
Pour continuer, rendez-vous sur : https://auth.example.com/activate
Code : XY12-ZZ45
----

. Ouvre son navigateur sur un autre appareil
. Va sur la `verification_uri`
. Sâ€™authentifie (login/mot de passe)
. Saisit le `user_code`
. Accepte les scopes demandÃ©s

__Le device interroge rÃ©guliÃ¨rement le serveur__

[source,http]
----
POST /token
Host: auth.example.com
Content-Type: application/x-www-form-urlencoded

grant_type=urn:ietf:params:oauth:grant-type:device_code&
device_code=abc123xyz&
client_id=client123
----

RÃ©ponses possibles :

* `authorization_pending` â†’ lâ€™utilisateur nâ€™a pas encore validÃ©
* `slow_down` â†’ trop de requÃªtes
* `access_token` â†’ succÃ¨s

== Flux Refresh Token

Obtenir un nouveau `access_token` **sans interaction utilisateur**, une fois que le token dâ€™origine a expirÃ©.

.refresh_token avec client sÃ»r
[plantuml]
----
@startuml
actor "Utilisateur" as User
participant "Client (App)" as Client
participant "Authorization Server (AS)" as AS
participant "Resource Server (API)" as API

== 1. Flux initial ==
User -> Client : Authentification initiale (ex: code)
Client -> AS : POST /token
AS -> Client : access_token + refresh_token

== 2. Appel API ==
Client -> API : Authorization: Bearer access_token
API -> Client : DonnÃ©es

== 3. Le token expire ==
note right of Client
access_token expirÃ© (ex: 3600s)
end note

== 4. RafraÃ®chissement ==
Client -> AS : POST /token
note right of Client
ParamÃ¨tres :
- grant_type=refresh_token
- refresh_token
- client_id (+ client_secret si confidentiel)
end note

AS -> Client : Nouveau access_token (+ refresh_token si rotation)
@enduml
----

.client publique non sÃ»r (pkce)

[plantuml]
----
@startuml
actor "Utilisateur" as User
participant "Client (SPA â€“ public)" as Client
participant "Authorization Server (AS)" as AS
participant "Resource Server (API)" as API

== 1. Flux initial ==
User -> Client : Authentification initiale (avec PKCE)
Client -> AS : POST /token (code + code_verifier)
AS -> Client : access_token + refresh_token

== 2. Appel API ==
Client -> API : Authorization: Bearer access_token
API -> Client : DonnÃ©es

== 3. Le token expire ==
note right of Client
access_token expirÃ© (ex: 3600s)
end note

== 4. RafraÃ®chissement ==
Client -> AS : POST /token

note right of Client
ParamÃ¨tres :
- grant_type=refresh_token
- refresh_token
- client_id
(N.B. : PAS de client_secret)
end note

AS -> Client : Nouveau access_token (+ refresh_token si rotation)
@enduml
----

[source,http]
----
POST /token HTTP/1.1
Host: auth.example.com
Content-Type: application/x-www-form-urlencoded
Authorization: Basic base64(client_id:client_secret)

grant_type=refresh_token
&refresh_token=def456uvw
----

Ou dans le corps :

[source,x-www-form-urlencoded]
----
grant_type=refresh_token
&client_id=client123
&client_secret=s3cr3t # Si applicable
&refresh_token=def456uvw
----

== ğŸ” Gestion de lâ€™URL cible et du state

----
state=csrf123___/photos/1234
----

Le format permet dâ€™associer protection CSRF et redirection.

Une fois lâ€™utilisateur redirigÃ© vers le client avec `?code=abc123&state=csrf123___/photos/1234`, le client :

. vÃ©rifie la partie anti-CSRF (`csrf123`)
. rÃ©cupÃ¨re ou dÃ©code lâ€™URL dâ€™origine (`/photos/1234`)
. effectue la redirection finale vers la ressource cible

=== ğŸ” JAR â€“ JWT Authorization Request

*JAR* (JWT Authorization Request) : Envoyer une requÃªte `/authorize` encapsulÃ©e dans un JWT signÃ©

[source,http]
----
GET /authorize?request=eyJhbGciOiJSUzI1NiIsImtpZCI6ImtleS0xIn0... (JWT signÃ©)
----

Ce JWT contient tous les paramÃ¨tres OAuth habituels, comme :
- `client_id`
- `redirect_uri`
- `response_type`
- `scope`
- `state`
- `exp`, `aud`, `iss` (normes JWT)

.En-tÃªte (header)
[source,json]
----
{
  "alg": "RS256",
  "typ": "JWT",
  "kid": "client-key-1"
}
----

.Payload (claims)
[source,json]
----
{
  "response_type": "code",
  "client_id": "client123",
  "redirect_uri": "https://client.example.com/callback",
  "scope": "openid profile",
  "state": "abcXYZ123",
  "nonce": "n-0S6_WzA2Mj",
  "aud": "https://auth.example.com",
  "iss": "client123",
  "exp": 1710000000
}
----

SignÃ©e avec la clÃ© privÃ©e du client, rÃ©fÃ©rencÃ©e par `kid`.
Le client fournit une URL lors de son enregistrement (statique ou dynamique) :

[source,json]
----
{
  "client_id": "client123",
  "jwks_uri": "https://client.example.com/jwks.json"
}
----

Exemple de `jwks.json` publiÃ© par le client :

[source,json]
----
{
  "keys": [
    {
      "kty": "RSA",
      "kid": "client-key-1",
      "use": "sig",
      "alg": "RS256",
      "n": "MIIBIjANBgkqhk...",  // clÃ© publique modulaire (base64url)
      "e": "AQAB"
    }
  ]
}
----

Ou via `jwks` inline Ã  lâ€™enregistrement

[source,json]
----
{
  "client_id": "client123",
  "jwks": {
    "keys": [ ... ] // mÃªme format que ci-dessus
  }
}
----

=== ğŸ“¦ JARM â€“ JWT Secured Authorization Response Mode

JARM (*JWT Secured Authorization Response Mode*) permet Ã  lâ€™Authorization Server de **renvoyer la rÃ©ponse `/authorize` encapsulÃ©e dans un JWT signÃ©**, au lieu de transmettre les paramÃ¨tres (`code`, `state`, etc.) directement dans lâ€™URL.

==== ğŸ§­ Exemple de flux avec JARM

[source,http]
----
GET /authorize?response_mode=jwt
----

Au lieu dâ€™un retour classique :
[source,http]
----
302 Found
Location: https://client.com/callback?code=abc123&state=xyz456
----

Lâ€™AS renvoie :
[source,http]
----
302 Found
Location: https://client.com/callback?response=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...
----

.En-tÃªte
[source,json]
----
{
  "alg": "RS256",
  "kid": "as-key-1",
  "typ": "JWT"
}
----

.Payload
[source,json]
----
{
  "iss": "https://auth.example.com",
  "aud": "client123",
  "exp": 1710000000,
  "iat": 1709999400,
  "code": "abc123",
  "state": "xyz456",
  "redirect_uri": "https://client.com/callback"
}
----

.Signature
SignÃ©e par lâ€™Authorization Server avec sa clÃ© privÃ©e.

Le client doit :
. VÃ©rifier la signature avec la clÃ© publique de lâ€™AS (`jwks_uri` de lâ€™AS)
. VÃ©rifier les claims `iss`, `aud`, `exp`
. Extraire le `code` et le `state` du payload

Comme pour tous les JWT OIDC, lâ€™AS expose sa clÃ© via son fichier de configuration OIDC :

[source,http]
----
GET /.well-known/openid-configuration
----

Extrait typique :
[source,json]
----
{
  "issuer": "https://auth.example.com",
  "jwks_uri": "https://auth.example.com/.well-known/jwks.json"
}
----

Le client rÃ©cupÃ¨re les clÃ©s :
[source,json]
----
{
  "keys": [
    {
      "kty": "RSA",
      "kid": "as-key-1",
      "alg": "RS256",
      "use": "sig",
      "n": "...",
      "e": "AQAB"
    }
  ]
}
----

=== ğŸ” DPoP â€“ Demonstration of Proof-of-Possession

DPoP (*Demonstration of Proof-of-Possession*) : Extension OAuth 2.0 visant Ã  **protÃ©ger les access tokens contre le vol et le rejeu**.

==== Vulgarisation du fonctionnement

Dans chaque access_token on trouve une clÃ© publique, il s'agit tout simplement de celle fournie par le client, lors de la demande de token. Le client peut mettre la clÃ© publique de son choix. La seule condition est que si il utilise cet access_token il doit prouver qu'il dÃ©tient la clÃ© privÃ©e associÃ©e. Cela se fait via le champ DPoP, qui contient un jwt signÃ© par la clÃ© privÃ©e associÃ©e Ã  la clÃ© publique.

Autrement dit, l'utilisateur du token doit prouver qu'il dÃ©tient la clÃ© privÃ©e associÃ©e Ã  la clÃ© publique.

==== ğŸ§­ Vue dâ€™ensemble du fonctionnement

. Le client gÃ©nÃ¨re localement une **paire de clÃ©s** asymÃ©triques (ex: EC P-256)
. Lors de lâ€™appel `/token`, il envoie un JWT signÃ© dans lâ€™en-tÃªte HTTP `DPoP`, qui contient :
- la **clÃ© publique** dans le champ `jwk` de lâ€™en-tÃªte du JWT
- la mÃ©thode HTTP (`htm`)
- lâ€™URL cible (`htu`)
- un `jti` unique
- un timestamp `iat`
- et est **signÃ© avec la clÃ© privÃ©e correspondant Ã  la clÃ© publique fournie**
. Lâ€™Authorization Server :
- extrait la **clÃ© publique (`jwk`) de lâ€™en-tÃªte du JWT**
- vÃ©rifie que la signature est correcte avec cette clÃ©
- **lâ€™inclut dans lâ€™`access_token`** via le champ `cnf.jwk`

. Lors des appels aux APIs, le client :
  - signe chaque requÃªte avec un nouveau JWT DPoP
  - fournit le mÃªme `access_token`, prÃ©cÃ©dÃ© du mot-clÃ© `DPoP`
. Le serveur de ressources :
  - vÃ©rifie que le JWT est signÃ© avec la mÃªme clÃ© publique que celle liÃ©e au token
  - rejette les appels dont la clÃ© ne correspond pas ou dont le `jti` a dÃ©jÃ  Ã©tÃ© vu (anti-rejeu)

[source,http]
----
POST /token
Host: auth.example.com
Authorization: Basic base64(client_id:client_secret)
Content-Type: application/x-www-form-urlencoded
DPoP: eyJhbGciOiJFUzI1NiIsInR5cCI6ImRwb3Arand0Iiwian... (JWT signÃ©)

grant_type=authorization_code
&code=abc123
&redirect_uri=https://client.com/callback
----

Lâ€™en-tÃªte `DPoP` est un JWT signÃ© avec la **clÃ© privÃ©e** du client.


.Header :
[source,json]
----
{
  "typ": "dpop+jwt",
  "alg": "ES256",
  "jwk": {
    "kty": "EC",
    "crv": "P-256",
    "x": "f83OJ3D2xF4U2hK2Y7KiGH2V",
    "y": "x_FEzRu9bktM6uZ7RzvJ2HiV"
  }
}
----

.Payload :
[source,json]
----
{
  "htu": "https://auth.example.com/token",
  "htm": "POST",
  "iat": 1723212345,
  "jti": "550e8400-e29b-41d4-a716-446655440000"
}
----

.Signature :
- Faite avec la **clÃ© privÃ©e associÃ©e au `jwk` ci-dessus**
- Le `jti` est un ID **unique gÃ©nÃ©rÃ© par le client**, utilisÃ© pour lâ€™anti-rejeu
- Le `iat` est un timestamp Unix (en secondes)
- Le `htm` (HTTP Method) et `htu` (Target URI) lient la preuve Ã  la requÃªte

Lâ€™Authorization Server inclut la **clÃ© publique du client** dans le `access_token`, sous le champ `cnf.jwk`.

Exemple de payload JWT :

[source,json]
----
{
  "sub": "user123",
  "iss": "https://auth.example.com",
  "aud": "https://api.example.com",
  "scope": "read:profile",
  "exp": 1723216000,
  "cnf": {
    "jwk": {
      "kty": "EC",
      "crv": "P-256",
      "x": "f83OJ3D2xF4U2hK2Y7KiGH2V",
      "y": "x_FEzRu9bktM6uZ7RzvJ2HiV"
    }
  }
}
----

[source,http]
----
GET /me HTTP/1.1
Host: api.example.com
Authorization: DPoP eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
DPoP: eyJhbGciOiJFUzI1NiIsInR5cCI6ImRwb3Arand0Iiwian... (JWT signÃ©)
----

* Le champ `Authorization` contient le `access_token`, prÃ©cÃ©dÃ© du mot-clÃ© `DPoP` (et non `Bearer`)
* Le champ `DPoP` contient un **nouveau JWT signÃ©**, gÃ©nÃ©rÃ© pour cette requÃªte spÃ©cifique

.Header :
[source,json]
----
{
  "typ": "dpop+jwt",
  "alg": "ES256",
  "jwk": { ... mÃªme que prÃ©cÃ©demment ... }
}
----

.Payload :
[source,json]
----
{
  "htu": "https://api.example.com/me",
  "htm": "GET",
  "iat": 1723212450,
  "jti": "7ca3c4a1-b1f3-43a6-9f4f-f9ea38cfcd99"
}
----

Lâ€™API doit vÃ©rifier :

* que le JWT DPoP est bien formÃ© et non expirÃ©
* que le `jwk` dans le header correspond au `cnf.jwk` du token
* que la signature est valide (avec la clÃ© publique)
* que le `htm` et `htu` correspondent Ã  la requÃªte rÃ©elle
* que le `jti` nâ€™a jamais Ã©tÃ© vu (anti-rejeu)

=== ğŸ” MTLS â€“ Mutual TLS (certificat client + access_token liÃ©)

OAuth 2.0 **dÃ©tourne mTLS** pour deux usages bien prÃ©cis :

1. ğŸ” **Authentification du client OAuth**
- Le client **prÃ©sente son certificat** lors du handshake TLS vers `/token`
- Le serveur OAuth (AS) utilise ce certificat pour **identifier et authentifier le `client_id`**

- Deux modes sont possibles :

a. `tls_client_auth` : certificat signÃ© par une CA connue, c'est le full handshake qui valide le certificat
b. `self_signed_tls_client_auth` : certificat auto-signÃ©, mais dont la **clÃ© publique est prÃ©-enregistrÃ©e**, c'est l'Ã©tape /token qui valide le certificat en comparant la clÃ© publique fournie avec celles enregistrÃ©es

2. ğŸ”— **Liaison de lâ€™`access_token` Ã  ce certificat**
- Lâ€™AS extrait lâ€™empreinte SHA-256 du certificat prÃ©sentÃ©
- Il lâ€™intÃ¨gre dans le `access_token` (JWT) dans le champ `cnf.x5t#S256`
- Ainsi, **le token ne pourra Ãªtre utilisÃ© que via mTLS avec ce mÃªme certificat**

.tls_client_auth
[plantuml]
----
@startuml
actor "Client OAuth" as Client
participant "Auth Server" as AS
participant "TLS Layer" as TLS

== Connexion TLS mutualisÃ©e ==

Client -> TLS : ClientHello (propose mTLS)
TLS -> Client : CertificateRequest
Client -> TLS : Certificat X.509 signÃ© (par CA)
note right of Client
Le client signe un challenge TLS
avec sa clÃ© privÃ©e
end note
note right of TLS
VÃ©rifie :
* ValiditÃ© du CA
* Possession de la clÃ© privÃ©e via challenge
end note
TLS -> AS : TLS OK, connexion Ã©tablie

== Appel /token ==

Client -> AS : POST /token\n(client_id, grant_type, scope)
note right of AS
Compare le certificat reÃ§u avec
celui attendu pour client_id
end note
AS -> AS : Calcule x5t#S256 du certificat
AS -> Client : access_token JWT\n(avec cnf.x5t#S256)
@enduml
----

.self_signed_tls_client_auth
[plantuml]
----
@startuml
actor "Client OAuth" as Client
participant "Auth Server" as AS
participant "TLS Layer" as TLS

== Connexion TLS mutualisÃ©e ==

Client -> TLS : ClientHello (propose mTLS)
TLS -> Client : CertificateRequest
Client -> TLS : Certificat X.509 auto-signÃ©
note right of Client
Le client signe un challenge TLS
avec sa clÃ© privÃ©e
end note
note right of TLS
VÃ©rifie :
* Possession de la clÃ© privÃ©e via challenge
âš ï¸ Pas de vÃ©rification de lâ€™Ã©metteur (auto-signÃ©)
end note
TLS -> AS : TLS OK, connexion Ã©tablie

== Appel /token ==

Client -> AS : POST /token\n(client_id, grant_type, scope)
note right of AS
Compare la **clÃ© publique** du certificat TLS
avec celle enregistrÃ©e pour ce `client_id`
end note
AS -> AS : Calcule x5t#S256 du certificat
AS -> Client : access_token JWT\n(avec cnf.x5t#S256)
@enduml
----

.RÃ©cupÃ©ration du token (identique au deux flux)
[plantuml]
----
@startuml
actor "Client OAuth" as Client
participant "API Server" as API
participant "TLS Layer" as TLS

== Connexion mTLS ==

Client -> TLS : ClientHello (mTLS)
TLS -> Client : CertificateRequest
Client -> TLS : Certificat X.509 (mÃªme que /token)
note right of Client
Le client signe un challenge TLS
avec sa clÃ© privÃ©e
end note
note right of TLS
VÃ©rifie :
* ValiditÃ© du CA
* Possession de la clÃ© privÃ©e via challenge
end note
TLS -> API : TLS OK, session Ã©tablie

== Appel API ==

Client -> API : GET /data\nAuthorization: Bearer eyJ...
API -> API : Extrait le certificat de TLS
API -> API : Calcule x5t#S256
API -> API : Compare avec cnf.x5t du token

alt Correspondance OK
  API -> Client : âœ… Donne la ressource
else Mauvaise clÃ© ou token volÃ©
  API -> Client : âŒ 401 Unauthorized
end
@enduml
----

[source,http]
----
POST /token
Host: auth.example.com
Content-Type: application/x-www-form-urlencoded

grant_type=client_credentials
&client_id=backend-app
&scope=read:data
----

[source,json]
----
{
  "sub": "backend-app",
  "aud": "https://api.example.com",
  "exp": 1723216000,
  "scope": "read:data",
  "cnf": {
    "x5t#S256": "FhS7ey5eTxN0GqR5twF7K1v0Vya8lJcvZP9ZT2aPjSo"
  }
}
----

`cnf.x5t#S256` :
- empreinte SHA-256 du certificat **prÃ©sentÃ© Ã  `/token`**
- encodÃ©e en base64url (format conforme Ã  JWK Thumbprint)
- calculÃ© comme ceci en accord avec la RFC 7638: thumbprint = base64url(SHA-256(canonicalized certificate))

> Utilisable **quâ€™avec ce mÃªme certificat** dans les appels aux APIs.

[source,http]
----
GET /me HTTP/1.1
Host: api.example.com
Authorization: Bearer eyJhbGciOiJSUzI1NiIs...
----

âœ”ï¸ La requÃªte est faite **en HTTPS avec mTLS**
âœ”ï¸ Le **mÃªme certificat client** est prÃ©sentÃ© que lors de `/token`
âœ”ï¸ Le serveur API :
- extrait ce certificat de la session TLS
- calcule son empreinte SHA-256
- la compare Ã  `cnf.x5t#S256` dans le JWT

âœ… RequÃªte acceptÃ©e **uniquement si lâ€™empreinte correspond**

=== ğŸ” FAPI â€“ Financial-grade API (OAuth 2.0 durci)

FAPI est une *spÃ©cification de lâ€™OpenID Foundation* visant Ã  sÃ©curiser les APIs sensibles (finance, santÃ©, identitÃ©â€¦).

Elle repose entiÃ¨rement sur OAuth 2.0, mais impose une *combinaison stricte de mÃ©canismes existants* pour renforcer lâ€™authentification, lâ€™intÃ©gritÃ©, la confidentialitÃ© et la non-rÃ©pudiation.

.Exigences de FAPI
[cols="1,4a",options="header"]
|===
|Ã‰lÃ©ment |RÃ´le

|*PKCE* (RFC 7636)
|EmpÃªche le vol du code d'autorisation

|*JAR* â€“ JWT Authorization Request
|Signature de la requÃªte `/authorize` (intÃ©gritÃ© + non-rÃ©pudiation)

|*JARM* â€“ JWT Authorization Response
|Signature de la rÃ©ponse Ã  `/authorize` (intÃ©gritÃ© + vÃ©rifiabilitÃ©)

|*mTLS* ou *DPoP*
|Preuve de possession du client + liaison des tokens (`cnf`)

|*Access Token liÃ© au certificat ou JWK*
|Via `cnf.x5t#S256` (mTLS) ou `cnf.jwk` (DPoP)

|*HTTP Message Signing*
|Protection des appels API contre la falsification

|*Scopes strictement limitÃ©s*
|Principe du moindre privilÃ¨ge renforcÃ©

|*Rotation obligatoire des refresh_token*
|RÃ©duction de l'impact en cas de vol

|*Pas de token rÃ©utilisable hors preuve*
|Les tokens liÃ©s Ã  un certificat ou une clÃ© privÃ©e ne peuvent pas Ãªtre rÃ©utilisÃ©s ailleurs
|===

[NOTE]
====
FAPI *nâ€™est pas un nouveau protocole*, mais un *profil de sÃ©curitÃ© OAuth 2.0 renforcÃ©*, souvent requis en Open Banking (Royaume-Uni, UEâ€¦).
====

ğŸ“– https://openid.net/fapi/[SpÃ©cification officielle]
