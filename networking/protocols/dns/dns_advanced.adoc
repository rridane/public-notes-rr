:author-url: https://github.com/rridane
:source-highlighter: rouge
:hardbreaks:
:table-caption!:
:toc: left

= DNS Advanced

== Emails et enregistrements txt

=== Spf

==== Introduction & définition

.enregistrement txt
[source, python]
----
@    IN    TXT "v=spf1 include:_spf.shop.example.com ~all"
----

v=spf1 : Indique la version de SPF, qui est SPF1 dans ce cas.
include:_spf.shop.example.com : Inclut les règles SPF définies pour le domaine _spf.shop.example.com. Cela signifie que les serveurs de messagerie autorisés pour shop.example.com peuvent aussi inclure ceux spécifiés dans le domaine _spf.shop.example.com.
~all : Spécifie une politique "SoftFail" pour les serveurs de messagerie qui ne correspondent pas à aucun des critères spécifiés dans l'enregistrement. "SoftFail" signifie que la réception du message est toujours autorisée, mais le message peut être traité avec suspicion (par exemple, marqué comme potentiellement du spam).

SPF est utilisé pour vérifier si l'expéditeur d'un email est autorisé à envoyer des emails au nom du domaine affiché dans "l'adresse de". Cela se fait en comparant l'ip de l'expéditeur avec une liste d'adresses IP autorisées publiées dans un l'enregistrement DNS SPF du domaine expéditeur. Sans spf, n'importe qui pourrait envoyer un mail : from: contact@example.com.

==== Mécanismes SPF courants

[cols="1,3", options="header"]
|===
| Mécanisme | Description

| `ip4:x.x.x.x` / `ip6:...` | Autorise une adresse IP ou un bloc CIDR
| `include:domain.com` | Intègre les règles SPF d’un autre domaine
| `a` | Autorise l’IP de l’enregistrement A du domaine
| `mx` | Autorise l’IP des enregistrements MX du domaine
| `exists:domain.com` | Autorise si la résolution DNS aboutit pour le domaine donné
| `all` | S’applique à toutes les IP restantes (utilisé en fin de règle)
|===

==== Modificateurs de résultat

Chaque mécanisme peut être précédé d’un modificateur pour indiquer son **niveau de confiance** :

[cols="1,2,2", options="header"]
|===
| Modificateur | Signification | Résultat attendu

| `+` (ou rien) | Autorisé explicitement | `Pass`
| `~` | Autorisé avec doute | `SoftFail` (souvent marqué comme spam)
| `-` | Refus explicite | `Fail` (le message peut être rejeté)
| `?` | Neutre | `Neutral` (aucune indication, le serveur décide)
|===

==== SPF macro : exemple décrypté

[source,dns]
----
@ IN TXT "v=spf1 ip4:192.0.2.5 ip4:198.51.100.25 include:_spf.google.com include:mailgun.org a mx ~all"
----

==== Décomposition de cet enregistrement

[cols="1,4a", options="header"]
|===
| Élément | Signification

| `v=spf1`
| Indique la version de SPF. Toujours `v=spf1` (actuellement la seule version standardisée).

| `ip4:192.0.2.5`
| Autorise cette IP à envoyer des e-mails pour ce domaine. Par exemple : le serveur d’envoi maison ou hébergé.

| `ip4:198.51.100.25`
| Autre IP autorisée. Cela peut être un serveur SMTP secondaire, un outil d’automatisation, etc.

| `include:_spf.google.com`
| Intègre les règles SPF définies par Google (Gmail, Google Workspace).
→ Indispensable si on utilise Gmail pour envoyer des e-mails via ce domaine. Concrètement, ira chercher les ips autorisées par google dans l'enregistrement txt _spf.google.com, voici ce qui sera fait :
[source, bash]
----
❭ dig @1.1.1.1 _spf.google.com A +noall +answer TXT
;; Warning, extra type option
_spf.google.com.        230     IN      TXT     "v=spf1 include:_netblocks.google.com include:_netblocks2.google.com include:_netblocks3.google.com ~all"
~
❭ dig @1.1.1.1 _netblocks.google.com A +noall +answer TXT
;; Warning, extra type option
_netblocks.google.com.  29      IN      TXT     "v=spf1 ip4:66.102.0.0/21 ip4:66.249.80.0/20 ip4:72.14.192.0/18 ip4:74.125.0.0/16 ip4:108.177.8.0/21 ip4:173.194.0.0/16 ip4:209.85.128.0/17 ip4:216.58.192.0/19 ip4:216.239.32.0/19 ~all"

----

| `include:mailgun.org`
| Autorise Mailgun à envoyer des e-mails pour ce domaine.
→ Les serveurs SMTP utilisés par Mailgun seront validés par cet include.

| `a`
| Autorise l’adresse IP liée à l’enregistrement A du domaine (`example.com A x.x.x.x`) à envoyer des e-mails.

| `mx`
| Autorise les IP des serveurs de messagerie déclarés en MX à émettre des mails (utile pour des serveurs tout-en-un).

| `~all`
| SoftFail : toutes les autres IP **non listées** dans les mécanismes précédents seront **acceptées mais marquées comme suspectes** (ex : en spam).
→ C’est un mode souple de filtrage : pas de rejet brutal mais classification prudente.
|===

==== Exemple détaillé : SPF vu côté serveur de réception

Supposons que :

* L’expéditeur envoie un mail depuis `contact@example.com`
* Le mail arrive chez `contact@example2.com`, hébergé sur un serveur SMTP géré par `example2.com`
* L’IP de l’expéditeur est `209.85.220.41` (l'une des IP SMTP de Google)

==== 🔹 Enregistrement SPF du domaine `example.com`

[source,dns]
----
example.com. IN TXT "v=spf1 ip4:192.0.2.5 ip4:198.51.100.25 include:_spf.google.com include:mailgun.org a mx ~all"
----

==== 🔍 Étapes côté serveur de réception

1. 🧾 **Extraction du domaine expéditeur**

Le serveur destinataire lit l’adresse `MAIL FROM: <contact@example.com>`.
→ Domaine = `example.com`

2. 📡 **Requête DNS pour l’enregistrement SPF**

Il interroge le DNS :

[source,bash]
----
dig TXT example.com
----

3. 🧠 **Évaluation de chaque mécanisme, dans l’ordre**

Le serveur compare l’**IP de l’expéditeur** (`209.85.220.41`) avec chaque mécanisme SPF :

[cols="1,3", options="header"]
|===
| Mécanisme | Vérification
| `ip4:192.0.2.5` | ❌ Non correspondante
| `ip4:198.51.100.25` | ❌ Non correspondante
| `include:_spf.google.com` | ✔️ Vérification nécessaire
|===

4. 🔄 **Résolution récursive du `include:`**

Le serveur interroge ensuite :

[source,bash]
----
dig TXT _spf.google.com
----

.Exemple de réponse typique :
[source,dns]
----
_spf.google.com. IN TXT "v=spf1 ip4:209.85.128.0/17 include:_netblocks.google.com include:_netblocks2.google.com include:_netblocks3.google.com ~all"
----

Le serveur suit tous les `include:` imbriqués, et compare l’IP `209.85.220.41`.

✅ Elle est dans la plage `209.85.128.0/17` → **SPF = PASS**

5. 📨 **Livraison du mail**

Au moins un mécanisme a validé l’IP : le résultat SPF est `Pass`.
→ Le mail est accepté (ou marqué comme légitime par le filtre anti-spam).

==== 🔁 Variante : envoi via Mailgun

Si le mail vient de l’IP `159.135.224.50` (serveur Mailgun) :

1. Le serveur suit `include:mailgun.org`
2. Il interroge :

[source,bash]
----
dig TXT mailgun.org
----

.Réponse possible :
[source,dns]
----
mailgun.org. IN TXT "v=spf1 ip4:159.135.224.0/24 ip4:69.72.32.0/20 ~all"
----

✅ L’IP `159.135.224.50` est dans la plage autorisée → **SPF = PASS**

==== 📌 À retenir sur `include:`

`include:domain.tld` signifie :
→ *« Va chercher l’enregistrement SPF de ce domaine, et applique ses règles ici »*

[NOTE]
====
* Le serveur de réception suit récursivement les `include:` (maximum 10 niveaux, selon RFC)
* Si une IP est autorisée dans un `include`, le résultat SPF est `Pass`
* Ce n’est **pas** une redirection SMTP, mais une inclusion logique des règles
====

==== 🔥 Et si aucune règle ne correspond ?

[cols="1,3", options="header"]
|===
| Résultat final | Interprétation
| `~all` | Le mail passe, mais est marqué comme suspect
| `-all` | Le mail est rejeté (ou marqué comme non conforme selon la politique du serveur)
| `?all` | Neutre, aucune recommandation
| (aucun SPF) | Résultat = `None`, confiance faible
|===

==== 🛠️ Outils de vérification recommandés

* https://www.kitterman.com/spf/validate.html
* https://mxtoolbox.com/spf.aspx
* https://toolbox.googleapps.com/apps/checkmx/

=== DKIM (DomainKeys Identified Mail)

DKIM permet à un domaine d’associer son nom à un e-mail via une **signature numérique**, ajoutée dans l’en-tête du message.
Le serveur de réception utilise la **clé publique**, publiée dans un enregistrement DNS TXT du domaine expéditeur, pour vérifier cette signature.

Cela garantit que :

* Le message provient bien du domaine déclaré (`From:`).
* Le message **n’a pas été modifié** depuis son envoi.

==== 🔐 Publication de la clé publique

La clé publique est publiée dans un enregistrement DNS de type TXT, avec un **nom construit comme suit** :

----
<sélecteur>._domainkey.<domaine>
----

.Enregistrement DNS DKIM (exemple)
[source,dns]
----
default._domainkey.example.com. IN TXT "v=DKIM1; k=rsa; p=MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC4nE2U0pGJAx9lmQ82eVzI..."
----

[cols="1,4a", options="header"]
|===
| Élément | Description

| `default._domainkey.example.com.` | Nom de l’enregistrement.
* `default` est le **sélecteur DKIM**, choisi librement par l’expéditeur.
* Le sélecteur permet d’avoir **plusieurs clés** actives en parallèle (rotation, testing…).

| `IN TXT` | Type d’enregistrement DNS (texte)

| `v=DKIM1` | Version du protocole DKIM

| `k=rsa` | Algorithme de chiffrement utilisé (RSA dans l’écrasante majorité des cas)

| `p=...` | Clé publique en base64
|===

==== ✉️ Où est stockée la signature ?

La signature DKIM est **insérée directement dans l’en-tête du mail**, sous forme d’un champ :

[source]
----
DKIM-Signature: v=1; a=rsa-sha256; d=example.com; s=default;
 h=from:to:subject;
 bh=Z0K2...==;
 b=K8x8bRfw0NFJeT0pHQFb...==
----

[cols="1,4a", options="header"]
|===
| Champ | Explication

| `v=1` | Version de DKIM
| `a=rsa-sha256` | Algorithme utilisé pour la signature
| `d=example.com` | Domaine signataire
| `s=default` | Sélecteur DKIM utilisé
| `h=...` | Liste des en-têtes inclus dans la signature
| `bh=...` | Hachage du corps du message
| `b=...` | Signature numérique (cryptée avec la clé privée)
|===

==== 🔄 Vérification côté serveur de réception

1. Le serveur lit l’en-tête `DKIM-Signature:`.
2. Il extrait :
* Le **sélecteur** (`s=default`)
* Le **domaine signé** (`d=example.com`)
3. Il construit une requête DNS :

[source,bash]
----
dig TXT default._domainkey.example.com
----

4. Il récupère la **clé publique** et **vérifie la signature** avec celle-ci.
5. Si la signature correspond aux en-têtes et au contenu :
→ ✅ DKIM = `pass`
→ Sinon : ❌ `fail`

==== 🔁 Illustration du processus

[plantuml, dkim-verification, png]
----
title "Vérification DKIM côté serveur de réception"
actor "Serveur destinataire" as S
database "DNS du domaine expéditeur" as DNS

S -> S: Lit l’en-tête DKIM-Signature
S -> DNS: Requête TXT\n"default._domainkey.example.com"
DNS --> S: Renvoie la clé publique
S -> S: Vérifie la signature avec la clé
S -> S: Marque DKIM = Pass / Fail
----

==== 📌 Remarques importantes

* Le sélecteur `s=` permet à un domaine d’avoir plusieurs clés (ex: `default`, `selector1`, etc.)
* La signature est **générée par le serveur d’envoi**, avec sa **clé privée**
* La vérification repose sur la **clé publique publiée dans le DNS**
* Contrairement à SPF, **DKIM survit au forwarding** (transferts, listes de diffusion), car la signature reste valable tant que le contenu n’est pas modifié
* DKIM est une **brique essentielle de DMARC**

==== 🧪 Tester un enregistrement DKIM

[source,bash]
----
dig TXT default._domainkey.example.com
----

==== 📚 Pour aller plus loin

* RFC 6376 (DKIM)
* https://dkimcore.org/tools/
* https://mxtoolbox.com/dkim.aspx

==== 🧠 Faut-il SPF si DKIM est en place ?

===== 🔍 Que garantit DKIM seul ?

[cols="1,4a", options="header"]
|===
| ✅ | Le message a bien été signé avec la clé privée du domaine (`d=...`)
| ✅ | Le contenu (en-têtes + corps) n’a pas été modifié en chemin
| ✅ | Le domaine peut prouver sa légitimité via une clé publique publiée en DNS
| ❌ | Mais DKIM **ne dit rien sur l’adresse IP** de l’expéditeur
| ❌ | Et ne garantit pas que le domaine `From:` est bien celui du signataire si non aligné
|===

===== 🛠️ Exemple de scénario problématique

Un prestataire comme SendGrid signe tous les e-mails avec :

[source,text]
----
DKIM-Signature: d=sendgrid.net; ...
From: contact@example.com
----

→ Résultat : DKIM = Pass, mais le domaine signé (`sendgrid.net`) **n’est pas aligné avec le domaine visible** (`example.com`).
→ Sans SPF ni DMARC strict, ce message **peut sembler légitime** alors qu’il est falsifiable.

===== ✅ Recommandation

[NOTE]
====
🌟 La meilleure pratique actuelle est d’utiliser :

* **SPF** : contrôle d’autorisation IP
* **DKIM** : preuve cryptographique du contenu
* **DMARC** : politique claire pour exiger un alignement

→ Ces trois briques ensemble permettent une **authentification forte**, une **traçabilité** claire, et une **protection contre le spoofing**.
====

=== DMARC (Domain-Based Message Authentication, Reporting, and Conformance)

dmarc est une norme de sécurité email qui aide à protéger les domaines email contre le spoofing, le phishig et d'autres types d'abus.

.dmarc
[source, bash]
----
Ridane@htb[/htb]$ nslookup -type=txt _dmarc.inlanefreight.com

Non-authoritative answer:
_dmarc.inlanefreight.com	text = "v=DMARC1; p=reject; rua=mailto:master@inlanefreight.com; ruf=mailto:master@inlanefreight.com; fo=1;"
----

v=DMARC1 : Indique la version de DMARC utilisée. "DMARC1" est actuellement la seule version en usage.

p=reject : Spécifie la politique DMARC appliquée aux emails qui échouent aux vérifications DMARC. Dans ce cas, "reject" signifie que les emails qui ne passent pas la vérification seront rejetés par les serveurs de messagerie recevant l'email. C'est la politique la plus stricte, indiquant que le domaine prend au sérieux la sécurité de son courrier électronique.

rua=mailto:master@inlanefreight.com : Définit l'adresse à laquelle les rapports d'agrégation DMARC doivent être envoyés. Ces rapports fournissent un résumé des messages passant ou échouant les vérifications DMARC et sont destinés à aider les administrateurs de domaines à surveiller l'utilisation de leur domaine dans les emails.

ruf=mailto:master@inlanefreight.com : Indique l'adresse pour les rapports de forensic DMARC. Contrairement aux rapports d'agrégation, ces rapports sont envoyés en temps réel et contiennent des détails sur les échecs individuels DMARC, offrant ainsi des informations plus précises sur des tentatives d'abus spécifiques.

fo=1 : Spécifie les conditions sous lesquelles les rapports de forensic doivent être générés. "1" signifie que les rapports sont générés pour chaque email qui échoue à la vérification DMARC. Cela garantit que l'administrateur reçoit des informations détaillées sur les échecs, ce qui est utile pour diagnostiquer et résoudre les problèmes de sécurité email.

[NOTE]
====
La **fonction principale** de l'enregistrement DMARC est de définir une **politique explicite** (`p=none`, `quarantine`, `reject`) à appliquer si les vérifications SPF et DKIM échouent.

Il exige également un **alignement** entre le domaine du champ `From:` et celui utilisé par SPF ou DKIM.

Le reporting (`rua`, `ruf`) est optionnel mais recommandé pour surveiller l’usage de son domaine.
====

== 🔐 DNSSEC

DNSSEC (Domain Name System Security Extensions) sécurise le DNS en garantissant **l'authenticité** et **l'intégrité** des données via une chaîne de signatures cryptographiques hiérarchique.

En synthèse, chaque zone contient deux clés, KSK (Key Signing Key) et ZSK (Zone Signing Key). La KSK signe le couple KSK+ZSK (appelé RRSet DNSKEY) pour chaque niveau créant l'enregistrement RRSig DNSKEY. On vérifie la KSK grâce au niveau précédent qui contient son hash (Enregistrement DS). La chaine de hash de KSK se poursuit jusqu'au niveau racine ou le hash de la KSK racine (DS racine) est stocké en locale, empêchant de falsifier la chaine complète. Ainsi, chaque niveau est en capacité de valider sa KSK et sa ZSK. La ZSK est ensuite utilisée pour signer les RSSet, pour créer des enregistrements RRSig associés (ex : RRSig A)

=== Concepts Fondamentaux

[cols="1,3", options="header"]
|===
| Terme
| Définition Technique

| RRset (Resource Record Set)
| Ensemble d'enregistrements DNS partageant le même _name_, _type_ et _class_

| RRSIG (Resource Record Signature)
| Signature numérique d'un RRset spécifique

| DNSKEY
| Clé publique de la zone (contient deux sous-types : KSK et ZSK)

| KSK (Key Signing Key)
| Clé de signature des clés (signe les DNSKEY et NSEC/NSEC3)

| ZSK (Zone Signing Key)
| Clé de signature des données (signe les autres RRsets)

| DS (Delegation Signer)
| Empreinte cryptographique (hash) d'une DNSKEY KSK enfant
|===


----
## HASH de la KSK zone racine détenue en local

# Zone racine

KSK (vérifiable en local par son hash)
ZSK
RSSIG DNSKEY (KSK+ZSK) signée par KSK

RSSET A
RSSIG A signé par ZSK

DS com. (hash KSK zone com)

# Zone com.

KSK (vérifiable par zone racine)
ZSK
RSSIG DNSKEY (KSK+ZSK) signée par KSK

RSSET A
RSSIG A signé par ZSK

DS cloudflare.com. (hash KSK zone cloudflare.com.)

# Zone cloudflare.com.

KSK (vérifiable par zone com.)
ZSK
RSSIG DNSKEY (KSK+ZSK) signée par KSK

RSSET A
RSSIG A signé par ZSK
----

Autrement dit :

* On vérifie la KSK grâce au niveau précédent (simple hash), et cette chaine se poursuit jusqu'à la détention en local de la KSK de la zone racine, ce qui empêche de falsifier la totalité de la chaine.
* La KSK permets de vérifier le RSSIG DNSKEY (hash encrypté de ZSK + KSK à l'aide de la KSK)
* Ce qui permets d'authentifier la ZSK en plus, en décryptant et en comparant les hash
* Ce qui permets de vérifier la RSSIG A

== Sécurité des emails ++

Lorsque quelqu'un tente d'envoyer un mail, le serveur de réception consulte l'enregistrement txt du domaine. Il consulte plus précisément les informations d'authentification DKIM que le serveur a inclut, signant l'email avec une clé privée spécifique. Le serveur de réception consulte l'enregistrement dns du serveur d'expédition pour récupérer la clé publique et ainsi vérifier que le message n'a pas été altéré.
Le serveur de réception consulte également la liste d'IP autorisés à envoyer un email via l'enregistrement DNS SPF de l'expéditeur. Il utilise ces deux résultats pour appliquer la politique déclarée dans l'enregistrement DMARC

En synthèse:

* SPF:  vérifie si l'IP de l'expéditeur est autorisée par le domaine de l'expéditeur.
* DKIM :  vérifie la validité du contenu de l'email, en comparant les hash obtenue à l'aide de l'en-tête de l'email.
* DMARC :  utilise les résultats de SPF et DKIM pour appliquer la politique définie dans son enregistrement (_dmarc.domain.com). Si l'email échoue à SPF ou DKIM et que la politique DMARC spécifie p=reject, l'email est rejeté.
* RSSIG & DNSKEY: Permette de vérifier l'authenticité d'un enregistrement DNS

== Réplication des données

Lorsque l'authoritative serveur (donc le SOA) modifie un enregistrement de type A, il s'opère une copie vers les serveurs secondaires, c'est un mécanisme interne au dns via des requêtes axfr (Asynchronous Full Transfer of Zone) ou IXFR (Incremental Transfer of Zone). Le processus induit un système de notification (DNS notify) vers les serveurs secondaires. L'objectif de ces notifications est d'inciter les serveurs secondaires à initier un transfert de zone (axfr ou ixfr).

AXFR est utilisé pour copier la totalité de la zone, c'est souvent utilisé à la première synchronisation.

IXFR permets un mise à jour uniquement des derniers changements.

En règle générale, on spécifie les ips des serveurs qui ont le droit de faire un transfert de zone, de manière explicite dans la configuration du serveur dns.

Pour autoriser un nouveau serveur DNS à recevoir un transfert de zone, l'administrateur du serveur doit explicitement ajouter l'ip du serveur, et utilisé ajouter des clés TSIG pour l'authentification.

== Sécurité

=== TSIG

TSIG = Transaction Signature. C'est un protocole qui permets l'authentification des messages de transfert DNS à l'aide de clés secrètes partagées. Il est définit dans la RFC 2845. Il sécurise principalement les transfert de zones entre serveurs dns. Il peut également ajouter une couche d'authentification dans les communications entre resolver et serveur dns dans le cadres des requêtes dns au sens plus large.

==== Exemple de configuration TSIG

===== Pré-requis

* Paquet `bind9` (ou `named`) installé sur chaque serveur ;
* Horloge système synchronisée (NTP / chrony) — TSIG rejette les messages trop décalés ;
* Droits *root* ou *sudo* pour manipuler les fichiers de configuration et (re)démarrer `named`.

===== Étape 1 : Générer la clé TSIG

Créez la clé depuis **n’importe** lequel des deux serveurs (elle sera copiée
sur l’autre par la suite). Le nom de la clé n’a pas d’impact sur la zone : on
choisit `example-tsig` pour la lisibilité :

[source,bash]
----
cd /etc/bind/keys
sudo dnssec-keygen -a HMAC-SHA256 -b 256 -n HOST example-tsig
----

Cette commande produit deux fichiers :

* `Kexample-tsig.+165+<id>.key` : version « publique » (elle contient la chaîne
que nous allons copier / coller) ;
* `Kexample-tsig.+165+<id>.private` : version privée (non utilisée par BIND
pour TSIG, mais à conserver en lieu sûr).

Ouvrez le fichier `.key` ; il ressemble à ceci :

[source]
----
example-tsig. IN KEY 512 3 165 YmFzZTY0RW5jb2RlZEtleQ==
----

La partie après *165* (`YmFzZTY0RW5jb2RlZEtleQ==`) est la clé Base64.

===== Étape 2 : Déclarer la clé dans *named.conf*

====== Sur le **master** (`ns1`)

Ajoutez (ou créez) le bloc `key` dans `/etc/bind/named.conf.tsig`, puis
mettez-le dans `named.conf` :

[source,bind]
----
key "example-tsig" {
    algorithm hmac-sha256;
    secret "YmFzZTY0RW5jb2RlZEtleQ==";
};
----

Inclure le fichier (s’il ne l’est pas déjà) :

[source,bind]
----
include "/etc/bind/named.conf.tsig";
----

====== Sur le **slave** (`ns2`)

Répétez exactement le même bloc `key` (la chaîne *secret* doit être
**identique**) :

[source,bind]
----
key "example-tsig" {
    algorithm hmac-sha256;
    secret "YmFzZTY0RW5jb2RlZEtleQ==";
};
include "/etc/bind/named.conf.tsig";
----

===== Étape 3 : Configurer la zone sur le **master**

Ajoutez ou modifiez la définition de zone dans `/etc/bind/named.conf.local` :

[source,bind]
----
zone "example.com" IN {
    type master;
    file "/etc/bind/zones/db.example.com";
    allow-transfer { key "example-tsig"; };
    also-notify  { 192.0.2.20 key "example-tsig"; };
};
----

[cols="1,4",options="header"]
|===
| Directive | Rôle
| `allow-transfer` | Refuse toute requête AXFR / IXFR ne portant pas la bonne signature TSIG.
| `also-notify`    | Envoie une notification (*NOTIFY*) signée au secondaire dès que le SOA change.
|===

===== Étape 4 : Configurer la zone sur le **slave**

Dans `/etc/bind/named.conf.local` du secondaire :

[source,bind]
----
zone "example.com" IN {
    type slave;
    masters { 192.0.2.10 key "example-tsig"; };
    file "/var/cache/bind/slaves/db.example.com";
};
----

===== Étape 5 : Recharger ou redémarrer BIND

[source,bash]
----
# Méthode sans coupure
sudo rndc reconfig

# Ou, si rndc n'est pas configuré
sudo systemctl restart bind9
----

Vérifiez qu’aucune erreur ne s’affiche dans `/var/log/syslog` ou
`journalctl -eu bind9`.

===== Étape 6 : Validation du transfert

====== 1. Depuis le **slave**

Demandez le transfert complet (AXFR) :

[source,bash]
----
dig @192.0.2.10 example.com AXFR \
    -y example-tsig:YmFzZTY0RW5jb2RlZEtleQ== \
    +tcp +nocookie
----

La réponse doit contenir tous les enregistrements de zone et
*status: NOERROR*.

====== 2. Depuis n’importe quel hôte non autorisé

La requête suivante doit échouer avec *REFUSED* ou *NOAUTH* :

[source,bash]
----
dig @192.0.2.10 example.com AXFR +tcp
----

===== Dépannage rapide

[cols="1,4",options="header"]
|===
| Symptom | Cause probable / Correctif
| `TSIG BADKEY`  | Les deux serveurs n’utilisent pas la même chaîne Base64 ou le même nom de clé.
| `TSIG BADSIG`  | Mauvais algorithme ou corruption du message ; régénérer la clé.
| `TSIG BADTIME` | Décalage d’horloge > 5 min ; vérifier NTP / chrony.
|===

==== Références

* RFC 2845 — *Secret Key Transaction Signatures for DNS (TSIG)*
* `dnssec-keygen(8)` — page de manuel
* *BIND Administrator Reference Manual* (ARM)

=== DoH et DoT

* DoH : Dns Over Https: Permets de crypter le traffic dns à l'intérieur d'une communication https, une session https est au préalable établie entre le resolver et le serveur dns qui présente son certificat, les paquets sont ainsi cryptés via la clé partagée établie à l'issue du processus d'authentification.
* DoT : Dns Over TLS : Permets de crypter le traffic dns à l'intérieur d'une communication tls. L'authentification se fait par le biais de certificats TLS, similaire aux certificats https. DoT est spécifiquement conçu pour crypter les communications dns, il utilise le port dédié 853, il peut être considére comme plus simple, il n'utilise pas le port 443 comme DoH, ainsi il permets de mieux segmenter les communications réseaux et d'identifier plus attentivement les communications dns. Il permets ainsi une distincition claire du traffic web.

__la sécurisation des communications peut concerner le resolver avec le nameserver mais également les nameservers entre eux__

==== Pratiques

Une minimisation des la longueur des zones aide à limiter les données exploitables par un attaquant lors de la reconnaissance.

=== ACL

Il est recommandé de mettre un contrôle d'accès (ACL) et de sécuriser les communications avec TSIG ou DNSSEC pour prévenir les modifications non autorisées.

.acl avec bind
[source, python]
----
acl "trusted" {
    192.0.2.0/24;       // Réseau interne
    203.0.113.4;        // Serveur DNS secondaire spécifique
};

acl "clients" {
    198.51.100.0/24;
};

options {
    directory "/var/named";
    recursion yes;   // Permet la récursivité pour les requêtes DNS
    allow-query { clients; }; // Permet aux clients de faire des requêtes DNS

    allow-transfer { trusted; }; // Permet le transfert de zone aux serveurs "trusted"
    allow-recursion { trusted; }; // Permet la récursivité seulement pour les "trusted"
};

zone "example.com" IN {
    type master;
    file "db.example.com";
    allow-query { any; }; // Cette zone peut être requêtée par n'importe qui
    allow-transfer { none; }; // Désactive le transfert de zone pour cette zone spécifique
};

# Dans cet exemple, on définit comme appartenant au groupe "trusted" (192.0.2.0/24) et un serveur secondaire spécifique (203.0.113.4), et comme appartenant au groupe "clients" les machines du réseau 198.51.100.0/24. On définit ensuites les politiques de ces deux groupes dans le dossier /var/name. (on précise que la récursion est activée). clients a le droit de faire des requêtes (allow-query), tandis que trusted a le droit de faire du transfert de zone, et on précise que la recursion n'est autorisée que pour les trusted.

# Enfin on précise que la zone example.com a sa propre politique de sécurité concernant les query et le transfert, le transfert n'est pas autorisé, et tout le monde peut faire une requête.

----

== Gestion avancé du cache

La gestion efficace du cache DNS repose sur la définition stratégique des valeurs TTL (Time To Live) pour les enregistrements DNS. Des TTL courts permettent des mises à jour plus rapides dans la propagation des changements DNS, mais augmentent la charge sur les serveurs DNS. Des TTL longs réduisent la fréquence des requêtes au serveur DNS mais peuvent retarder la propagation des mises à jour.

Meilleures pratiques :

Équilibrage : Utilisez des TTL courts pour les enregistrements susceptibles de changer fréquemment, et des TTL longs pour ceux qui sont relativement statiques.
Surveillance : Implémentez des outils de surveillance DNS pour analyser l'efficacité du cache et ajuster les TTL en conséquence.
Validation : Assurez-vous que les serveurs DNS respectent les valeurs TTL spécifiées, évitant ainsi le cache excessif ou insuffisant.

== DNS Anycast

DNS Anycast permet à plusieurs serveurs DNS de répondre à la même adresse IP. Les routeurs dirigent les requêtes DNS vers le serveur le plus proche géographiquement, réduisant ainsi la latence.

Implémentation :

Réseau global : Déployez des instances DNS dans plusieurs centres de données à travers le monde.
Configuration réseau : Configurez le routage Anycast au niveau de vos fournisseurs de transit et de vos points d'échange Internet (IXP).
Redondance : Assurez-vous que chaque instance DNS est capable de gérer indépendamment les requêtes, pour garantir la disponibilité.
Compatibilité et Transition vers IPv6
Enjeux : La transition vers IPv6 nécessite que les serveurs DNS puissent gérer les enregistrements AAAA, qui pointent vers des adresses IPv6.

Stratégies :

Dual-stack : Configurez vos serveurs DNS pour qu'ils fonctionnent en mode dual-stack, acceptant à la fois les connexions IPv4 et IPv6.
Enregistrements AAAA : Ajoutez des enregistrements AAAA pour tous les domaines et sous-domaines, parallèlement aux enregistrements A existants.
Test : Vérifiez la compatibilité IPv6 de votre infrastructure DNS en utilisant des outils de test en ligne.

== DNS et Cloud

Options :

AWS Route 53 : Offre une haute disponibilité et un service DNS scalable avec des fonctionnalités avancées comme la gestion du trafic basée sur la santé des ressources.
Google Cloud DNS : Propose une infrastructure DNS globale et rapide, intégrée avec d'autres services Google Cloud.
Azure DNS : Intègre des services DNS dans l'écosystème Azure, permettant une gestion unifiée des ressources cloud et DNS.


== 🌐 Configuration Complète BIND avec DNSSEC

=== Arborescence des Fichiers

[source,text]
----
/etc/bind/
├── named.conf                     # Configuration principale
├── keys/                          # Répertoire sécurisé pour les clés
│   ├── K.root.+008+12345.key      # DNSKEY publique racine (trust anchor)
│   ├── K.root.+008+12345.private  # Clé privée KSK racine 🔐
│   ├── K.root.+008+67890.key      # DNSKEY publique ZSK racine
│   ├── K.root.+008+67890.private  # Clé privée ZSK racine 🔐
│   ├── K.com.+013+19718.key       # DNSKEY publique KSK .com
│   ├── K.com.+013+19718.private   # Clé privée KSK .com 🔐
│   ├── K.com.+013+54321.key       # DNSKEY publique ZSK .com
│   ├── K.com.+013+54321.private   # Clé privée ZSK .com 🔐
│   ├── K.cloudflare.+013+34505.key # DNSKEY publique KSK cloudflare
│   ├── K.cloudflare.+013+34505.private # Clé privée KSK cloudflare 🔐
│   ├── K.cloudflare.+013+67890.key # DNSKEY publique ZSK cloudflare
│   └── K.cloudflare.+013+67890.private # Clé privée ZSK cloudflare 🔐
├── zones/
│   ├── db.root                    # Zone racine (.)
│   ├── db.com                     # Zone TLD (.com)
│   └── db.cloudflare.com          # Zone domaine (cloudflare.com)
----

=== 🔧 1. `named.conf` - Configuration Principale

[source,bind]
----
options {
    directory "/etc/bind";
    dnssec-enable yes;              # Activation globale DNSSEC
    dnssec-validation yes;          # Validation récursive DNSSEC
    bindkeys-file "/etc/bind/keys/bind.keys"; # Fichier trust anchors

    # Configuration DNSSEC avancée
    dnssec-lookaside auto;          # Utilisation DLV (si nécessaire)
    dnssec-must-be-secure "." yes;  # Exiger validation pour la racine
};

// ZONE RACINE
zone "." {
    type master;
    file "zones/db.root";
    key-directory "/etc/bind/keys"; # Répertoire des clés
    auto-dnssec maintain;           # Gestion automatique signatures
    inline-signing yes;             # Signatures en temps réel
};

// ZONE TLD (.com)
zone "com." {
    type master;
    file "zones/db.com";
    key-directory "/etc/bind/keys";
    auto-dnssec maintain;
    inline-signing yes;
};

// ZONE DOMAINE
zone "cloudflare.com." {
    type master;
    file "zones/db.cloudflare.com";
    key-directory "/etc/bind/keys";
    auto-dnssec maintain;
    inline-signing yes;
};
----

==== 🔍 Explications :
- `key-directory` : Répertoire contenant à la fois les clés publiques (.key) et privées (.private)
- `auto-dnssec maintain` : BIND signe automatiquement la zone avec les clés disponibles
- `inline-signing` : Génération dynamique des signatures sans modifier le fichier de zone original

=== 🌐 2. `/etc/bind/zones/db.root` - Zone Racine (.) avec clés PUBLIQUES

[source,bind]
----
$TTL 3600
@ IN SOA  root.dns. admin.dns. (
    2025070101 ; Serial (AAAAMMJJNN)
    10800      ; Refresh (3h)
    3600       ; Retry (1h)
    2592000    ; Expire (30j)
    3600       ; Minimum TTL (1h)
)

; SERVERS RACINE
. IN NS a.root-servers.net.
a.root-servers.net. IN A 198.41.0.4

; === ENREGISTREMENTS DNSSEC ===

; -- DNSKEY PUBLIQUE RACINE (KSK) --
@ IN DNSKEY 257 3 8 (
    AwEAAagAIKlVZrpC6Ia7gEzahOR+9W29euxhJhVVLOyQ...
) ; id = 12345 (KSK)

; -- DNSKEY PUBLIQUE RACINE (ZSK) --
@ IN DNSKEY 256 3 8 (
    AwEAAbcd123456...
) ; id = 67890 (ZSK)

; -- RRSIG DNSKEY (signée par KSK privée) --
@ IN RRSIG DNSKEY 8 0 3600 (
    20250801000000 ; Expiration
    20250701000000 ; Début validité
    12345          ; Key tag KSK
    .
    FAKE-SIGNATURE==
)

; -- DS pour .com (hash de la KSK publique de .com) --
com. IN DS 19718 13 2 (
    E4F1A2B38CFBD55AB4FE3C739F785842B9C2EDC1DA92...
) ; Algo 13 (ECDSA), Digest Type 2 (SHA-256)

; -- RRSIG DS (signée par ZSK privée) --
com. IN RRSIG DS 8 1 86400 (
    20250801000000
    20250701000000
    67890          ; Key tag ZSK
    .
    FAKE-SIGNATURE==
)
----

==== 🔒 Fichier de clé privée associée : `/etc/bind/keys/K.root.+008+12345.private`
[source,text]
----
Private-key-format: v1.3
Algorithm: 8 (RSASHA256)
Modulus: AQOgx... (base64)
PublicExponent: AQAB
PrivateExponent: MIGHAgE... (base64)
Prime1: 7ZvR...
Prime2: 6Uw9...
Exponent1: 5l0x...
Exponent2: 4k4c...
Coefficient: 1k3b...
----

=== 🌐 3. `/etc/bind/zones/db.com` - Zone .com avec clés PUBLIQUES

[source,bind]
----
$TTL 3600
@ IN SOA ns1.com. admin.com. (
    2025070101
    7200
    3600
    1209600
    3600
)

; SERVERS TLD
com. IN NS ns1.com.
ns1.com. IN A 192.5.6.30

; === ENREGISTREMENTS DNSSEC ===

; -- DNSKEY PUBLIQUE KSK .com (algo 13) --
@ IN DNSKEY 257 3 13 (
    AwEAAZ0pD5r+9k/3VJbV4R7zJ2mG...
) ; id = 19718

; -- DNSKEY PUBLIQUE ZSK .com --
@ IN DNSKEY 256 3 13 (
    AwEAAd1Xv5rX3Y6Z6A7...
) ; id = 54321

; -- RRSIG DNSKEY (signée par KSK privée) --
@ IN RRSIG DNSKEY 13 1 3600 (
    20250801000000
    20250701000000
    19718
    com.
    FAKE-SIGNATURE==
)

; -- DS pour cloudflare.com (hash de la KSK publique cloudflare) --
cloudflare.com. IN DS 34505 13 2 (
    9A8D7B2E9E1C37F6D2AC7A9270B0F3F8912C5827AE51...
)

; -- RRSIG DS (signée par ZSK privée .com) --
cloudflare.com. IN RRSIG DS 13 2 86400 (
    20250801000000
    20250701000000
    54321
    com.
    FAKE-SIGNATURE==
)
----

==== 🔒 Fichier de clé privée associée : `/etc/bind/keys/K.com.+013+19718.private`
[source,text]
----
Private-key-format: v1.3
Algorithm: 13 (ECDSAP256SHA256)
PrivateKey: MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgZ0lHk8gHkz0a...
----

=== 🌐 4. `/etc/bind/zones/db.cloudflare.com` - Zone Domaine avec clés PUBLIQUES

[source,bind]
----
$TTL 300
@ IN SOA ns1.cloudflare.com. admin.cloudflare.com. (
    2025070101
    3600
    1800
    604800
    300
)

; SERVERS DOMAINE
@ IN NS ns1.cloudflare.com.
ns1 IN A 104.16.134.229

; === ENREGISTREMENTS DNSSEC ===

; -- DNSKEY PUBLIQUE KSK cloudflare.com --
@ IN DNSKEY 257 3 13 (
    AwEAAZ0pD5r+9k/3VJbV4R7zJ2mG...
) ; id = 34505

; -- DNSKEY PUBLIQUE ZSK cloudflare.com --
@ IN DNSKEY 256 3 13 (
    AwEAAd1Xv5rX3Y6Z6A7...
) ; id = 67890

; -- RRSIG DNSKEY (signée par KSK privée) --
@ IN RRSIG DNSKEY 13 2 3600 (
    20250801000000
    20250701000000
    34505
    cloudflare.com.
    FAKE-SIGNATURE==
)

; === DONNÉES UTILES ===
www IN A 104.16.132.229
www IN A 104.16.133.229

; -- Signature RRset A (signée par ZSK privée) --
www IN RRSIG A 13 3 300 (
    20250710000000  ; TTL court pour rotation fréquente
    20250701000000
    67890           ; Key tag ZSK
    cloudflare.com.
    FAKE-SIGNATURE==
)
----

==== 🔒 Fichier de clé privée associée : `/etc/bind/keys/K.cloudflare.+013+67890.private`
[source,text]
----
Private-key-format: v1.3
Algorithm: 13 (ECDSAP256SHA256)
PrivateKey: MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgZ0lHk8gHkz0a...
----

© 2025 *rridane* – [GitHub](https://github.com/rridane)
