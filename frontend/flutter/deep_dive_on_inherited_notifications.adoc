:source-highlighter: rouge
:hardbreaks:
:table-caption!:
:title: Deep dived on inherited and notifications

== Rebuild de l'inheritedWidget

InheritedElement étends de ProxyElement, lorsqu'un parent change, il forcera alors le build de ses enfants, si un de ses enfant est un inheritedElement, alors update (qui est surchargée par rapport à ComponentElement et à Element) se appelée.

.update de proxyElementa appelle udpated
[source, dart]
----
abstract class ProxyElement extends ComponentElement {
/// Initializes fields for subclasses.
ProxyElement(ProxyWidget super.widget);

  @override
  Widget build() => (widget as ProxyWidget).child;

  @override
  void update(ProxyWidget newWidget) {
    final ProxyWidget oldWidget = widget as ProxyWidget;
    assert(widget != newWidget);
    super.update(newWidget);
    assert(widget == newWidget);
    updated(oldWidget);
    rebuild(force: true);
  }

  /// Called during build when the [widget] has changed.
  ///
  /// By default, calls [notifyClients]. Subclasses may override this method to
  /// avoid calling [notifyClients] unnecessarily (e.g. if the old and new
  /// widgets are equivalent).
  @protected
  void updated(covariant ProxyWidget oldWidget) {
    notifyClients(oldWidget);
  }
----

Cette méthode appelle updated, mais updated est surchargée dans inheritedElement.

Elle va tout d'abord consulter la méthode updateShouldNotify que nous implémentons dans nos inheritedWidget

.updated appelle updateShouldNotify puis updated du proxy
[source, dart]
----
  /// Calls [Element.didChangeDependencies] of all dependent elements, if
  /// [InheritedWidget.updateShouldNotify] returns true.
  ///
  /// Called by [update], immediately prior to [build].
  ///
  /// Calls [notifyClients] to actually trigger the notifications.
  @override
  void updated(InheritedWidget oldWidget) {
    if ((widget as InheritedWidget).updateShouldNotify(oldWidget)) {
      super.updated(oldWidget);
    }
  }
----

Puis appeller l'updated du proxy

.notifyClients
[source, dart]
----
  @protected
  void updated(covariant ProxyWidget oldWidget) {
    notifyClients(oldWidget);
  }
----

Celle ci notiife les "clients".

Il faut remonter à l'inheritedElement pour voir la méthode notifyClient,

.notifyClient dans inheritedElement
[source, dart]
----
  @override
  void notifyClients(InheritedWidget oldWidget) {
    assert(_debugCheckOwnerBuildTargetExists('notifyClients'));
    for (final Element dependent in _dependents.keys) {
      assert(() {
        // check that it really is our descendant
        Element? ancestor = dependent._parent;
        while (ancestor != this && ancestor != null) {
          ancestor = ancestor._parent;
        }
        return ancestor == this;
      }());
      // check that it really depends on us
      assert(dependent._dependencies!.contains(this));
      notifyDependent(oldWidget, dependent);
    }
  }
----


On voit qu'elle parcours les "dependent", et appelle notifiyDependent, qui appelle didChangeDependencies. C'est donc au passage dans nos didChangeDependencies qu'il faut mettre à jour les données issues des inheritedWidgets.

.notifyDependent
[source, dart]
----
  @protected
  void notifyDependent(covariant InheritedWidget oldWidget, Element dependent) {
    dependent.didChangeDependencies();
  }
----

didChangeDependencies. Or en plus d'appeler les didChangeDependencies implémentée, cette méthode doit appeler celle de son parent (Element). Une fois donc la mise à jour effectuée par nos soin, l'element est finalement marqué comme dirty pour le build, et sera reconstruit à la prochaine frame

.marksNeedBuild
[source, dart]
----
  @mustCallSuper
  void didChangeDependencies() {
    assert(_lifecycleState == _ElementLifecycle.active); // otherwise markNeedsBuild is a no-op
    assert(_debugCheckOwnerBuildTargetExists('didChangeDependencies'));
    markNeedsBuild();
  }
----

== L'ajout des depend

Lorsque nous utilisons des données depuis un composant enfant d'un inheritedWidget cela se fait par la méthode dependOnInheritedWidgetOfExactType

.dependOnInheritedWidgetOfExactType dans Element
[source, dart]
----
  @override
  T? dependOnInheritedWidgetOfExactType<T extends InheritedWidget>({Object? aspect}) {
    assert(_debugCheckStateIsActiveForAncestorLookup());
    final InheritedElement? ancestor = _inheritedElements == null ? null : _inheritedElements![T];
    if (ancestor != null) {
      return dependOnInheritedElement(ancestor, aspect: aspect) as T;
    }
    _hadUnsatisfiedDependencies = true;
    return null;
  }
----


Cela appelle également dependOnInheritedElement des _inheritedElements.

.dependOnInheritedElement
[source, dart]
----
  @override
  InheritedWidget dependOnInheritedElement(InheritedElement ancestor, { Object? aspect }) {
    _dependencies ??= HashSet<InheritedElement>();
    _dependencies!.add(ancestor);
    ancestor.updateDependencies(this, aspect);
    return ancestor.widget as InheritedWidget;
  }
----

On voit que cela maintient d'une part dans l'element un liste des dependencies.

._inheritedElements[T]
[source, dart]
----
    _dependencies!.add(ancestor);
----

Mais surtout cela appelle updateDependencies sur l'ancềtre

.updateDependencies
[source, dart]
----
  @protected
  void updateDependencies(Element dependent, Object? aspect) {
    setDependencies(dependent, null);
  }
----

Et setDependencies ajouter le widget à la liste des dependent.

.setDependencies
[source, dart]
----
  @protected
  void setDependencies(Element dependent, Object? value) {
    _dependents[dependent] = value;
  }
----

== Exemple d'implémentation

.
[source, dart]
----
class StateOwner extends InheritedWidget {

  int counter = 0;

  StateOwner({required super.child});

  static int of(BuildContext context) => context.dependOnInheritedWidgetOfExactType<StateOwner>()!.counter;

  @override
  bool updateShouldNotify(covariant StateOwner oldWidget) {
    oldWidget.counter != counter;
    throw UnimplementedError();
  }

}

class ChildOfStateOwner extends StatelessWidget {

  @override
  Widget build(BuildContext context) {

    int counter = StateOwner.of(context);

    return Text(counter.toString());

  }

}
----

== NotificationListener : Dispatch

Le processus de notification dans flutter fonctionne d'un widget parent qui implémente la NotifiableMixin a tous ses widgets enfants. Le processus est le suivant.


.utilisation du NotificationListener
[source, dart]
----
class NotificationListenerExample extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Notification Listener Example'),
      ),
      body: NotificationListener<CustomNotification>(
        onNotification: (notification) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(notification.message),
              duration: Duration(seconds: 2),
            ),
          );
          return true; // Stop propagation.
        },
        child: Center(
          child: NotificationButton(),
        ),
      ),
    );
  }
}
----

=== Introduction et pré requis à la compréhension

En partant du haut de l'arbre des elements, un enfant disposera du notificationTree de son parent immédiat. Lorsque nous implémentons la mixin NotifiableMixin depuis un composant parent, cela va créer le NotificationNode dans l'element parent.

.lorsqu'un widget implémente la NotifiableElementMixin
[source, dart]
----
mixin NotifiableElementMixin on Element {
  /// Called when a notification of the appropriate type arrives at this
  /// location in the tree.
  ///
  /// Return true to cancel the notification bubbling. Return false to
  /// allow the notification to continue to be dispatched to further ancestors.
  bool onNotification(Notification notification);

  @override
  void attachNotificationTree() {
    _notificationTree = _NotificationNode(_parent?._notificationTree, this);
  }
}
----

Or la méthode attachNotificationTree est appelée à chaque mount, donc à chaque updateChild. Et pour un element qui n'implémente pas la mixin, l'attachNotificationTree passera simplement le notificationTree créé par le parent. Il va donc se propager de haut en bas, tous les enfants d'un NotifiableMixin disposera donc du NotificationTree du parent:

.passer par défaut le notificationTree du parent
[source, dart]
----
  @protected
  void attachNotificationTree() {
    _notificationTree = _parent?._notificationTree;
  }
----

Ainsi lorsqu'un enfant dispatch une notification, il le fera sur le notificationNode du parent le plus proche qui implémente la NotifiableMixin, puisqu'il a été passé d'enfants en enfants.

.dispatch depuis la classe Notification
[source, dart]
----
abstract class Notification {
  /// Abstract const constructor. This constructor enables subclasses to provide
  /// const constructors so that they can be used in const expressions.
  const Notification();

  /// Start bubbling this notification at the given build context.
  ///
  /// The notification will be delivered to any [NotificationListener] widgets
  /// with the appropriate type parameters that are ancestors of the given
  /// [BuildContext]. If the [BuildContext] is null, the notification is not
  /// dispatched.
  void dispatch(BuildContext? target) {
    target?.dispatchNotification(this);
  }

  @override
  String toString() {
    final List<String> description = <String>[];
    debugFillDescription(description);
    return '${objectRuntimeType(this, 'Notification')}(${description.join(", ")})';
  }

  /// Add additional information to the given description for use by [toString].
  ///
  /// This method makes it easier for subclasses to coordinate to provide a
  /// high-quality [toString] implementation. The [toString] implementation on
  /// the [Notification] base class calls [debugFillDescription] to collect
  /// useful information from subclasses to incorporate into its return value.
  ///
  /// Implementations of this method should start with a call to the inherited
  /// method, as in `super.debugFillDescription(description)`.
  @protected
  @mustCallSuper
  void debugFillDescription(List<String> description) { }
}
----

Or cette méthode appelle dispatchNotification sur l'element, et leNotificationTree est celui du parent le plus proche qui implémente la notifiableMixin passé d'enfant en enfant.


.dispatchNotification on NotificationNode
[source, dart]
----
class _NotificationNode {
  _NotificationNode(this.parent, this.current);

  NotifiableElementMixin? current;
  _NotificationNode? parent;

  void dispatchNotification(Notification notification) {
    if (current?.onNotification(notification) ?? true) {
      return;
    }
    parent?.dispatchNotification(notification);
  }
}
----

Hors la méthode dispatchNotification va faire le chemin inverse, elle s'assurera que le current est bien le NotificationListener source, elle le fait en vérifiant que la méthode onNotification a bien été implémentée, si ce n'est pas le cas elle remonte au parent. Elle le fera jusqu'à trouver la méthode onNotification

.exemple de parent qui passe son NotificationTree
[source, dart]
----
class AppController extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return NotificationListener<CustomNotification>(
      onNotification: (notification) {
        // Gérer les notifications ici, par exemple, enregistrer des actions, analyser des événements, etc.
        print(notification.message);
        return true; // Stop the notification from bubbling up further
      },
      child: AppData(
        themeData: 'Light',
        child: MaterialApp(
          home: HomeScreen(),
        ),
      ),
    );
  }
}
----

A noter ainsi que si l'on veut qu'une notification soit dispatché à deux notifiationListener parent, on peut ne pas retourner true.

