:author-url: https://github.com/rridane
:author: rridane
:source-highlighter: rouge
:hardbreaks:
:table-caption!:
:toc: left
:title: Render Box

= RenderBox

== RenderBox protocol

Constraints go down => le parent dit à l'enfant "voici ce que tu peux avoir"
En réalité il passe une BoxConstraints (min et max width & height)
Sizes go up => L'enfant dit "ok si je peux avoir au max tant j'en veux tant"
En réalité il passe un object size (height, width)
Parents sets position => le parent dit "ok si tu veux tant, tu seras ici"

== RenderSliver Protocol

Les contraintes utilisées par le protocol sliver sont beaucoup plus nombreuses:

axisDirection
crossAxisDirection
growthDirection
etc, elles sont très nombreuses mais il est fait pour s'étendre

Les slivers constraints vont vers le bas, donc il lui passe une direction etc

Les SliveGeometry vont vers le haut, elles ont également beaucoup plus de propriétés :

maxPaintExtent
layoutExtent
maxPaintExtent
etc

== ContainerParentDataMixin

Permets d'accéder au previsouSibling et nextSibling

.ContainerParentDataMixin
[source, dart]
----
mixin ContainerParentDataMixin<ChildType extends RenderObject> on ParentData {
  /// The previous sibling in the parent's child list.
  ChildType? previousSibling;
  /// The next sibling in the parent's child list.
  ChildType? nextSibling;

  /// Clear the sibling pointers.
  @override
  void detach() {
    assert(previousSibling == null, 'Pointers to siblings must be nulled before detaching ParentData.');
    assert(nextSibling == null, 'Pointers to siblings must be nulled before detaching ParentData.');
    super.detach();
  }
}
----

== ContainerRenderObjectMixin

Permets d'accéder à de nombreuses infos sur les renderObjects. Elle demande à ce qu'on lui fournisse le couple enfant <> parentData

* firstChild et lastChild
* childCount
* de nombreuses méthodes pour manipuler l'arbre
** add
** addAll
** insert
** remove
** removeAll
** detach
** attach
** visitChildren
** childBefore
** childAfter
** etc

Elle permets notamment d'utiliser child.nextSibling dans notre boucle pour le layout et le paint.

== RenderBoxContainerDefaultsMixin

Elle nous des implémentations par défaut pour nous faire gagner du temps de quatre méthodes.

* defaultComputeDistanceToFirstActualBaseline
* defaultComputeDistanceToHighestActualBaseline
* defaultHitTestChildren
* defaultPaint
* getChildrenAsList

Elle demande également à ce qu'on lui fournisse le couple enfant <> parentData.

== ParentData

C'est la représentation du "parents sets position". Chaque renderObject dispose d'un parentData définit par son parent, Il est stocké au niveau de l'enfant, mais a été définit par le parent.

== Les points successifs importants à reporter ici

* Les méthodes des mixin
* Les deux étapes importantes dans le perform, le layout et le positioning
* le computeDryLayout pour l'optimisation
* Les offsets

Une fois rattachée à l'enfant, le parent pourra le reconsulter pendant l'étape de layout et de paint. C'est une manière de rattacher une configuration spécifique au parent sur le renderObject.

== Intrinsics

C'est la capacité d'un widget à se size en fonction de la taille de ses enfants.

getMinInstrinsicWidth appelle computeMinIntrinsincWidth

Il faut implémenter les méthodes intrinsic pour avoir l'intrinsic, par défaut elles retournent.

== Baseline

Pour les widgets texte, il s'agit de la distance entre la bordure supérieure et le bas de la première ligne de texte (ligne sur laquelle repose le texte).

Il y en a deux:

- Alphabetical
- Ideographic

la height prends le relais pour les lignes suivantes, mais pour plus de clarté, les systèmes idéographiques ont besoin de plus d'espacement avec la bordure supérieure.

La baseline et la height combinée permettent donc un contrôle précis de l'affichage du texte, de la première ligne (baseline) jusqu'à l'affichage de toutes les autres lignes (height).

Il y a deux méthodes intéressantes dans la RenderBoxDefaultsMixin, :

- defaultComputeDistanceToFirstActualBaseline
- defaultComputeDistanceToHighesttActualBaseline

1. defaultComputeDistanceToFirstActualBaseline
Cette méthode calcule la distance de la bordure supérieure du conteneur jusqu'à la première baseline rencontrée parmi ses enfants. C'est-à-dire qu'elle parcourt les enfants du conteneur et renvoie la distance jusqu'à la première baseline d'un enfant qu'elle trouve. Si aucun des enfants n'a de baseline définie, la méthode renvoie null. Cette méthode est utile pour aligner un widget conteneur avec un autre selon la baseline du premier enfant qui présente une telle mesure.

2. defaultComputeDistanceToHighestActualBaseline
À l'inverse, cette méthode calcule la distance de la bordure supérieure du conteneur jusqu'à la plus haute (c'est-à-dire la plus proche du haut du conteneur) baseline parmi ses enfants. Elle parcourt tous les enfants et trouve la baseline la plus haute (la plus petite distance verticale depuis le haut du conteneur). Comme pour la première méthode, si aucun des enfants n'a de baseline, la méthode renvoie null.

NOTE: Cela signifie qu'un texte peut apparaitre via le premier widget mais ne pas être le plus haut.

== Voir la gesture arena

__TODO__

Notamment ce qui va distinguer les gestures:

- kDoubleTapTimeout
- kPresTimeout

etc

== Semantics

Dans la doc du Semantics Widget:
"used by accessibility tools, search engines, and other semantic analysis software to determine the meaning of the application"

Il y a deux méthodes :

- visitChildren for semantics qu'il n'est pas utile de surcharger
- describeApproximatePaintClip
- describeSemanticsConfiguration

.describeSemanticsConfiguration est la méthode qui permets de décrire ce que l'on devrait voir
[source, dart]
----
  @override
  void describeSemanticsConfiguration(SemanticsConfiguration config) {
    config
      ..isButton = true
      ..textDirection = TextDirection.ltr
      ..hint = 'Trigger spinning animation'
      ..onTap = _onTap;
  }

----

On peut utiliser le widget Semantic Debugger pour une représentation visuelle de l'accessibilité.

== Manipuler et créer des renderObjects

== Créer le widget qui servira de configuration pour l'element et pour le renderObject

* Etendre de MultiChildRenderObjectWidget, de SingleChildRenderObject, de LeafRenderObjectWidget.

Le widget doit implémenter les méthodes:

* `createRenderObject` retourne le renderObject que nous crééons
* `updateRenderObject` donne la procédure pour l'update du renderObject

=== Quelques exemples

==== SingleRenderObject

.simple SingleRenderObject et proxybox
[source, dart]
----
class CustomProxyBox extends SingleChildRenderObjectWidget {
  CustomProxyBox({
    Key? key,
    required Widget child,
  }) : super(key: key, child: child);

  @override
  RenderObject createRenderObject(BuildContext context) {
    return RenderCustomProxyBox();
  }
}
----

==== LeafRenderObject

il s'agit de la configuration d'un renderObject qui gère une box de couleur, avec un carré qu'il est possible de manipuler en rotation. A noter ici la mise à jour via l'updateRenderObject

.leafRenderObject pour une customBox
[source, dart]
----
class CustomBox extends LeafRenderObjectWidget {
  int flex;
  Color color;
  double rotation;
  final VoidCallback? onTap;

  CustomBox({Key? key, this.flex = 0, required this.color, required this.rotation, this.onTap});

  @override
  RenderObject createRenderObject(BuildContext context) {
    return RenderCustomBox(flex: flex, color: color, rotation: rotation, onTap: onTap);
  }

  @override
  void updateRenderObject(BuildContext context, covariant RenderCustomBox renderObject) {
    renderObject
      .._flex = flex
      .._color = color
      ..rotation = rotation
      ..onTap = onTap;
    ;
  }
}
----

==== MultiChildRenderObject

Il s'agit du widget, donc de la configuration d'un customColumn

.multichildRenderObject
[source, dart]
----
class CustomColumn extends MultiChildRenderObjectWidget {
  List<Widget> children;

  final CustomColumnAlignment alignment;

  CustomColumn({required this.children, this.alignment = CustomColumnAlignment.center});

  @override
  RenderObject createRenderObject(BuildContext context) {
    return RenderCustomColumn(alignment: alignment);
  }

  @override
  void updateRenderObject(BuildContext context, covariant RenderCustomColumn renderObject) {
    renderObject.alignment = alignment;
  }

----

== Créer le ParentData si besoin

Si l'on a besoin d'utiliser la ContainerRenderObjectMixin il nous faut créer un parentData. Cette mixin a besoin de connaitre les couples enfant <> parentData qu'elle manipule. Il en est de même pour la RenderBoxContainerDefaultsMixin.

.exemple de parentData qui permets de récupérer le flex setté par les enfants
[source, dart]
----
class CustomColumnParentData extends ContainerBoxParentData<RenderBox> {
  int? flex = 0;
}
----

On surchage également la méthode qui définit le parentData

.setUpParentData
[source, dart]
----
  @override
  void setupParentData(covariant RenderObject child) {
    if (child.parentData is! CustomColumnParentData) {
      child.parentData = CustomColumnParentData();
    }
  }
----

== Créer la renderBox

=== Pattern d'optimisation

Il est préférable d'utiliser des getters et des setters pour nos propriétés, cela nous permets de contrôler le markNeedsLayout, marksNeedsPaint et MarksNeedsSemanticsUpdate et de ne pas faire de relaout inutile. On contrôle systématiquement si la valeur a changé, si non c'est inutile de processer.

.pattern de contrôle avant update
[source, dart]
----

  CustomColumnAlignment _alignment;
  RenderCustomColumn({required CustomColumnAlignment alignment}): _alignment = alignment;

  CustomColumnAlignment get alignment => _alignment;

  set alignment(CustomColumnAlignment value) {
    if (value == _alignment) {
      return;
    }
    _alignment = value;
    marksNeedsLayout();
  }
----

== Implémentation du layout d'un MultiChild Column

On implémente ensuite les méthodes

* performLayout : Cette étape peut se diviser en deux
    ** processSize: Définit la taille du widget parent en fonction de la taille demandée par les enfants
    ** positionChildren: Positionne les enfants en fonction de la taille du widget parent et de la taille des enfants
* computeDryLayout: computeLayout ne calcul que la size, cela peut être utile pour des problématiques d'optimisation. Par exemple pour des processus de layout complexes.

.exemple
[source, dart]
----

  @override
  void performLayout() {

    size = _processSize(false);
    _positionChildren();

  }

  Size _processSize(bool dryLayout) {
    double width = 0, height = 0;

    RenderBox? child = firstChild;
    RenderBox? lastFlexChild;

    int totalFlex = 0;

    // Layout non flex
    while (child != null) {
      final childParentData = child.parentData as CustomColumnParentData;
      final flex = childParentData.flex ?? 0;

      if (flex > 0) {
        totalFlex += flex;
        lastFlexChild = child;
      } else {
        if (!dryLayout) {
          child.layout(BoxConstraints(maxWidth: constraints.maxWidth), parentUsesSize: true);
        }

        height += child.size.height;
        width = max(width, child.size.width);
      }

      child = childParentData.nextSibling;
    }

    child = lastFlexChild;

    final remainingHeight = (constraints.maxHeight - height);
    final flexHeight = remainingHeight / totalFlex;

    // Layout flex
    while (child != null) {
      final childParentDta = child.parentData as CustomColumnParentData;
      final flex = childParentDta.flex ?? 0;

      if (flex > 0) {
        final childHeight = flexHeight * flex;

        if (!dryLayout) {
          child.layout(BoxConstraints(maxWidth: constraints.maxWidth, maxHeight: childHeight, minHeight: childHeight), parentUsesSize: true);
        }

        height += childHeight;
        width = max(width, child.size.width);
      }

      child = childParentDta.previousSibling;
    }

    return Size(width, height);
  }

  void _positionChildren() {

    var childOffset = const Offset(0, 0);

    RenderBox? child = firstChild;

    // L
    while (child != null) {

      final childParentData = child.parentData as CustomColumnParentData;

      double dx = 0;

      if (_alignment == CustomColumnAlignment.center) {
        dx = constraints.maxWidth / 2 - child.size.width/2;
      }


      // childParentData.offset = childOffset;
      childParentData.offset = Offset(dx, childOffset.dy);

      double dy = childOffset.dy + child.size.height;

      childOffset = Offset(dx, dy);

      child = childParentData.nextSibling;
    }

  }

  @override
  Size computeDryLayout(covariant BoxConstraints constraints) {
    return _performLayout(true);
  }
----

Pour notre column, nous ne souhaitons pas contrôler réellement le paint, on la délègue.

.defaultPaint de la RenderBoxContainerDefaultsMixin pour le column
[source, dart]
----
  @override
  void paint(PaintingContext context, Offset offset) {
    defaultPaint(context, offset);
  }
----

== Implémentation d'un parentDataWidget

Le applyParentData est utile parce qu'il nous permets de passer automatiquement les données d'un renderObject vers son parent. Cela s'avère très utile parce que ce passe s'effectue à la fois à la création du renderObject enfant, mais également lorsqu'il est mis à jour, et ce processus est automatisé.

.customExpanded qui permets d'exploiter le applyParentData
[source, dart]
----
import 'package:flutter/cupertino.dart';
import 'package:flutter_learning/widgets/render_objects/custom_column.dart';

class CustomExpanded extends ParentDataWidget<CustomColumnParentData> {

  final int flex;

  CustomExpanded({Key? key, required this.flex, required Widget child}): assert(flex > 0), super(key: key, child: child);

  @override
  void applyParentData(RenderObject renderObject) {
    final parentData = renderObject.parentData as CustomColumnParentData;

    if (parentData.flex != flex) {
      parentData.flex = flex;

      final targetObject = renderObject.parent;

      if (targetObject is RenderObject) {
        targetObject.markNeedsLayout();
      }

    }

  }

  @override
  Type get debugTypicalAncestorWidgetClass => CustomColumn;

}

----

== Implémentation d'un customColumn utilisant un leaf

NOTE: Il n'est pas recommandé d'utiliser un leaf pour contrôler les parentData, et pour les mettre à jour. Il faut utilsier un parentDataWidget, on aurait du séparer cette partie. Cela nous aurait permis de ne pas utiliser l'attach. L'attach est surchargé pour des tâches qui ne concernent pas la configuration du renderObject, définir onTap en est ici un bon exemple. On ne veut pas que le onTap soit déclenché avant que le widget est attaché, et il ne fait pas partie à proprement parler de la configuration du widget, ou plus son ajout n'en fait pas partie.

Dans cet exemple on implémente la méthode paint. Pour cela on utilise le canvas. C'est un canvas globale qui nous est fournit.

.
[source, dart]
----

class RenderCustomBox extends RenderBox {
  int _flex;
  Color _color;

  int get flex => _flex;

  Color get color => _color;
  double _rotation;
  VoidCallback? _onTap;

  late final TapGestureRecognizer _tapGestureRecognizer;

  set flex(int value) {
    assert(value > 0);
    if (value == _flex) return;

    _flex = value;

    parentData!.flex = flex;
    markNeedsLayout();
  }

  set color(Color value) {
    if (value == _color) return;

    _color = value;
    markNeedsLayout();
  }

  double get rotation => _rotation;

  @override
  bool get isRepaintBoundary => true;

  set rotation(double value) {
    if (_rotation == value) {
      return;
    }

    _rotation = value;
    markNeedsLayout();
  }

  VoidCallback? get onTap => _onTap;

  set onTap(VoidCallback? callback) {
    if (_onTap == callback) return;

    _onTap = callback;

    markNeedsSemanticsUpdate();
    markNeedsPaint();
  }

  RenderCustomBox({required int flex, required Color color, required double rotation, VoidCallback? onTap})
      : _flex = flex,
        _color = color,
        _rotation = rotation,
        _onTap = onTap,
        _tapGestureRecognizer = TapGestureRecognizer();

  @override
  CustomColumnParentData? get parentData {
    if (super.parentData == null) return null;
    assert(super.parentData is CustomColumnParentData, '$CustomBox can only be a direct child of $CustomColumn');
    return super.parentData as CustomColumnParentData;
  }

  @override
  bool get sizedByParent => true;

  @override
  Size computeDryLayout(covariant BoxConstraints constraints) {
    return constraints.biggest;
  }

  @override
  void describeSemanticsConfiguration(SemanticsConfiguration config) {
    config
      ..isButton = true
      ..textDirection = TextDirection.ltr
      ..hint = 'Trigger spinning animation'
      ..onTap = _onTap;
  }

  /// Une fois de plus il ne faut pas mettre à jour le parentData via attach, ce n'est pas son rôle
  @override
  void attach(PipelineOwner owner) {
    super.attach(owner);
    if (parentData is CustomColumnParentData) {
      (parentData as CustomColumnParentData).flex = _flex;
    }
    _tapGestureRecognizer.onTap = _onTap;

    // Lui fait ceci ici pour l'instanciation de son recognizer, mais l'on ne peut pas référencer le this dans le constructeur
    // _tapGestureRecognizer = TapGestureRecognizer(debugOwner: this);
  }

  @override
  void detach() {
    _tapGestureRecognizer.onTap = null;
    super.detach();
  }

  @override
  void paint(PaintingContext context, Offset offset) {
    // Draw background
    final canvas = context.canvas;
    canvas.drawRect(offset & size, Paint()..color = color);
    final smallRectWidth = size.shortestSide / (3 - sin(rotation));

    // Draw small rectangle
    canvas.save();
    canvas.translate(offset.dx + size.width / 2, offset.dy + size.height / 2);
    canvas.rotate(rotation);
    canvas.drawRect(
        Rect.fromCenter(center: Offset.zero, width: smallRectWidth, height: smallRectWidth),
        Paint()
          ..color
          ..style = PaintingStyle.stroke
          ..strokeWidth = 5
          ..color = Colors.blue);
    canvas.restore();
  }

  @override
  bool hitTestSelf(Offset position) {
    return size.contains(position);
  }

  @override
  void handleEvent(PointerEvent event, covariant BoxHitTestEntry entry) {
    /// Voir pourquoi mais flutter conseille de l'appeler dans la méthode source handle
    /// Il semble que cela permette de supporter debugPaintPointersEnabled
    assert(debugHandleEvent(event, entry));

    if (event is PointerDownEvent) {
      _tapGestureRecognizer.addPointer(event);
    }
  }
}
----

== Proxy box

.implémentation d'un proxybox pour manipuler le canvas avant de faire dessiner le child
[source, bash]
----

import 'package:flutter/material.dart';
import 'package:flutter/rendering.dart';

class CustomProxyBox extends SingleChildRenderObjectWidget {
  CustomProxyBox({
    Key? key,
    required Widget child,
  }) : super(key: key, child: child);

  @override
  RenderObject createRenderObject(BuildContext context) {
    return RenderCustomProxyBox();
  }
}

/// On hérite d'une renderProxy box
class RenderCustomProxyBox extends RenderProxyBox {

  @override
  bool hitTest(BoxHitTestResult result, {required Offset position}) {
    return false;
  }

  @override
  void paint(PaintingContext context, Offset offset) {
    final canvas = context.canvas;
    canvas.saveLayer(offset & size, Paint()..blendMode = BlendMode.difference..color = Colors.blue.withOpacity(0.3));
    // super.paint(context, offset); ou alors:
    context.paintChild(child!, offset);
    canvas.restore();
  }
}
----

== Very deep dive on renderObjects

Le processus de reconstruction des renderObjects et de leur arbre est le suivant.

Ce processus se déroule au cours de l'étape de build:

.widgetsBinding et buildScope initient le flux
[source, dart]
----

  void drawFrame() {
    // ...
    try {
      if (rootElement != null) {
        buildOwner!.buildScope(rootElement!);
      }
      super.drawFrame();
      // ...
      }
      // ...
  }
----

buildScope appelle element.rebuild() qui appelle performRebuild

.framework.dart, buildScope to performRebuild
[source, dart]
----

  @pragma('vm:notify-debugger-on-exception')
  void buildScope(Element context, [ VoidCallback? callback ]) {
  // ...
        try {
          element.rebuild();
        }
        // ...
  }
----

.element.rebuild to performRebuild
[source, dart]
----

  @pragma('vm:prefer-inline')
  void rebuild({bool force = false}) {
  // ...
    try {
      performRebuild();
    }
    // ...
  }
----

Le processus commence forcément par un setState donc par un componentElement

.performRebuild détermine le build et utilise
[source, dart]
----

  @override
  @pragma('vm:notify-debugger-on-exception')
  void performRebuild() {
    Widget? built;
    try {
      // ...
      built = build();
      // ...
    }
    // ...
    try {
      _child = updateChild(_child, built, slot);
      // ...
    }
    // ...
  }
----

build reconstruit l'ensemble des widgets, puisqu'il appelle simplement widget.build

updateChild fait partie de la classe Element, à noter que pour le premier appel le slot est celui de la classe Element, donc l'existant.

.updateChild on class Element
[source, dart]
----

  @protected
  @pragma('vm:prefer-inline')
  Element? updateChild(Element? child, Widget? newWidget, Object? newSlot) {

    if (newWidget == null) {
      if (child != null) {
        deactivateChild(child);
      }
      return null;
    }

    final Element newChild;
    if (child != null) {
      bool hasSameSuperclass = true;
      if (hasSameSuperclass && child.widget == newWidget) {
        if (child.slot != newSlot) {
          updateSlotForChild(child, newSlot);
        }
        newChild = child;
      } else if (hasSameSuperclass && Widget.canUpdate(child.widget, newWidget)) {
        if (child.slot != newSlot) {
          updateSlotForChild(child, newSlot);
        }
        // ...
        child.update(newWidget);
        // ...
        newChild = child;
      } else {
        deactivateChild(child);
        // ..
        newChild = inflateWidget(newWidget, newSlot);
      }
    } else {
      // ...
      newChild = inflateWidget(newWidget, newSlot);
    }

    // ...

    return newChild;
  }
----

updateChild a pour objectif de retourner le child pour qu'il mette à jour le child du parent, qui a fait l'objet d'un performRebuild.

Nous voyons que soit l'objet peut faire l'objet d'un update (canUpdate), soit il doit être reconstruit (inflateWidget).

.canUpdate
[source, dart]
----
  /// Whether the `newWidget` can be used to update an [Element] that currently
  /// has the `oldWidget` as its configuration.
  ///
  /// An element that uses a given widget as its configuration can be updated to
  /// use another widget as its configuration if, and only if, the two widgets
  /// have [runtimeType] and [key] properties that are [operator==].
  ///
  /// If the widgets have no key (their key is null), then they are considered a
  /// match if they have the same type, even if their children are completely
  /// different.
  static bool canUpdate(Widget oldWidget, Widget newWidget) {
    return oldWidget.runtimeType == newWidget.runtimeType
        && oldWidget.key == newWidget.key;
  }
----

=== L'Element peut être mis à jour (canUpdate = true) à partir du widget

Le widget est mis à jour dans l'element dans un premier temps

.on commence ici
[source, dart]
----
        child.update(newWidget);
----

.class Element mets uniquement à jour le widget de l'element
[source, dart]
----

  @mustCallSuper
  void update(covariant Widget newWidget) {
    // ...
    _widget = newWidget;
  }
----

Or update appelle rebuild(force: true), quel que soit la classe, en plus de l'appel à la classe parente

.update dans ComponentElement
[source, dart]
----

  @override
  void update(StatefulWidget newWidget) {
    super.update(newWidget);
    // ..
    rebuild(force: true);
  }
----

.class StatefulElement
[source, dart]
----
  @override
  void update(StatefulWidget newWidget) {
    super.update(newWidget);
    // ..
    rebuild(force: true);
  }
----

.class ProxyElement
[source, dart]
----
  @override
  void update(ProxyWidget newWidget) {
    // ..
    updated(oldWidget);
    // ..
    rebuild(force: true);
  }
----

A noter que pour le proxy une notification est envoyée aux clients

.notifyClients
[source, dart]
----
  @protected
  void updated(covariant ProxyWidget oldWidget) {
    notifyClients(oldWidget);
  }
----

=== Mise à jour du renderObject pour les renderObjectElement

.update pour les renderObjectElement
[source, dart]
----
  @override
  void update(covariant RenderObjectWidget newWidget) {
    super.update(newWidget);
    // ...
    _performRebuild(); // calls widget.updateRenderObject()
  }
----

.updateRenderObject
[source, dart]
----

  @pragma('vm:prefer-inline')
  void _performRebuild() {
    // ...
    (widget as RenderObjectWidget).updateRenderObject(this, renderObject);
    // ...
  }
----

Or la méthode update est surchargé pour tous les renderObject et elle appelle de toute façon updateChild, c'est ainsi que le processus de décorticage du build continue jusqu'à obtenir l'ensemble de l'arbre des elements, jusqu'à tomber sur un Leaf

.update in SingleChildRenderObjectElement
[source, dart]
----
  @override
  void update(SingleChildRenderObjectWidget newWidget) {
    super.update(newWidget);
    // ...
    _child = updateChild(_child, (widget as SingleChildRenderObjectWidget).child, null);
  }
----

Dans le cas d'un multi child l'idée est la même

.updateChildren et multiChildRenderObjectElement
[source, dart]
----

  @override
  void update(MultiChildRenderObjectWidget newWidget) {
    super.update(newWidget);
    final MultiChildRenderObjectWidget multiChildRenderObjectWidget = widget as MultiChildRenderObjectWidget;
    // ...
    _children = updateChildren(_children, multiChildRenderObjectWidget.children, forgottenChildren: _forgottenChildren);
    // ...
  }
----

Pour un Leaf c'est la fin, update n'est pas surchargée.

A noter que dans ce cas nous constatons que l'arbre des widgets, qui est une doubleLinked List n'est pas mis à jour. C'est tout à fait logique, dans la mesure ou le widget pouvait être mis à jour (canUpdate).

=== L'element ne peut pas être mis à jour à partir du widget (canUpdate = false)

Si l'element ne peut pas être mis à jour, c'est la méthode inflateWidget qui est appelée

.inflateWidget dans updateChild() de la classe Element
[source, dart]
----
    // ...
      newChild = inflateWidget(newWidget, newSlot);
    // ...
----

inflateWidget a pour objectif de crééer l'element à partir du widget, comme il n'a pas pu être mis à jour.

.creation de l'element avec inflateWdiget
[source, dart]
----

  @protected
  @pragma('vm:prefer-inline')
  Element inflateWidget(Widget newWidget, Object? newSlot) {

    // ...

    try {
      final Key? key = newWidget.key;
      if (key is GlobalKey) {
        final Element? newChild = _retakeInactiveElement(key, newWidget);
        if (newChild != null) {
          assert(newChild._parent == null);
          assert(() {
            _debugCheckForCycles(newChild);
            return true;
          }());
          try {
            newChild._activateWithParent(this, newSlot);
          } catch (_) {
            // Attempt to do some clean-up if activation fails to leave tree in a reasonable state.
            try {
              deactivateChild(newChild);
            } catch (_) {
              // Clean-up failed. Only surface original exception.
            }
            rethrow;
          }
          final Element? updatedChild = updateChild(newChild, newWidget, newSlot);
          assert(newChild == updatedChild);
          return updatedChild!;
        }
      }
      final Element newChild = newWidget.createElement();
      assert(() {
        _debugCheckForCycles(newChild);
        return true;
      }());
      newChild.mount(this, newSlot);
      assert(newChild._lifecycleState == _ElementLifecycle.active);

      return newChild;
    } finally {
      if (isTimelineTracked) {
        FlutterTimeline.finishSync();
      }
    }
  }
----

La première chose que l'on voit est que si la clé est une globalKey, l'element qui a été désactivé est récupéré à partir de la gloale key, pou être retourné

Pour rappel le processus commence toujours par la désactivation de l'element (nous l'avons vu plus haut)

.deactivateChild dans updateChild
[source, dart]
----
    if (newWidget == null) {
      if (child != null) {
        deactivateChild(child);
      }
      return null;
    }
----

retakeInactiveElement vise donc à récupérer l'element désactivé

._retakeInactiveElement
[source, dart]
----

  Element? _retakeInactiveElement(GlobalKey key, Widget newWidget) {
    final Element? element = key._currentElement;
    // ...
    return element;
  }
----

Sinon l'element est créé à partir du widget, le point essentiel est que chaque widget a un createElement. Une fois l'element créé, l'element appelle mount, c'est le vrai point de départ de reconstruction de l'arbre des renderObjects.

.appel à mount au moment de l'inflateWidget
[source, dart]
----
      final Element newChild = newWidget.createElement();
      // ...
      newChild.mount(this, newSlot);
----

A noter que le newSlot provient de la méthode updateChild, implémentée au niveau le plus bas des elements, chaque element peut décider du slot qu'il veut passer. Le slot a pour objectif de distinguer les enfants d'un element.

.slot pour un MultiChildRenderObjectElement dans updateChild
[source, dart]
----
final Element newChild = inflateWidget(multiChildRenderObjectWidget.children[i], IndexedSlot<Element?>(i, previousChild));
----

L'implémentation par défaut de mount a trois objectifs

* Setter le parent (une des deux propriétés de la double linked list)
* Setter le slot passé en paramètre
* Setter la depth (incrémentation de la depth du parent)
* Setter le owner (owner du parent)
* enregistrer la globalKey si elle est fournie

.mount par défaut
[source, dart]
----
  @mustCallSuper
  void mount(Element? parent, Object? newSlot) {
    // ...
    _parent = parent;
    _slot = newSlot;
    // ...
    _depth = _parent != null ? _parent!.depth + 1 : 1;
    if (parent != null) {
      _owner = parent.owner;
    }
    // ...
    final Key? key = widget.key;
    if (key is GlobalKey) {
      owner!._registerGlobalKey(key, this);
    }
    _updateInheritance();
    attachNotificationTree();
  }
----

Elle attache également le notificationTree (NotificationNode) qui permets aux notifications de remonter par les parents. Elle mets également à jour l'inheritedElement le plus proche dans l'arbre, afin d'être rebuildé si ce dernier change.

(Voir deep dive on inherited and notifications)

.mis à jour du notificationTree et mise à jour de  l'_inheritedElements
[source, dart]
----
  /// Called in [Element.mount] and [Element.activate] to register this element in
  /// the notification tree.
  ///
  /// This method is only exposed so that [NotifiableElementMixin] can be implemented.
  /// Subclasses of [Element] that wish to respond to notifications should mix that
  /// in instead.
  ///
  /// See also:
  ///   * [NotificationListener], a widget that allows listening to notifications.
  @protected
  void attachNotificationTree() {
    _notificationTree = _parent?._notificationTree;
  }

  void _updateInheritance() {
    assert(_lifecycleState == _ElementLifecycle.active);
    _inheritedElements = _parent?._inheritedElements;
  }
----

A partir de ce moment, l'element possède un référence vers son parent. Nous avons vu plus haut que la référence vers son enfant est setté à l'issue du processus d'updateChild. A noter donc que la référence au parent est setté pendant le mount, tandis que la référence à l'enfant est settée à l'issue du processus d'update de tous ses enfants.

.rappel sur _child
[source, dart]
----
    _child = updateChild(_child, (widget as SingleChildRenderObjectWidget).child, null);
----

Nous pouvons cependant considérer que nous disposons de toutes les informations qui construisent l'arbre des élements (au sens algorithmiques)

=== Surcharge de mount et reconstruction du renderObject Tree

la classe RenderObjectElement surcharge la méthode mount, elle commence par appeler la méthode parente afin de procéder au montage de l'arbre des élements, puis créé le renderObject, qui est simplement l'appel que nous devons implémenter lorsque nous construisons un renderObjectWidget. A partir de ce renderObject, mount appelle attachRenderObject.

.mount on renderObjectElement
[source, dart]
----
  @override
  void mount(Element? parent, Object? newSlot) {
    super.mount(parent, newSlot);
    // ...
    _renderObject = (widget as RenderObjectWidget).createRenderObject(this);
    // ...
    attachRenderObject(newSlot);
    super.performRebuild(); // clears the "dirty" flag
  }
----

attachRenderObject procède ainsi:

* Il retrouve tout d'abord le renderObjectElement le plus proche à partir de l'arbre des elements
* Il insère le renderObject comme child de ce dernier avec insertRenderObjectChild
* Il parcourt ensuite l'ensemble des elements à la recherche de parentDataElement et procède dans la foulée à la construction du parentData du renderObject

Le parentData d'un renderObject est un moyen de setter à travers l'arbre des elements des propriétés à l'enfant qui seront utilisées dans la phase de layout du renderObject parent.

.attachRenderObject
[source, dart]
----

  @override
  void attachRenderObject(Object? newSlot) {
    assert(_ancestorRenderObjectElement == null);
    _slot = newSlot;
    _ancestorRenderObjectElement = _findAncestorRenderObjectElement();
    assert(() {
      if (_ancestorRenderObjectElement == null) {
        FlutterError.reportError(FlutterErrorDetails(exception: FlutterError.fromParts(
        <DiagnosticsNode>[
          ErrorSummary(
            'The render object for ${toStringShort()} cannot find ancestor render object to attach to.',
          ),
          ErrorDescription(
            'The ownership chain for the RenderObject in question was:\n  ${debugGetCreatorChain(10)}',
          ),
          ErrorHint(
            'Try wrapping your widget in a View widget or any other widget that is backed by '
            'a $RenderTreeRootElement to serve as the root of the render tree.',
          ),
        ]
        )));
      }
      return true;
    }());
    _ancestorRenderObjectElement?.insertRenderObjectChild(renderObject, newSlot);
    final List<ParentDataElement<ParentData>> parentDataElements = _findAncestorParentDataElements();
    for (final ParentDataElement<ParentData> parentDataElement in parentDataElements) {
      _updateParentData(parentDataElement.widget as ParentDataWidget<ParentData>);
    }
  }
----

._findAncestorRenderObjectElement trouve le plus proche RenderObjectElement parent
[source, dart]
----
  RenderObjectElement? _findAncestorRenderObjectElement() {
    Element? ancestor = _parent;
    while (ancestor != null && ancestor is! RenderObjectElement) {
      // ...
      ancestor = ancestor?._parent;
    }
    // ...
    return ancestor as RenderObjectElement?;
  }
----

insertRenderObjectChild est surchargé au niveau du renderObjectElement le plus haut, ici par exemple pour un SingleChildRenderObjectElement. Logique parce que tous les renderObjectElement n'ont pas d'enfants. A noter ici le cast qui garantit que le renderObject utilise la RenderObjectWithChildMixin

.insertRenderObjectChild dans SingleChildRenderObjectElement
[source, dart]
----
  @override
  void insertRenderObjectChild(RenderObject child, Object? slot) {
    final RenderObjectWithChildMixin<RenderObject> renderObject = this.renderObject as RenderObjectWithChildMixin<RenderObject>;
    assert(slot == null);
    assert(renderObject.debugValidateChild(child));
    renderObject.child = child;
    assert(renderObject == this.renderObject);
  }
----

Pour un MultiChildRenderObjectElement, il est à noter que le renderObject est casté en ContainerRenderObjectMixin.

.insertRenderObjectChild dans MultiChildRenderObjectElement
[source, dart]
----
  @override
  void insertRenderObjectChild(RenderObject child, IndexedSlot<Element?> slot) {
    final ContainerRenderObjectMixin<RenderObject, ContainerParentDataMixin<RenderObject>> renderObject = this.renderObject;
    assert(renderObject.debugValidateChild(child));
    renderObject.insert(child, after: slot.value?.renderObject);
    assert(renderObject == this.renderObject);
  }
----

La différence de mixin s'explique par l'implémentation de la doubleLinkedList.

Dans le cas d'un SingleChildRenderObjectElement, renderObject.child est en réalité un setter, qui se chargera de mettre à jour le parent et l'enfant.

.child setter et mise à jour de la doubleLinked list
[source, dart]
----
  ChildType? _child;
  /// The render object's unique child.
  ChildType? get child => _child;
  set child(ChildType? value) {
    if (_child != null) {
      dropChild(_child!);
    }
    _child = value;
    if (_child != null) {
      adoptChild(_child!);
    }
  }
----

Dans le cas d'un multiChild, le processus ne peut pas être identique, on utilise insert en passant le slot définit par le parent, la méthode insert est définit dans la ContainerRenderObjectMixin.

.insert dans ContainerRenderObjectMixin
[source, dart]
----
  void insert(ChildType child, { ChildType? after }) {
    // ...
    adoptChild(child);
    _insertIntoChildList(child, after: after);
  }
----

La méthode _insertIntoChildList est technique mais elle permets basiquement de définir les _firstChild, _lastChild, nextSibling, previousSibling etc en plus de reconstruire l'arbre des renderObjects.

._insertIntoChildList
[source, dart]
----
  ChildType? _firstChild;
  ChildType? _lastChild;
  void _insertIntoChildList(ChildType child, { ChildType? after }) {
    final ParentDataType childParentData = child.parentData! as ParentDataType;
    // ...
    _childCount += 1;
    // ...
    if (after == null) {
      // insert at the start (_firstChild)
      childParentData.nextSibling = _firstChild;
      if (_firstChild != null) {
        final ParentDataType firstChildParentData = _firstChild!.parentData! as ParentDataType;
        firstChildParentData.previousSibling = child;
      }
      _firstChild = child;
      _lastChild ??= child;
    } else {
      // ...
      final ParentDataType afterParentData = after.parentData! as ParentDataType;
      if (afterParentData.nextSibling == null) {
        // ...
        childParentData.previousSibling = after;
        afterParentData.nextSibling = child;
        _lastChild = child;
      } else {
        // ...
        childParentData.nextSibling = afterParentData.nextSibling;
        childParentData.previousSibling = after;
        // ..
        final ParentDataType childPreviousSiblingParentData = childParentData.previousSibling!.parentData! as ParentDataType;
        final ParentDataType childNextSiblingParentData = childParentData.nextSibling!.parentData! as ParentDataType;
        childPreviousSiblingParentData.nextSibling = child;
        childNextSiblingParentData.previousSibling = child;
        // ...
      }
    }
  }
----

Notons enfin que dans les deux cas, la méthode adoptChild(_child!) est appelée.

C'est elle qui marque le renderObject comme appelle tout d'abord setUpParentData, méthode que nous devons implémenter lorsque nous crééons manuellement un renderObject, elle marque ensuite le renderObject comme nécessitant un layout, et un redessinage (ComopsitingBitsUpdate).

Elle définit enfin le parent de son enfant.

.adoptChild on renderObject
[source, dart]
----
  @mustCallSuper
  @protected
  void adoptChild(RenderObject child) {
    assert(child._parent == null);
    assert(() {
      RenderObject node = this;
      while (node.parent != null) {
        node = node.parent!;
      }
      assert(node != child); // indicates we are about to create a cycle
      return true;
    }());    setupParentData(child);
    markNeedsLayout();
    markNeedsCompositingBitsUpdate();
    markNeedsSemanticsUpdate();

    setupParentData(child);
    markNeedsLayout();
    markNeedsCompositingBitsUpdate();
    markNeedsSemanticsUpdate();
    child._parent = this;
    if (attached) {
      child.attach(_owner!);
    }
    redepthChild(child);
  }
----

A ce stade les deux linkedList sont à jour. Le processus d'updateChild et de décorticage de l'arbre des widgets continue jusqu'à ce que l'on arrive tout en bas du built passé initialement.

Le performRebuild se termine et sette le child le plus haut qu'il doit processer

._child au niveau performRebuild
[source, dart]
----

  @override
  @pragma('vm:notify-debugger-on-exception')
  void performRebuild() {
    Widget? built;
    try {
      // ...
      built = build();
      // ...
    }
    // ...
    try {
      _child = updateChild(_child, built, slot);
      // ...
    }
    // ...
  }
----

Le widgetsBinding appelle alors drawFrame pour entamer la phase de layout (super.drawFrame appelle drawFrame dans le renderer)

.widgetsBinding et buildScope initient le flux
[source, dart]
----

  void drawFrame() {
    // ...
    try {
      if (rootElement != null) {
        buildOwner!.buildScope(rootElement!);
      }
      super.drawFrame();
      // ...
      }
      // ...
  }
----
