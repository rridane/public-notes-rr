:author-url: https://github.com/rridane
:author: rridane
:source-highlighter: rouge
:hardbreaks:
:table-caption!:
:toc: left
:title: deep dive flutter

= Deep dive on internal flutter framework

== Processus de build des widgets méthode par méthode

Le platformDispatcher lance le handleBeginFrame et le handleDrawFrame

Le lancement de l'application lance le runApp. Le runApp appelle scheduleWarmUpFrame. scheduleWarmUpFrame lance comme son nom l'indique la première frame. C'est ici à partir de là que son initialisées les callbacks qui lance la beginFrame et la drawFrame.

== Preambule

A l'instanciation des mixins, la méthode InitInstances est appelées. C'est elle qui va enregistrer les différentes callbacks nécessaires au bon fonctionnment de l'application. Elle est déclarer dans le constructeur de la classe Binding de base

.bindingBase et initInstance
[source, dart]
----
abstract class BindingBase {
  BindingBase() {
    // ...
    initInstances();
    // ...
  }
}
----

A cette étape le widgetsBinding ne déclare aucune callback mais initie le buildOwner principal.

.initBuildOnwer
[source, dart]
----
  void initInstances() {
    // ..
    _buildOwner = BuildOwner();
    buildOwner!.onBuildScheduled = _handleBuildScheduled;
    // ..
  }
----

Le rendererBinding déclare les callbacks à lancer lorsque le platformDispatcher constate des changements sur les metrics, le textScale, la luminosité. Il créé également le rootPipelineOwner qui aura son importance par la suite. Mais surtout il ajoute la callback principale qui servira le build, le layout et le paint.

.renderer et initInstance
[source, dart]
----

  @override
  void initInstances() {
    super.initInstances();
    _instance = this;
    _rootPipelineOwner = createRootPipelineOwner();
    platformDispatcher
      ..onMetricsChanged = handleMetricsChanged
      ..onTextScaleFactorChanged = handleTextScaleFactorChanged
      ..onPlatformBrightnessChanged = handlePlatformBrightnessChanged;
    addPersistentFrameCallback(_handlePersistentFrameCallback);
    initMouseTracker();
    if (kIsWeb) {
      addPostFrameCallback(_handleWebFirstFrame, debugLabel: 'RendererBinding.webFirstFrame');
    }
    rootPipelineOwner.attach(_manifold);
  }
----

_handlePersistentFrameCallback appelle drawFrame du renderer mais celle ci est surchargée par le widgetsBinding, le processus est donc drawFrame dans le widgetsBinding puis qui appelle celle du renderer par la suite.

._handlePersistenFrameCallback -> drawFrame dans le renderer,
[source, dart]
----
  void _handlePersistentFrameCallback(Duration timeStamp) {
    drawFrame();
    _scheduleMouseTrackerUpdate();
  }
----

Et c'est ici que le pipeline est déclaré pour tous les rendering des frame.

.rootPipeline pour les étape de layout, de paint
[source, dart]
----
  void drawFrame() {
    rootPipelineOwner.flushLayout();
    rootPipelineOwner.flushCompositingBits();
    rootPipelineOwner.flushPaint();
    if (sendFramesToEngine) {
      for (final RenderView renderView in renderViews) {
        renderView.compositeFrame(); // this sends the bits to the GPU
      }
      rootPipelineOwner.flushSemantics(); // this sends the semantics to the OS.
      _firstFrameSent = true;
    }
  }
----

== A partir de runApp

scheduleAttachRootWidget créé le rootWidget (app) et l'attach à la view et au buildOwner

.wrapWithDefaultView
[source, dart]
----
  Widget wrapWithDefaultView(Widget rootWidget) {
    return View(
      view: platformDispatcher.implicitView!,
      deprecatedDoNotUseWillBeRemovedWithoutNoticePipelineOwner: pipelineOwner,
      deprecatedDoNotUseWillBeRemovedWithoutNoticeRenderView: renderView,
      child: rootWidget,
    );
  }
----

.attachToBuildOwner
[source, dart]
----
  void attachRootWidget(Widget rootWidget) {
    attachToBuildOwner(RootWidget(
      debugShortDescription: '[root]',
      child: rootWidget,
    ));
  }
----

.run app -> scheduleWramUpFrame
[source,dart]
----
void runApp(Widget app) {
  final WidgetsBinding binding = WidgetsFlutterBinding.ensureInitialized();
  assert(binding.debugCheckZone('runApp'));
  binding
    ..scheduleAttachRootWidget(binding.wrapWithDefaultView(app))
    ..scheduleWarmUpFrame();
}

void scheduleWarmUpFrame() {
  // ...
  Timer.run(() {
    assert(_warmUpFrame);
    handleDrawFrame();
    // ...
  });
  //...

}
----

.scheduleWarmUpFrame->platformDispatcher.scheduleFrame
[source,dart]
----
void scheduleFrame() {
  // ...
  ensureFrameCallbacksRegistered();
  platformDispatcher.scheduleFrame();
  // ...
}
----

.scheduleWarmUpFrame->platformDispatcher.scheduleFrame
[source, dart]
----
void scheduleFrame() {
if (_hasScheduledFrame || !framesEnabled) {
  return;
}
assert(() {
  if (debugPrintScheduleFrameStacks) {
    debugPrintStack(label: 'scheduleFrame() called. Current phase is $schedulerPhase.');
  }
  return true;
}());
ensureFrameCallbacksRegistered();
platformDispatcher.scheduleFrame();
_hasScheduledFrame = true;
}
----

`ensureFrameCallbacksRegistered` s'assure que les deux fonctions de base `onBeginFrame` et `onDrawFrame` sont enregistrées pour la prochaine frame. A partir de ce moment là, le platformDispatcher sait quelles fonctions appeler pour initialiser la reconstruction de la frame.

[source,dart]
----
void ensureFrameCallbacksRegistered() {
  platformDispatcher.onBeginFrame ??= _handleBeginFrame;
  platformDispatcher.onDrawFrame ??= _handleDrawFrame;
}
----

Les méthodes ajoutées sont bien les deux qui lanceront le hanbleBeginFrame et le handleRawFrame

._handleBeginFrame & _handleDrawFrame
[source, dart]
----
  void _handleBeginFrame(Duration rawTimeStamp) {
    // ...
    handleBeginFrame(rawTimeStamp);
  }

  void _handleDrawFrame() {
    // ...
    handleDrawFrame();
  }
----

== handleBeginFrame

`handleBeginFrame` déclenche les premières tâches (animation, touch, normal). animation, touch normal sont des priorités. Chaque priorité dispose de sa liste de callbacks, elles sont associées aux animations, auxs notifications.

[source,dart]
----
void handleBeginFrame(Duration? rawTimeStamp) {
  _frameTimelineTask?.start('Frame');
  // ...
  try {
    // TRANSIENT FRAME CALLBACKS
    _frameTimelineTask?.start('Animate');
    _schedulerPhase = SchedulerPhase.transientCallbacks;
    // ...
    callbacks.forEach((int id, _FrameCallbackEntry callbackEntry) {
      //...
        _invokeFrameCallback(callbackEntry.callback, _currentFrameTimeStamp!, callbackEntry.debugStack);
        //...
    });
    // ...
  } finally {
    _schedulerPhase = SchedulerPhase.midFrameMicrotasks;
  }
}
----

.exemple de transientCallback enregistrée pour une animation
[source, dart]
----
  @protected
  void scheduleTick({ bool rescheduling = false }) {
    //...
    _animationId = SchedulerBinding.instance.scheduleFrameCallback(_tick, rescheduling: rescheduling);
  }
----

NOTE: Le scheduler passe alors à la phase de microtask qui concerne essentiellement des tâches de nettoyage et de préparation des phases de build/layout/paint.

Le platformDispatcher lance alors handleDrawFrame.

== handleDrawFrame et le scheduler prenne le relais du plateformDispatcher

On voit  que la première étape est d'attendre la fin des microtasks.
handleDrawFrame qu'il déclenche d'abord les persistentCallback, puis les frameCallback, puis les postFrameCallback
On voit également que toutes les phases s'enchainent. Les phases sont décrites après.

._handleDrawFrame déclenche les phases de build, layout et frame
[source, dart]
----
  void handleDrawFrame() {
    assert(_schedulerPhase == SchedulerPhase.midFrameMicrotasks);
    _frameTimelineTask?.finish(); // end the "Animate" phase
    try {
      // PERSISTENT FRAME CALLBACKS
      _schedulerPhase = SchedulerPhase.persistentCallbacks;
      for (final FrameCallback callback in List<FrameCallback>.of(_persistentCallbacks)) {
        _invokeFrameCallback(callback, _currentFrameTimeStamp!);
      }

      // POST-FRAME CALLBACKS
      _schedulerPhase = SchedulerPhase.postFrameCallbacks;

      // ...
      Timeline.startSync('POST_FRAME');
      try {
        for (final FrameCallback callback in localPostFrameCallbacks) {
          _invokeFrameCallback(callback, _currentFrameTimeStamp!);
        }
      } finally {
        Timeline.finishSync();
      }
    } finally {
      _schedulerPhase = SchedulerPhase.idle;
      _frameTimelineTask?.finish(); // end the Frame
      // ...
    }
  }
----


== Les scheduledCallback

Nous avons vu par ailleurs défiler les schedulePhase.

.scheduledCallback
[source, dart]
----
enum SchedulerPhase {
  /// No frame is being processed. Tasks (scheduled by
  /// [SchedulerBinding.scheduleTask]), microtasks (scheduled by
  /// [scheduleMicrotask]), [Timer] callbacks, event handlers (e.g. from user
  /// input), and other callbacks (e.g. from [Future]s, [Stream]s, and the like)
  /// may be executing.
  idle,

  /// The transient callbacks (scheduled by
  /// [SchedulerBinding.scheduleFrameCallback]) are currently executing.
  ///
  /// Typically, these callbacks handle updating objects to new animation
  /// states.
  ///
  /// See [SchedulerBinding.handleBeginFrame].
  transientCallbacks,

  /// Microtasks scheduled during the processing of transient callbacks are
  /// current executing.
  ///
  /// This may include, for instance, callbacks from futures resolved during the
  /// [transientCallbacks] phase.
  midFrameMicrotasks,

  /// The persistent callbacks (scheduled by
  /// [SchedulerBinding.addPersistentFrameCallback]) are currently executing.
  ///
  /// Typically, this is the build/layout/paint pipeline. See
  /// [WidgetsBinding.drawFrame] and [SchedulerBinding.handleDrawFrame].
  persistentCallbacks,

  /// The post-frame callbacks (scheduled by
  /// [SchedulerBinding.addPostFrameCallback]) are currently executing.
  ///
  /// Typically, these callbacks handle cleanup and scheduling of work for the
  /// next frame.
  ///
  /// See [SchedulerBinding.handleDrawFrame].
  postFrameCallbacks,
}

----

== Phase de build

NOTE: _invokeFrameCallback (dans le handleDrawFrame) appelle les callback de frame, elle appelle directement drawFrame dans le widgetsBinding qui lui même appelle buildScope du buildOwner. (Pour rappel drawFrame du widgetsBinding surcharge celle du rendererBinding, c'est don celle du widgetsBinding qui est appelée)

Le buildOwner détient l'arbre des widgets, c'est lui qui le reconstruit également.

.handleDrawFrame -> buildScope du buildOwner
[source, dart]
----
  @override
  void drawFrame() {
      // ...
        buildOwner!.buildScope(rootElement!);
      // ...
  }
----

BuildScope appelle rebuild

.buildScope -> rebuild (WidgetsBinding)
[source, dart]
----
  void buildScope(Element context, [ VoidCallback? callback ]) {
        //...
        try {
          element.rebuild();
        } catch (e, stack) {
          // ...
        }
   }

----

Rebuild appelle performRebuild, à noter le le performeRebuild et le @mustCallSuper

.rebuild -> performRebuild
[source, dart]
----
  @pragma('vm:prefer-inline')
  void rebuild({bool force = false}) {
    // ...
    try {
      performRebuild();
    } finally {
      // ...
    }
    // ...
  }

  /// Cause the widget to update itself.
  ///
  /// Called by [rebuild] after the appropriate checks have been made.
  ///
  /// The base implementation only clears the [dirty] flag.
  @protected
  @mustCallSuper
  void performRebuild() {
    _dirty = false;
  }
----

Le point clé ici est que performRebuild doit appeler sa superclass, qui est componentElement, et c'est ici que sont appelés sucessivement les méthodes build (de tous les widgets) et updateChild à la suite du build des widgets.

Prenons l'exemple d'un statefulElement qui a été marqué comme dirty.

Dans le stateFulElement, performRebuild appelle tout d'abord notre didChangeDependencies si les _didChangeDependencies a été marqué à true, ceci à été calculé pendant la phase du setState, et du scheduleFrameFor

.performRebuild appelle sa méthode parent
[source, dart]
----
  @override
  void performRebuild() {
    if (_didChangeDependencies) {
      state.didChangeDependencies();
      _didChangeDependencies = false;
    }
    super.performRebuild();
  }
----

Son parent est le componentElement

.performRebuild dans le ComponentElement
[source, dart]
----

abstract class ComponentElement extends Element {
  /// Creates an element that uses the given widget as its configuration.
  ComponentElement(super.widget);

  Element? _child;

  bool _debugDoingBuild = false;
  @override
  bool get debugDoingBuild => _debugDoingBuild;

  @override
  Element? get renderObjectAttachingChild => _child;

  @override
  void mount(Element? parent, Object? newSlot) {
    super.mount(parent, newSlot);
    assert(_child == null);
    assert(_lifecycleState == _ElementLifecycle.active);
    _firstBuild();
    assert(_child != null);
  }

  void _firstBuild() {
    // StatefulElement overrides this to also call state.didChangeDependencies.
    rebuild(); // This eventually calls performRebuild.
  }

  @override
  @pragma('vm:notify-debugger-on-exception')
  void performRebuild() {
    Widget? built;
    try {
      // ..
      built = build();
      // ...
    } finally {
      // ...
      super.performRebuild(); // clears the "dirty" flag
    }
    try {
      _child = updateChild(_child, built, slot);
      assert(_child != null);
    } catch (e, stack) {
      // ...
      _child = updateChild(null, built, slot);
    }
  }
  }

----

== La phase de layout

Le renderer prends la suite conformément aux appels enregistrés dans les persistentCallback du scheduler

.revenons au drawFrame
[source, dart]
----
  void drawFrame() {
    rootPipelineOwner.flushLayout();
    rootPipelineOwner.flushCompositingBits();
    rootPipelineOwner.flushPaint();
    if (sendFramesToEngine) {
      for (final RenderView renderView in renderViews) {
        renderView.compositeFrame(); // this sends the bits to the GPU
      }
      rootPipelineOwner.flushSemantics(); // this sends the semantics to the OS.
      _firstFrameSent = true;
    }
  }
----

flushLayout appelle _layoutWithoutResize sur tous les renderObjects dirty mais également sur tous les enfants

.flushLayout
[source, dart]
----
  void flushLayout() {
  // ...
        for (int i = 0; i < dirtyNodes.length; i++) {
          // ...
          if (node._needsLayout && node.owner == this) {
            node._layoutWithoutResize();
          }
          // ...
          for (final PipelineOwner child in _children) {
            child.flushLayout();
          }
          // ..
        }
        // ..
  }
----

_layoutWithoutResize appelle performLayout

.appelle des performLayout
[source, dart]
----
  void _layoutWithoutResize() {
    // ...
    try {
      performLayout();
      markNeedsSemanticsUpdate();
    } catch (e, stack) {
      // ...
    }
    _needsLayout = false;
  }
----

== La phase de paint

Pour rappel elle est appelée par le renderer

.Rappel
[source, dart]
----
// ...
    rootPipelineOwner.flushPaint();
// ...
----

flushPaint appelle repaintCompositedChild et appelle également flush paint sur tous les enfants

.flushPaint -> repaintCompositeChild
[source, dart]
----
      for (final RenderObject node in dirtyNodes..sort((RenderObject a, RenderObject b) => b.depth - a.depth)) {
        // ...
        if ((node._needsPaint || node._needsCompositedLayerUpdate) && node.owner == this) {
          // ...
            if (node._needsPaint) {
              PaintingContext.repaintCompositedChild(node);
            } else {
                // ...
            }
          }
        // ...
      }
      for (final PipelineOwner child in _children) {
        child.flushPaint();
      }
----

repaintCompositeChild appelle _paintWithContext

.repaintCompositeChild -> _paintWithContext
[source, dart]
----
  /// Repaint the given render object.
  ///
  /// The render object must be attached to a [PipelineOwner], must have a
  /// composited layer, and must be in need of painting. The render object's
  /// layer, if any, is re-used, along with any layers in the subtree that don't
  /// need to be repainted.
  ///
  /// See also:
  ///
  ///  * [RenderObject.isRepaintBoundary], which determines if a [RenderObject]
  ///    has a composited layer.
  static void repaintCompositedChild(RenderObject child, { bool debugAlsoPaintedParent = false }) {
    assert(child._needsPaint);
    _repaintCompositedChild(
      child,
      debugAlsoPaintedParent: debugAlsoPaintedParent,
    );
  }

  static void _repaintCompositedChild(
    RenderObject child, {
    bool debugAlsoPaintedParent = false,
    PaintingContext? childContext,
  }) {
    // ...
    childContext ??= PaintingContext(childLayer, child.paintBounds);
    child._paintWithContext(childContext, Offset.zero);
    // ..
  }

----

_paintWithContext appelle paint

.paint
[source, dart]
----
  void _paintWithContext(PaintingContext context, Offset offset) {
    // ...
    try {
      paint(context, offset);
      // ...
    } catch (e, stack) {
      // ..
    }
    // ..
  }
----


